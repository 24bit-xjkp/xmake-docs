<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="//cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h2>Note: this is the mirror page, if you want to see the original page, please goto: </h2>
<a href="https://xmake.io/#/zh-cn/manual/custom_rule">https://xmake.io/#/zh-cn/manual/custom_rule</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <p>在2.2.1版本之后，xmake不仅原生内置支持多种语言文件的构建，而且还可以通过自定义构建规则，让用户自己来实现复杂的未知文件构建。</p>
<p>我们可以通过预先设置规则支持的文件后缀，来扩展其他文件的构建支持：</p>
<pre><code class="lang-lua">-- 定义一个markdown文件的构建规则
rule(&quot;markdown&quot;)
    set_extensions(&quot;.md&quot;, &quot;.markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. &quot;.html&quot;))
    end)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)

    -- 使test目标支持markdown文件的构建规则
    add_rules(&quot;markdown&quot;)

    -- 添加markdown文件的构建
    add_files(&quot;src/*.md&quot;)
    add_files(&quot;src/*.markdown&quot;)
</code></pre>
<p>我们也可以指定某些零散的其他文件作为markdown规则来处理：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    -- ...
    add_files(&quot;src/test/*.md.in&quot;, {rule = &quot;markdown&quot;})
</code></pre>
<p>一个target可以叠加应用多个rules去更加定制化实现自己的构建行为，甚至支持不同的构建环境。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>通过<code>add_files(&quot;*.md&quot;, {rule = &quot;markdown&quot;})</code>方式指定的规则，优先级高于<code>add_rules(&quot;markdown&quot;)</code>设置的规则。<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#rule">rule</a></td>
<td>定义规则</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleadd_imports">add_imports</a></td>
<td>为所有自定义脚本预先导入扩展模块</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleset_extensions">set_extensions</a></td>
<td>设置规则支持的文件扩展类型</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_load">on_load</a></td>
<td>自定义加载脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleon_link">on_link</a></td>
<td>自定义链接脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#ruleon_build">on_build</a></td>
<td>自定义编译脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_clean">on_clean</a></td>
<td>自定义清理脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_package">on_package</a></td>
<td>自定义打包脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_install">on_install</a></td>
<td>自定义安装脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_uninstall">on_uninstall</a></td>
<td>自定义卸载脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_build_file">on_build_file</a></td>
<td>自定义编译脚本, 实现单文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleon_build_files">on_build_files</a></td>
<td>自定义编译脚本, 实现多文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_load">before_load</a></td>
<td>自定义加载前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_link">before_link</a></td>
<td>自定义链接前的脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#rulebefore_build">before_build</a></td>
<td>自定义编译前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_clean">before_clean</a></td>
<td>自定义清理前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_package">before_package</a></td>
<td>自定义打包前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_install">before_install</a></td>
<td>自定义安装前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_uninstall">before_uninstall</a></td>
<td>自定义卸载前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_build_file">before_build_file</a></td>
<td>自定义编译前的脚本, 实现单文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_build_files">before_build_files</a></td>
<td>自定义编译前的脚本, 实现多文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_load">after_load</a></td>
<td>自定义加载后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_link">after_link</a></td>
<td>自定义链接后的脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#ruleafter_build">after_build</a></td>
<td>自定义编译后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_clean">after_clean</a></td>
<td>自定义清理后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_package">after_package</a></td>
<td>自定义打包后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_install">after_install</a></td>
<td>自定义安装后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_uninstall">after_uninstall</a></td>
<td>自定义卸载后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_build_file">after_build_file</a></td>
<td>自定义编译后的脚本, 实现单文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_build_files">after_build_files</a></td>
<td>自定义编译后的脚本, 实现多文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rule_end">rule_end</a></td>
<td>结束定义规则</td>
<td>&gt;= 2.1.9</td>
</tr>
</tbody>
</table>
<h3 id="-">内建规则</h3>
<p>自从2.2.1版本后，xmake提供了一些内置规则去简化日常xmake.lua描述，以及一些常用构建环境的支持。</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mode-debug">mode.debug</a></td>
<td>调试模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-release">mode.release</a></td>
<td>发布模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-releasedbg">mode.releasedbg</a></td>
<td>发布模式编译规则（带调试符号）</td>
<td>&gt;= 2.3.4</td>
</tr>
<tr>
<td><a href="#mode-minsizerel">mode.minsizerel</a></td>
<td>发布模式编译规则（最小编译）</td>
<td>&gt;= 2.3.4</td>
</tr>
<tr>
<td><a href="#mode-check">mode.check</a></td>
<td>检测模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-profile">mode.profile</a></td>
<td>性能分析模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-coverage">mode.coverage</a></td>
<td>覆盖分析编译模式规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-valgrind">mode.valgrind</a></td>
<td>Valgrind分析检测模式规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#mode-asan">mode.asan</a></td>
<td>AddressSanitizer分析检测模式规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#mode-tsan">mode.tsan</a></td>
<td>ThreadSanitizer分析检测模式规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#mode-lsan">mode.lsan</a></td>
<td>LeakSanitizer分析检测模式规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#mode-ubsan">mode.ubsan</a></td>
<td>UndefinedBehaviorSanitizer分析检测模式规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#qt-static">qt.static</a></td>
<td>Qt静态库编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#qt-shared">qt.shared</a></td>
<td>Qt动态库编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#qt-console">qt.console</a></td>
<td>Qt控制台编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#qt-quickapp">qt.quickapp</a></td>
<td>Qt QuickApp应用程序编译规则</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#qt-quickapp_static">qt.quickapp_static</a></td>
<td>Qt QuickApp应用程序编译规则（静态链接）</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#qt-widgetapp">qt.widgetapp</a></td>
<td>Qt WidgetApp应用程序编译规则</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#qt-widgetapp_static">qt.widgetapp_static</a></td>
<td>Qt WidgetApp应用程序编译规则（静态链接）</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#xcode-bundle">xcode.bundle</a></td>
<td>Xcode Bundle编译规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#xcode-framework">xcode.framework</a></td>
<td>Xcode Framework编译规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#xcode-application">xcode.application</a></td>
<td>Xcode iOS/MacOS App编译规则</td>
<td>&gt;= 2.3.3</td>
</tr>
<tr>
<td><a href="#wdk-umdf-driver">wdk.umdf.driver</a></td>
<td>WDK环境umdf驱动编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-umdf-binary">wdk.umdf.binary</a></td>
<td>WDK环境umdf驱动应用编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-kmdf-driver">wdk.kmdf.driver</a></td>
<td>WDK环境kmdf驱动编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-kmdf-binary">wdk.kmdf.binary</a></td>
<td>WDK环境kmdf驱动应用编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-wdm-driver">wdk.wdm.driver</a></td>
<td>WDK环境wdm驱动编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-wdm-binary">wdk.wdm.binary</a></td>
<td>WDK环境wdm驱动应用编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
</tbody>
</table>
<p>我们可以通过运行以下命令，查看完整的内置规则列表：</p>
<pre><code class="lang-bash">$ xmake show -l rules
</code></pre>
<h4 id="mode-debug">mode.debug</h4>
<p>为当前工程xmake.lua添加debug编译模式的配置规则，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.debug&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">if is_mode(&quot;debug&quot;) then
    set_symbols(&quot;debug&quot;)
    set_optimize(&quot;none&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m debug</code>来切换到此编译模式。</p>
<h4 id="mode-release">mode.release</h4>
<p>为当前工程xmake.lua添加release编译模式的配置规则，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.release&quot;)
</code></pre>
<p>!&gt; 此模式默认不会带调试符号。</p>
<p>相当于：</p>
<pre><code class="lang-lua">if is_mode(&quot;release&quot;) then
    set_symbols(&quot;hidden&quot;)
    set_optimize(&quot;fastest&quot;)
    set_strip(&quot;all&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m release</code>来切换到此编译模式。</p>
<h4 id="mode-releasedbg">mode.releasedbg</h4>
<p>为当前工程xmake.lua添加releasedbg编译模式的配置规则，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.releasedbg&quot;)
</code></pre>
<p>!&gt; 与release模式相比，此模式还会额外开启调试符号，这通常是非常有用的。</p>
<p>相当于：</p>
<pre><code class="lang-lua">if is_mode(&quot;releasedbg&quot;) then
    set_symbols(&quot;debug&quot;)
    set_optimize(&quot;fastest&quot;)
    set_strip(&quot;all&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m releasedbg</code>来切换到此编译模式。</p>
<h4 id="mode-minsizerel">mode.minsizerel</h4>
<p>为当前工程xmake.lua添加minsizerel编译模式的配置规则，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.minsizerel&quot;)
</code></pre>
<p>!&gt; 与release模式相比，此模式更加倾向于最小代码编译优化，而不是速度优先。</p>
<p>相当于：</p>
<pre><code class="lang-lua">if is_mode(&quot;minsizerel&quot;) then
    set_symbols(&quot;hidden&quot;)
    set_optimize(&quot;smallest&quot;)
    set_strip(&quot;all&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m minsizerel</code>来切换到此编译模式。</p>
<h4 id="mode-check">mode.check</h4>
<p>为当前工程xmake.lua添加check编译模式的配置规则，一般用于内存检测，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.check&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">if is_mode(&quot;check&quot;) then
    set_symbols(&quot;debug&quot;)
    set_optimize(&quot;none&quot;)
    add_cxflags(&quot;-fsanitize=address&quot;, &quot;-ftrapv&quot;)
    add_mxflags(&quot;-fsanitize=address&quot;, &quot;-ftrapv&quot;)
    add_ldflags(&quot;-fsanitize=address&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m check</code>来切换到此编译模式。</p>
<h4 id="mode-profile">mode.profile</h4>
<p>为当前工程xmake.lua添加profile编译模式的配置规则，一般用于性能分析，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.profile&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">if is_mode(&quot;profile&quot;) then
    set_symbols(&quot;debug&quot;)
    add_cxflags(&quot;-pg&quot;)
    add_ldflags(&quot;-pg&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m profile</code>来切换到此编译模式。</p>
<h4 id="mode-coverage">mode.coverage</h4>
<p>为当前工程xmake.lua添加coverage编译模式的配置规则，一般用于覆盖分析，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.coverage&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">if is_mode(&quot;coverage&quot;) then
    add_cxflags(&quot;--coverage&quot;)
    add_mxflags(&quot;--coverage&quot;)
    add_ldflags(&quot;--coverage&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m coverage</code>来切换到此编译模式。</p>
<h4 id="mode-valgrind">mode.valgrind</h4>
<p>此模式提供valgrind内存分析检测支持。</p>
<pre><code class="lang-lua">add_rules(&quot;mode.valgrind&quot;)
</code></pre>
<p>我们可以通过：<code>xmake f -m valgrind</code>来切换到此编译模式。</p>
<h4 id="mode-asan">mode.asan</h4>
<p>此模式提供AddressSanitizer内存分析检测支持。</p>
<pre><code class="lang-lua">add_rules(&quot;mode.asan&quot;)
</code></pre>
<p>我们可以通过：<code>xmake f -m asan</code>来切换到此编译模式。</p>
<h4 id="mode-tsan">mode.tsan</h4>
<p>此模式提供ThreadSanitizer内存分析检测支持。</p>
<pre><code class="lang-lua">add_rules(&quot;mode.tsan&quot;)
</code></pre>
<p>我们可以通过：<code>xmake f -m tsan</code>来切换到此编译模式。</p>
<h4 id="mode-lsan">mode.lsan</h4>
<p>此模式提供LeakSanitizer内存分析检测支持。</p>
<pre><code class="lang-lua">add_rules(&quot;mode.lsan&quot;)
</code></pre>
<p>我们可以通过：<code>xmake f -m lsan</code>来切换到此编译模式。</p>
<h4 id="mode-ubsan">mode.ubsan</h4>
<p>此模式提供UndefinedBehaviorSanitizer内存分析检测支持。</p>
<pre><code class="lang-lua">add_rules(&quot;mode.ubsan&quot;)
</code></pre>
<p>我们可以通过：<code>xmake f -m ubsan</code>来切换到此编译模式。</p>
<h4 id="qt-static">qt.static</h4>
<p>用于编译生成Qt环境的静态库程序：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;qt.static&quot;)
    add_files(&quot;src/*.cpp&quot;)
    add_frameworks(&quot;QtNetwork&quot;, &quot;QtGui&quot;)
</code></pre>
<h4 id="qt-shared">qt.shared</h4>
<p>用于编译生成Qt环境的动态库程序：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;qt.shared&quot;)
    add_files(&quot;src/*.cpp&quot;)
    add_frameworks(&quot;QtNetwork&quot;, &quot;QtGui&quot;)
</code></pre>
<h4 id="qt-console">qt.console</h4>
<p>用于编译生成Qt环境的控制台程序：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;qt.console&quot;)
    add_files(&quot;src/*.cpp&quot;)
</code></pre>
<h4 id="qt-quickapp">qt.quickapp</h4>
<p>用于编译生成Qt环境的Quick(qml) ui应用程序。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;qt.quickapp&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/qml.qrc&quot;)
</code></pre>
<h4 id="qt-quickapp_static">qt.quickapp_static</h4>
<p>用于编译生成Qt环境的Quick(qml) ui应用程序（静态链接版本）。</p>
<p>!&gt; 需要切换到静态库版本Qt SDK</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;qt.quickapp_static&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/qml.qrc&quot;)
</code></pre>
<h4 id="qt-widgetapp">qt.widgetapp</h4>
<p>用于编译Qt Widgets(ui/moc)应用程序</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;qt.widgetapp&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/mainwindow.ui&quot;)
    add_files(&quot;src/mainwindow.h&quot;)  -- 添加带有 Q_OBJECT 的meta头文件
</code></pre>
<h4 id="qt-widgetapp_static">qt.widgetapp_static</h4>
<p>用于编译Qt Widgets(ui/moc)应用程序（静态库版本）</p>
<p>!&gt; 需要切换到静态库版本Qt SDK</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;qt.widgetapp_static&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/mainwindow.ui&quot;)
    add_files(&quot;src/mainwindow.h&quot;)  -- 添加带有 Q_OBJECT 的meta头文件
</code></pre>
<p>更多Qt相关描述见：<a href="https://github.com/xmake-io/xmake/issues/160">#160</a></p>
<h4 id="xcode-bundle">xcode.bundle</h4>
<p>用于编译生成ios/macos bundle程序</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;xcode.bundle&quot;)
    add_files(&quot;src/*.m&quot;)
    add_files(&quot;src/Info.plist&quot;)
</code></pre>
<h4 id="xcode-framework">xcode.framework</h4>
<p>用于编译生成ios/macos framework程序</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;xcode.framework&quot;)
    add_files(&quot;src/*.m&quot;)
    add_files(&quot;src/Info.plist&quot;)
</code></pre>
<h4 id="xcode-application">xcode.application</h4>
<p>用于编译生成ios/macos应用程序</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;xcode.application&quot;)
    add_files(&quot;src/*.m&quot;, &quot;src/**.storyboard&quot;, &quot;src/*.xcassets&quot;)
    add_files(&quot;src/Info.plist&quot;)
</code></pre>
<h4 id="wdk-env-kmdf">wdk.env.kmdf</h4>
<p>应用WDK下kmdf的编译环境设置，需要配合：<code>wdk.[driver|binary|static|shared]</code>等规则来使用。</p>
<h4 id="wdk-env-umdf">wdk.env.umdf</h4>
<p>应用WDK下umdf的编译环境设置，需要配合：<code>wdk.[driver|binary|static|shared]</code>等规则来使用。</p>
<h4 id="wdk-env-wdm">wdk.env.wdm</h4>
<p>应用WDK下wdm的编译环境设置，需要配合：<code>wdk.[driver|binary|static|shared]</code>等规则来使用。</p>
<h4 id="wdk-driver">wdk.driver</h4>
<p>编译生成windows下基于WDK环境的驱动程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">-- add target
target(&quot;echo&quot;)

    -- add rules
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.kmdf&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;) 
    add_files(&quot;driver/*.inx&quot;)

    -- add includedirs
    add_includedirs(&quot;exe&quot;)
</code></pre>
<h4 id="wdk-binary">wdk.binary</h4>
<p>编译生成windows下基于WDK环境的可执行程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">-- add target
target(&quot;app&quot;)

    -- add rules
    add_rules(&quot;wdk.binary&quot;, &quot;wdk.env.umdf&quot;)

    -- add files
    add_files(&quot;exe/*.cpp&quot;) 
</code></pre>
<h4 id="wdk-static">wdk.static</h4>
<p>编译生成windows下基于WDK环境的静态库程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">target(&quot;nonpnp&quot;)

    -- add rules
    add_rules(&quot;wdk.static&quot;, &quot;wdk.env.kmdf&quot;)

    -- add flags for rule: wdk.tracewpp
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TraceEvents(LEVEL,FLAGS,MSG,...)&quot;, &quot;-func:Hexdump((LEVEL,FLAGS,MSG,...))&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
</code></pre>
<h4 id="wdk-shared">wdk.shared</h4>
<p>编译生成windows下基于WDK环境的动态库程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">target(&quot;nonpnp&quot;)

    -- add rules
    add_rules(&quot;wdk.shared&quot;, &quot;wdk.env.wdm&quot;)

    -- add flags for rule: wdk.tracewpp
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TraceEvents(LEVEL,FLAGS,MSG,...)&quot;, &quot;-func:Hexdump((LEVEL,FLAGS,MSG,...))&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
</code></pre>
<h4 id="wdk-tracewpp">wdk.tracewpp</h4>
<p>用于启用tracewpp预处理源文件：</p>
<pre><code class="lang-lua">target(&quot;nonpnp&quot;)

    -- add rules
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.kmdf&quot;)

    -- add flags for rule: wdk.tracewpp
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TraceEvents(LEVEL,FLAGS,MSG,...)&quot;, &quot;-func:Hexdump((LEVEL,FLAGS,MSG,...))&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
    add_files(&quot;driver/*.rc&quot;)
</code></pre>
<p>更多WDK规则描述见：<a href="https://github.com/xmake-io/xmake/issues/159">#159</a></p>
<h4 id="win-sdk-application">win.sdk.application</h4>
<p>编译生成winsdk应用程序。</p>
<pre><code class="lang-lua">-- add rules
add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)

-- define target
target(&quot;usbview&quot;)

    -- windows application
    add_rules(&quot;win.sdk.application&quot;)

    -- add files
    add_files(&quot;*.c&quot;, &quot;*.rc&quot;)
    add_files(&quot;xmlhelper.cpp&quot;, {rule = &quot;win.sdk.dotnet&quot;})
</code></pre>
<h4 id="wdk-sdk-dotnet">wdk.sdk.dotnet</h4>
<p>用于指定某些c++源文件作为c++.net来编译。</p>
<pre><code class="lang-lua">add_files(&quot;xmlhelper.cpp&quot;, {rule = &quot;win.sdk.dotnet&quot;})
</code></pre>
<h3 id="rule">rule</h3>
<h4 id="-">定义规则</h4>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    set_extensions(&quot;.md&quot;, &quot;.markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. &quot;.html&quot;))
    end)
</code></pre>
<h3 id="rule-add_imports">rule:add_imports</h3>
<h4 id="-">为所有自定义脚本预先导入扩展模块</h4>
<p>使用方式和说明请见：<a href="#targetadd_imports">target:add_imports</a>，用法相同。</p>
<h3 id="rule-set_extensions">rule:set_extensions</h3>
<h4 id="-">设置规则支持的文件扩展类型</h4>
<p>通过设置支持的扩展文件类型，将规则应用于带这些后缀的文件上，例如：</p>
<pre><code class="lang-lua">-- 定义一个markdown文件的构建规则
rule(&quot;markdown&quot;)
    set_extensions(&quot;.md&quot;, &quot;.markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. &quot;.html&quot;))
    end)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)

    -- 使test目标支持markdown文件的构建规则
    add_rules(&quot;markdown&quot;)

    -- 添加markdown文件的构建
    add_files(&quot;src/*.md&quot;)
    add_files(&quot;src/*.markdown&quot;)
</code></pre>
<h3 id="rule-on_load">rule:on_load</h3>
<h4 id="-">自定义加载脚本</h4>
<p>用于实现自定规则的加载脚本，当加载target的时候，会被执行，可在里面自定义设置一些target配置，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    on_load(function (target)
        target:add(&quot;defines&quot;, &quot;-DTEST&quot;)
    end)
</code></pre>
<h3 id="rule-on_link">rule:on_link</h3>
<h4 id="-">自定义链接脚本</h4>
<p>用于实现自定规则的链接脚本，会覆盖被应用的target的默认链接行为，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    on_link(function (target)
    end)
</code></pre>
<h3 id="rule-on_build">rule:on_build</h3>
<h4 id="-">自定义编译脚本</h4>
<p>用于实现自定规则的构建脚本，会覆盖被应用的target的默认构建行为，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_build(function (target)
    end)
</code></pre>
<h3 id="rule-on_clean">rule:on_clean</h3>
<h4 id="-">自定义清理脚本</h4>
<p>用于实现自定规则的清理脚本会，覆盖被应用的target的默认清理行为，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_clean(function (target)
        -- remove sourcefile.html
    end)
</code></pre>
<h3 id="rule-on_package">rule:on_package</h3>
<h4 id="-">自定义打包脚本</h4>
<p>用于实现自定规则的打包脚本，覆盖被应用的target的默认打包行为, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_package(function (target)
        -- package sourcefile.html
    end)
</code></pre>
<h3 id="rule-on_install">rule:on_install</h3>
<h4 id="-">自定义安装脚本</h4>
<p>用于实现自定规则的安装脚本，覆盖被应用的target的默认安装行为, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_install(function (target)
    end)
</code></pre>
<h3 id="rule-on_uninstall">rule:on_uninstall</h3>
<h4 id="-">自定义卸载脚本</h4>
<p>用于实现自定规则的卸载脚本，覆盖被应用的target的默认卸载行为, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_uninstall(function (target)
    end)
</code></pre>
<h3 id="rule-on_build_file">rule:on_build_file</h3>
<h4 id="-">自定义编译脚本，一次处理一个源文件</h4>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        print(&quot;%%%d: %s&quot;, opt.progress, sourcefile)
    end)
</code></pre>
<p>其中第三个参数opt是可选参数，用于获取一些编译过程中的信息状态，例如：opt.progress 为当期的编译进度。</p>
<h3 id="rule-on_build_files">rule:on_build_files</h3>
<h4 id="-">自定义编译脚本，一次处理多个源文件</h4>
<p>大部分的自定义构建规则，每次都是处理单独一个文件，输出一个目标文件，例如：a.c =&gt; a.o</p>
<p>但是，有些情况下，我们需要同时输入多个源文件一起构建生成一个目标文件，例如：a.c b.c d.c =&gt; x.o</p>
<p>对于这种情况，我们可以通过自定义这个脚本来实现：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_build_files(function (target, sourcebatch, opt)
        -- build some source files
        for _, sourcefile in ipairs(sourcebatch.sourcefiles) do
            -- ...
        end
    end)
</code></pre>
<h3 id="rule-before_load">rule:before_load</h3>
<h4 id="-">自定义加载前脚本</h4>
<p>用于实现自定义target加载前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    before_load(function (target)
        target:add(&quot;defines&quot;, &quot;-DTEST&quot;)
    end)
</code></pre>
<h3 id="rule-before_link">rule:before_link</h3>
<h4 id="-">自定义链接前脚本</h4>
<p>用于实现自定义target链接前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    before_link(function (target)
    end)
</code></pre>
<h3 id="rule-before_build">rule:before_build</h3>
<h4 id="-">自定义编译前脚本</h4>
<p>用于实现自定义target构建前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_build(function (target)
    end)
</code></pre>
<h3 id="rule-before_clean">rule:before_clean</h3>
<h4 id="-">自定义清理前脚本</h4>
<p>用于实现自定义target清理前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_clean(function (target)
    end)
</code></pre>
<h3 id="rule-before_package">rule:before_package</h3>
<h4 id="-">自定义打包前脚本</h4>
<p>用于实现自定义target打包前的执行脚本, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_package(function (target)
    end)
</code></pre>
<h3 id="rule-before_install">rule:before_install</h3>
<h4 id="-">自定义安装前脚本</h4>
<p>用于实现自定义target安装前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_install(function (target)
    end)
</code></pre>
<h3 id="rule-before_uninstall">rule:before_uninstall</h3>
<h4 id="-">自定义卸载前脚本</h4>
<p>用于实现自定义target卸载前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_uninstall(function (target)
    end)
</code></pre>
<h3 id="rule-before_build_file">rule:before_build_file</h3>
<h4 id="-">自定义编译前脚本，一次处理一个源文件</h4>
<p>跟<a href="#ruleon_build_file">rule:on_build_file</a>用法类似，不过这个接口被调用的时机是在编译某个源文件之前，<br>一般用于对某些源文件进行编译前的预处理。</p>
<h3 id="rule-before_build_files">rule:before_build_files</h3>
<h4 id="-">自定义编译前脚本，一次处理多个源文件</h4>
<p>跟<a href="#ruleon_build_files">rule:on_build_files</a>用法类似，不过这个接口被调用的时机是在编译某些源文件之前，<br>一般用于对某些源文件进行编译前的预处理。</p>
<h3 id="rule-after_load">rule:after_load</h3>
<h4 id="-">自定义加载后脚本</h4>
<p>用于实现自定义target加载后的执行脚本，用法跟<a href="#rulebefore_load">rule:before_load</a>类似。</p>
<h3 id="rule-after_link">rule:after_link</h3>
<h4 id="-">自定义链接后脚本</h4>
<p>用于实现自定义target链接后的执行脚本，用法跟<a href="#rulebefore_link">rule:before_link</a>类似。</p>
<h3 id="rule-after_build">rule:after_build</h3>
<h4 id="-">自定义编译后脚本</h4>
<p>用于实现自定义target构建后的执行脚本，用法跟<a href="#rulebefore_build">rule:before_build</a>类似。</p>
<h3 id="rule-after_clean">rule:after_clean</h3>
<h4 id="-">自定义清理后脚本</h4>
<p>用于实现自定义target清理后的执行脚本，用法跟<a href="#rulebefore_clean">rule:before_clean</a>类似。</p>
<h3 id="rule-after_package">rule:after_package</h3>
<h4 id="-">自定义打包后脚本</h4>
<p>用于实现自定义target打包后的执行脚本, 用法跟<a href="#rulebefore_package">rule:before_package</a>类似。</p>
<h3 id="rule-after_install">rule:after_install</h3>
<h4 id="-">自定义安装后脚本</h4>
<p>用于实现自定义target安装后的执行脚本，用法跟<a href="#rulebefore_install">rule:before_install</a>类似。</p>
<h3 id="rule-after_uninstall">rule:after_uninstall</h3>
<h4 id="-">自定义卸载后脚本</h4>
<p>用于实现自定义target卸载后的执行脚本，用法跟<a href="#rulebefore_uninstall">rule:before_uninstall</a>类似。</p>
<h3 id="rule-after_build_file">rule:after_build_file</h3>
<h4 id="-">自定义编译后脚本，一次处理一个源文件</h4>
<p>跟<a href="#ruleon_build_file">rule:on_build_file</a>用法类似，不过这个接口被调用的时机是在编译某个源文件之后，<br>一般用于对某些编译后对象文件进行后期处理。</p>
<h3 id="rule-after_build_files">rule:after_build_files</h3>
<h4 id="-">自定义编译后脚本，一次处理多个源文件</h4>
<p>跟<a href="#ruleon_build_files">rule:on_build_files</a>用法类似，不过这个接口被调用的时机是在编译某些源文件之后，<br>一般用于对某些编译后对象文件进行后期处理。</p>
<h3 id="rule_end">rule_end</h3>
<h4 id="-">结束定义规则</h4>
<p>这个是可选的，如果想要手动结束rule的定义，可以调用它：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    -- ..
rule_end()
</code></pre>
</article>
</body>
</html>