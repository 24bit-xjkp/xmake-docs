<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="/assets/npm/github-markdown/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/zh-cn/manual/package_instance">https://xmake.io/#/zh-cn/manual/package_instance</a>
<div id="wwads-panel" class="wwads-cn wwads-vertical wwads-sticky" data-id="239" style="max-width:180px;bottom:20px;right:20px;width:200px;height:260px;background:#fff;position:fixed"></div>
</br>
    <script type="text/javascript" charset="UTF-8" src="https://cdn.wwads.cn/js/makemoney.js" async></script>
<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <p>此页面描述了 <a href="zh-cn/manual/package_dependencies.md">包依赖管理</a> 的 <code>on_load()</code>、<code>on_install()</code> 或 <code>on_test()</code> 等函数的 <code>package</code> 接口</p>
<h4 id="packagename">package:name</h4>
<ul>
<li>获取包的名字</li>
</ul>
<h4 id="packageget">package:get</h4>
<ul>
<li>获取包在描述域的配置值</li>
</ul>
<p>任何在描述域的 <code>set_xxx</code> 和 <code>add_xxx</code> 配置值都可以通过这个接口获取到。</p>
<pre><code class="lang-lua">-- get the dependencies
package:get("deps")
-- get the links
package:get("links")
-- get the defined macros
package:get("defines")
</code></pre>
<h4 id="packageset">package:set</h4>
<ul>
<li>设置包的配置值，（如果你想添加值可以用 <a href="#packageadd">package:add</a>）。</li>
</ul>
<pre><code class="lang-lua">-- set the dependencies
package:set("deps", "python")
-- set the links
package:set("links", "sdl2")
-- set the defined macros
package:set("defines", "SDL_MAIN_HANDLED")
</code></pre>
<h4 id="packageadd">package:add</h4>
<ul>
<li>按名称添加到包的值</li>
</ul>
<pre><code class="lang-lua">-- add dependencies
package:add("deps", "python")
-- add links
package:add("links", "sdl2")
-- add defined macros
package:add("defines", "SDL_MAIN_HANDLED")
</code></pre>
<h4 id="packagelicense">package:license</h4>
<ul>
<li>获取包的许可证（同<code>package:get("license")</code>）</li>
</ul>
<h4 id="packagedescription">package:description</h4>
<ul>
<li>获取包的描述（同<code>package:get("description")</code>）</li>
</ul>
<h4 id="packageplat">package:plat</h4>
<ul>
<li>获取包的平台。 可以是以下任何一种：<ul>
<li>windows</li>
<li>linux</li>
<li>macosx</li>
<li>android</li>
<li>iphoneos</li>
<li>watchos</li>
<li>mingw</li>
<li>cygwin</li>
<li>bsd</li>
</ul>
</li>
</ul>
<p>如果包是二进制的，则会返回 <a href="zh-cn/manual/builtin_modules.md#oshost"><code>os.host</code></a> 的值</p>
<h4 id="packagearch">package:arch</h4>
<ul>
<li>获取包的架构（例如 x86、x64、x86_64）</li>
</ul>
<p>如果包是二进制的，则返回 <a href="zh-cn/manual/builtin_modules.md#osarch"><code>os.arch</code></a></p>
<h4 id="packagetargetos">package:targetos</h4>
<ul>
<li>获取包的目标操作系统。 可以具有与 <a href="#packageplat">package:plat</a> 相同的值</li>
</ul>
<h4 id="packagetargetarch">package:targetarch</h4>
<ul>
<li>获取包的目标架构。 可以具有与 <a href="#packagearch">package:arch</a> 相同的值</li>
</ul>
<h4 id="packageis_plat">package:is_plat</h4>
<ul>
<li>当前平台是否是给定平台之一</li>
</ul>
<pre><code class="lang-lua">-- Is the current platform android?
package:is_plat("android")
-- Is the current platform windows, linux or macosx?
package:is_plat("windows", "linux", "macosx")
</code></pre>
<h4 id="packageis_arch">package:is_arch</h4>
<ul>
<li>当前架构是否是给定架构之一</li>
</ul>
<pre><code class="lang-lua">-- Is the current architecture x86
package:is_arch("x86")
-- Is the current architecture x64 or x86_64
package:is_arch("x64", "x86_64")
</code></pre>
<h4 id="packageis_targetos">package:is_targetos</h4>
<ul>
<li>当前目标操作系统是否是给定操作系统之一</li>
</ul>
<pre><code class="lang-lua">-- Is the currently targeted OS windows?
package:is_targetos("windows")
-- Is the currently targeted OS android or iphoneos?
package:is_targetos("android", "iphoneos")
</code></pre>
<h4 id="packageis_targetarch">package:is_targetarch</h4>
<ul>
<li>当前目标架构是否是给定架构之一</li>
</ul>
<pre><code class="lang-lua">-- Is the currently targeted architecture x86
package:is_targetarch("x86")
-- Is the currently targeted architecture x64 or x86_64
package:is_targetarch("x64", "x86_64")
</code></pre>
<h4 id="packagealias">package:alias</h4>
<ul>
<li>获取包的别名</li>
</ul>
<p>如果用户像这样设置别名：</p>
<pre><code class="lang-lua">add_requires("libsdl", {alias = "sdl"})
</code></pre>
<p>那么这个别名可以通过这个接口获取到：</p>
<pre><code class="lang-lua">-- returns "sdl"
package:alias()
</code></pre>
<h4 id="packageurls">package:urls</h4>
<ul>
<li>获取包的 urls 列表</li>
</ul>
<p>如果我们设置了如下 URLs</p>
<pre><code class="lang-lua">add_urls("https://example.com/library-$(version).zip")
-- or so
set_urls("https://example.com/library-$(version).zip")
</code></pre>
<p>那么我们可以通过下面的接口来获取</p>
<pre><code class="lang-lua">-- returns the table {"https://example.com/library-$(version).zip"}
package:urls()
</code></pre>
<h4 id="packagedep">package:dep</h4>
<ul>
<li>通过名称获取包的依赖项。 该名称需要是包的依赖项。</li>
</ul>
<pre><code class="lang-lua">local python = package:dep("python")
-- returns "python"
python:name()
</code></pre>
<h4 id="packagedeps">package:deps</h4>
<ul>
<li>获取包的所有依赖项</li>
</ul>
<pre><code class="lang-lua">-- prints the names of all dependencies
for _,dep in pairs(package:deps()) do
    print(dep:name())
end
</code></pre>
<h4 id="packagesourcehash">package:sourcehash</h4>
<ul>
<li>获取 URL 别名的 sha256 校验和</li>
</ul>
<p>如果校验和是这样提供的：</p>
<pre><code class="lang-lua">add_urls("https://example.com/library-$(version).zip", {alias = "example"})
add_versions("example:2.4.1", "29f9983cc7196e882c4bc3d23d7492f9c47574c7cf658afafe7d00c185429941")
</code></pre>
<p>您可以像这样获取它：</p>
<pre><code class="lang-lua">-- returns "29f9983cc7196e882c4bc3d23d7492f9c47574c7cf658afafe7d00c185429941"
package:sourcehash("example")
-- or so
package:sourcehash(package:url_alias(package:urls()[1]))
</code></pre>
<h4 id="packagekind">package:kind</h4>
<ul>
<li>获取包的类型。 可以是以下任何一种：<ul>
<li>binary</li>
<li>toolchain (is also binary)</li>
<li>library (default)</li>
<li>template <a href="https://github.com/xmake-io/xmake/issues/2138">#2138</a></li>
<li>headeronly</li>
</ul>
</li>
</ul>
<h4 id="packageis_binary">package:is_binary</h4>
<ul>
<li>包是否为二进制类型</li>
</ul>
<h4 id="packageis_toolchain">package:is_toolchain</h4>
<ul>
<li>报是否为工具链类型</li>
</ul>
<h4 id="packageis_library">package:is_library</h4>
<ul>
<li>包是否为库类型</li>
</ul>
<h4 id="packageis_toplevel">package:is_toplevel</h4>
<p>-- 包是否在用户 xmake.lua 里面通过 add_requires 直接引用</p>
<h4 id="packageis_thirdparty">package:is_thirdparty</h4>
<ul>
<li>包是否由第三方包管理器提供（例如 brew、conan、vcpkg）</li>
</ul>
<h4 id="packageis_debug">package:is_debug</h4>
<ul>
<li>包是否以调试模式构建（同<code>package:config("debug")</code>）</li>
</ul>
<h4 id="packageis_supported">package:is_supported</h4>
<ul>
<li>当前平台和架构是否支持该包</li>
</ul>
<h4 id="packagedebug">package:debug</h4>
<ul>
<li>包是否使用调试模式构建（不推荐使用：使用 <a href="#packageis_debug"><code>package:is_debug</code></a> 代替）</li>
</ul>
<h4 id="packageis_cross">package:is_cross</h4>
<ul>
<li>包是否正在交叉编译</li>
</ul>
<h4 id="packagecachedir">package:cachedir</h4>
<ul>
<li>获取包的缓存目录</li>
</ul>
<h4 id="packageinstalldir">package:installdir</h4>
<ul>
<li>获取包的安装目录。 也可用于获取子目录。 如果给定的目录树不存在，它将被创建。</li>
</ul>
<pre><code class="lang-lua">-- returns the installation directory
package:installdir()
-- returns the subdirectory include inside the installation directory
package:installdir("include")
-- returns the subdirectory include/files
package:installdir("include", "files")
</code></pre>
<h4 id="packagescriptdir">package:scriptdir</h4>
<ul>
<li>获取包的xmake.lua所在目录</li>
</ul>
<h4 id="packageenvs">package:envs</h4>
<ul>
<li>获取包导出的环境变量</li>
</ul>
<h4 id="packagegetenv">package:getenv</h4>
<ul>
<li>获取给定的环境变量</li>
</ul>
<pre><code class="lang-lua">-- returns a table
package:getenv("PATH")
</code></pre>
<h4 id="packagesetenv">package:setenv</h4>
<ul>
<li>设置给定的环境变量。 覆盖变量</li>
</ul>
<pre><code class="lang-lua">-- sets PATH to {"bin", "lib"}
package:setenv("PATH", "bin", "lib")
</code></pre>
<h4 id="packageaddenv">package:addenv</h4>
<ul>
<li>将给定的值添加到环境变量</li>
</ul>
<pre><code class="lang-lua">-- adds "bin" and "lib" to PATH
package:addenv("PATH", "bin", "lib")
</code></pre>
<h4 id="packageversions">package:versions</h4>
<ul>
<li>获取包的所有版本列表。</li>
</ul>
<h4 id="packageversion">package:version</h4>
<ul>
<li>获取包的版本</li>
</ul>
<p>它会返回一个语义版本对象，便于做版本之间的判断。</p>
<pre><code class="lang-lua">local version = package:version()
-- get the major version
version:major()
-- get the minor version
version:minor()
-- get the patch version
version:patch()
</code></pre>
<h4 id="packageversion_str">package:version_str</h4>
<ul>
<li>以字符串形式获取包的版本</li>
</ul>
<h4 id="packageconfig">package:config</h4>
<ul>
<li>获取包的给定配置值</li>
</ul>
<pre><code class="lang-lua">-- if configurations are set like so
add_require("example", {configs = {enable_x = true, value_y = 6}})
-- these values can be retrieved like so
-- returns true
package:config("enable_x")
-- returns 6
package:config("value_y")
</code></pre>
<h4 id="packageconfig_set">package:config_set</h4>
<ul>
<li>设置包的给定配置值</li>
</ul>
<pre><code class="lang-lua">package:config_set("enable_x", true)
package:config_set("value_y", 6)
</code></pre>
<h4 id="packageconfigs">package:configs</h4>
<ul>
<li>获取包的所有配置</li>
</ul>
<pre><code class="lang-lua">-- returns a table with the configuration names as keys and their values as values
local configs = package:configs()
local enable_x = configs["enable_x"]
local value_y = configs["value_y"]
</code></pre>
<h4 id="packagebuildhash">package:buildhash</h4>
<ul>
<li>获取包的构建哈希</li>
</ul>
<p>它确保每个包，不同的配置安装到唯一的路径下，相互之间不冲突。</p>
<h4 id="packagepatches">package:patches</h4>
<ul>
<li>获取当前版本的所有补丁</li>
</ul>
<pre><code class="lang-lua">-- returns a table with all patches
local patches = package:patches()
-- each element contains the keys "url" and "sha256"
local url = patches[1]["url"]
local sha256 = patches[1]["sha256"]
</code></pre>
<h4 id="packagehas_cfuncs">package:has_cfuncs</h4>
<ul>
<li>检测包是否具有给定的 C 函数</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:has_cfuncs("foo"))
  -- you can also add configs
  assert(package:has_cfuncs("bar", {includes = "foo_bar.h"}))
  assert(package:has_cfuncs("blob", {includes = "blob.h", configs = {defines = "USE_BLOB"}}))
  -- you can even set the language
  assert(package:has_cfuncs("bla", {configs = {languages = "c99"}}))
end)
</code></pre>
<h4 id="packagehas_cxxfuncs">package:has_cxxfuncs</h4>
<ul>
<li>检测包是否具有给定的 C++ 函数</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:has_cxxfuncs("foo"))
  -- you can also add configs
  assert(package:has_cxxfuncs("bar", {includes = "foo_bar.hpp"}))
  assert(package:has_cxxfuncs("blob", {includes = "blob.hpp", configs = {defines = "USE_BLOB"}}))
  -- you can even set the language
  assert(package:has_cxxfuncs("bla", {configs = {languages = "cxx17"}}))
end)
</code></pre>
<h4 id="packagehas_ctypes">package:has_ctypes</h4>
<ul>
<li>检测包是否具有给定的 C 类型</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:has_ctypes("foo"))
  -- you can also add configs
  assert(package:has_ctypes("bar", {includes = "foo_bar.h"}))
  assert(package:has_ctypes("blob", {includes = "blob.h", configs = {defines = "USE_BLOB"}}))
  -- you can even set the language
  assert(package:has_ctypes("bla", {configs = {languages = "c99"}}))
end)
</code></pre>
<h4 id="packagehas_cxxtypes">package:has_cxxtypes</h4>
<ul>
<li>检测包是否具有给定的 C++ 类型</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:has_cxxtypes("foo"))
  -- you can also add configs
  assert(package:has_cxxtypes("bar", {includes = "foo_bar.hpp"}))
  assert(package:has_cxxtypes("blob", {includes = "blob.hpp", configs = {defines = "USE_BLOB"}}))
  -- you can even set the language
  assert(package:has_cxxtypes("bla", {configs = {languages = "cxx17"}}))
end)
</code></pre>
<h4 id="packagehas_cincludes">package:has_cincludes</h4>
<ul>
<li>检测包是否具有给定的 C 头文件</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:has_cincludes("foo.h"))
end)
</code></pre>
<h4 id="packagehas_cxxincludes">package:has_cxxincludes</h4>
<ul>
<li>检测包是否具有给定的 C++ 头文件</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:has_cincludes("foo.hpp"))
end)
</code></pre>
<h4 id="packagecheck_csnippets">package:check_csnippets</h4>
<ul>
<li>检测是否可以编译和链接给定的 C 代码片段</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:check_csnippets({test = [[
    #define USE_BLOB
    #include <blob.h>
    void test(int argc, char** argv) {
      foo bar;
      printf("%s", bar.blob);
    }
  ]]}, {configs = {languages = "c99"}, includes = "foo.h"}))
end)
</code></pre>
<h4 id="packagecheck_cxxsnippets">package:check_cxxsnippets</h4>
<ul>
<li>检测是否可以编译和链接给定的 C++ 代码片段</li>
</ul>
<p>这应该在 <code>on_test</code> 中使用，如下所示：</p>
<pre><code class="lang-lua">on_test(function (package)
  assert(package:check_cxxsnippets({test = [[
    #define USE_BLOB
    #include <blob.hpp>
    void test(int argc, char** argv) {
      foo bar();
      std::cout << bar.blob;
    }
  ]]}, {configs = {languages = "cxx11"}, includes = "foo.hpp"}))
end)
</code></pre>
<h4 id="packagecheck_fcsnippets">package:check_fcsnippets</h4>
<ul>
<li>检测是否可以编译和链接给定的 Fortran 代码片段</li>
</ul>
<p>用法如上</p>
</article>
</body>
</html>