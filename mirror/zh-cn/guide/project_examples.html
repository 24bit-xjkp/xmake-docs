<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="//cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/zh-cn/guide/project_examples">https://xmake.io/#/zh-cn/guide/project_examples</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <p>下面我们简单介绍一些常用的工程例子，更多更全的examples工程可以到<a href="https://github.com/xmake-io/xmake/tree/master/tests/projects">project examples</a>中查看。</p>
<p>我们也可以通过：<code>xmake create</code>命令创建各种常用的空工程来快速开始，具体对于这个命令的介绍以及支持的工程模板，可以敲下面的命令查看：</p>
<pre><code class="lang-bash">xmake create --help
</code></pre>
<h2 id="-">可执行程序</h2>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*c&quot;)
</code></pre>
<p>完整例子请执行下面的命令来创建：</p>
<pre><code class="lang-bash">xmake create -l c -t console test
</code></pre>
<h2 id="-">静态库程序</h2>
<pre><code class="lang-lua">target(&quot;library&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;src/library/*.c&quot;)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*c&quot;)
    add_deps(&quot;library&quot;)
</code></pre>
<p>通过<code>add_deps</code>将一个静态库自动链接到test可执行程序。</p>
<p>完整例子请执行下面的命令来创建：</p>
<pre><code class="lang-bash">xmake create -l c -t static test
</code></pre>
<h2 id="-">动态库程序</h2>
<pre><code class="lang-lua">target(&quot;library&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/library/*.c&quot;)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*c&quot;)
    add_deps(&quot;library&quot;)
</code></pre>
<p>通过<code>add_deps</code>将一个动态库自动链接到test可执行程序。</p>
<p>完整例子请执行下面的命令来创建：</p>
<pre><code class="lang-bash">xmake create -l c -t shared test
</code></pre>
<h2 id="qt-">Qt程序</h2>
<p>创建一个空工程：</p>
<p>v2.2.9以上版本：</p>
<pre><code class="lang-console">$ xmake create -t qt.console test
$ xmake create -t qt.static test
$ xmake create -t qt.shared test
$ xmake create -t qt.quickapp test
$ xmake create -t qt.widgetapp test
</code></pre>
<p>更多工程模板见：<code>xmake create --help</code></p>
<p>v2.2.8以前老版本：</p>
<pre><code class="lang-console">$ xmake create -l c++ -t console_qt test
$ xmake create -l c++ -t static_qt test
$ xmake create -l c++ -t shared_qt test
$ xmake create -l c++ -t quickapp_qt test
</code></pre>
<p>默认会自动探测Qt环境，当然也可以指定Qt SDK环境目录：</p>
<pre><code class="lang-console">$ xmake f --qt=~/Qt/Qt5.9.1
</code></pre>
<p>如果想要使用windows下mingw的Qt环境，可以切到mingw的平台配置，并且指定下mingw编译环境的sdk路径即可，例如：</p>
<pre><code class="lang-console">$ xmake f -p mingw --sdk=C:\Qt\Qt5.10.1\Tools\mingw530_32 
</code></pre>
<p>上述指定的mingw sdk用的是Qt下Tools目录自带的环境，当然如果有其他第三方mingw编译环境，也可以手动指定, 具体可以参考：<a href="#mingw">mingw编译配置</a>。</p>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/160">#160</a></p>
<h3 id="-">静态库程序</h3>
<pre><code class="lang-lua">target(&quot;qt_static_library&quot;)
    add_rules(&quot;qt.static&quot;)
    add_files(&quot;src/*.cpp&quot;)
    add_frameworks(&quot;QtNetwork&quot;, &quot;QtGui&quot;)
</code></pre>
<h3 id="-">动态库程序</h3>
<pre><code class="lang-lua">target(&quot;qt_shared_library&quot;)
    add_rules(&quot;qt.shared&quot;)
    add_files(&quot;src/*.cpp&quot;)
    add_frameworks(&quot;QtNetwork&quot;, &quot;QtGui&quot;)
</code></pre>
<h3 id="-">控制台程序</h3>
<pre><code class="lang-lua">target(&quot;qt_console&quot;)
    add_rules(&quot;qt.console&quot;)
    add_files(&quot;src/*.cpp&quot;)
</code></pre>
<h3 id="quick-">Quick应用程序</h3>
<p>v2.2.9以上版本：</p>
<pre><code class="lang-lua">target(&quot;qt_quickapp&quot;)
    add_rules(&quot;qt.quickapp&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/qml.qrc&quot;)
</code></pre>
<p>!&gt; 新版本提供了<code>qt.quickapp</code>规则，内置了QtQuick的内建规则，使用更加简单，下面老版本的<code>qt.application</code>还是支持的，向下兼容：</p>
<pre><code class="lang-lua">target(&quot;qt_quickapp&quot;)
    add_rules(&quot;qt.application&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/qml.qrc&quot;)
    add_frameworks(&quot;QtQuick&quot;)
</code></pre>
<p>!&gt; 如果使用的自己编译的static版本QT SDK，那么需要切换到<code>add_rules(&quot;qt.quickapp_static&quot;)</code>静态规则才行，因为链接的库是不同的，需要做静态链接。</p>
<p>接下来，我们尝试编译下，通常，如果是使用Qt的安装包默认安装，也没有修改安装路径，那么大部分情况下都是可以自动检测到QT SDK的根路径，例如：</p>
<pre><code class="lang-bash">$ xmake
checking for the architecture ... x86_64
checking for the Xcode directory ... /Applications/Xcode.app
checking for the SDK version of Xcode ... 10.15
checking for the Qt SDK directory ... /Users/ruki/Qt5.13.2/5.13.2/clang_64
checking for the Qt SDK version ... 5.13.2
[  0%]: ccache compiling.release src/main.cpp
[ 49%]: compiling.qt.qrc src/qml.qrc
[100%]: linking.release test
build ok!
</code></pre>
<p>然后我们继续运行下它：</p>
<pre><code class="lang-bash">$ xmake run
</code></pre>
<p>效果如下：</p>
<p><img src="/assets/img/guide/qt_quickapp.png" alt=""></p>
<h3 id="widgets-">Widgets应用程序</h3>
<p>v2.2.9以上版本：</p>
<pre><code class="lang-lua">target(&quot;qt_widgetapp&quot;)
    add_rules(&quot;qt.widgetapp&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/mainwindow.ui&quot;)
    add_files(&quot;src/mainwindow.h&quot;)  -- 添加带有 Q_OBJECT 的meta头文件
</code></pre>
<p>!&gt; 新版本提供了<code>qt.widgetapp</code>规则，内置了QtWidgets的内建规则，使用更加简单，下面老版本的<code>qt.application</code>还是支持的，向下兼容：</p>
<pre><code class="lang-lua">target(&quot;qt_widgetapp&quot;)
    add_rules(&quot;qt.application&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/mainwindow.ui&quot;)
    add_files(&quot;src/mainwindow.h&quot;)  -- 添加带有 Q_OBJECT 的meta头文件
    add_frameworks(&quot;QtWidgets&quot;)
</code></pre>
<p>!&gt; 如果使用的自己编译的static版本QT SDK，那么需要切换到<code>add_rules(&quot;qt.widgetapp_static&quot;)</code>静态规则才行，因为链接的库是不同的，需要做静态链接。</p>
<p>运行效果如下：</p>
<p><img src="/assets/img/guide/qt_widgetapp.png" alt=""></p>
<h3 id="android-">Android应用程序</h3>
<p>2.2.6之后版本，可以直接切到android平台编译Quick/Widgets应用程序，生成apk包，并且可通过<code>xmake install</code>命令安装到设备。</p>
<pre><code class="lang-console">$ xmake create -t quickapp_qt -l c++ appdemo
$ cd appdemo
$ xmake f -p android --ndk=~/Downloads/android-ndk-r19c/ --android_sdk=~/Library/Android/sdk/ -c 
$ xmake
[  0%]: compiling.qt.qrc src/qml.qrc
[ 50%]: ccache compiling.release src/main.cpp
[100%]: linking.release libappdemo.so
[100%]: generating.qt.app appdemo.apk
</code></pre>
<p>然后安装到设备：</p>
<pre><code class="lang-console">$ xmake install
installing appdemo ...
installing build/android/release/appdemo.apk ..
Success
install ok!👌
</code></pre>
<h2 id="cuda-">Cuda程序</h2>
<p>创建一个空工程：</p>
<pre><code class="lang-console">$ xmake create -P test -l cuda
$ cd test
$ xmake
</code></pre>
<pre><code class="lang-lua">-- define target
target(&quot;cuda_console&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.cu&quot;)
    -- generate SASS code for SM architecture of current host
    add_cugencodes(&quot;native&quot;)
    -- generate PTX code for the virtual architecture to guarantee compatibility
    add_cugencodes(&quot;compute_30&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>从v2.2.7版本开始，默认构建会启用device-link。（参见 <a href="https://devblogs.nvidia.com/separate-compilation-linking-cuda-device-code/">Separate Compilation and Linking of CUDA C++ Device Code</a>）<br>如果要显示禁用device-link，可以通过<code>add_values(&quot;cuda.devlink&quot;, false)</code> 来设置。<br>&lt;/p&gt;

</p>
<p>默认会自动探测cuda环境，当然也可以指定Cuda SDK环境目录：</p>
<pre><code class="lang-console">$ xmake f --cuda=/usr/local/cuda-9.1/ 
$ xmake
</code></pre>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/158">#158</a></p>
<h2 id="wdk-">WDK驱动程序</h2>
<p>默认会自动探测wdk所在环境，当然也可以指定wdk sdk环境目录：</p>
<pre><code class="lang-console">$ xmake f --wdk=&quot;G:\Program Files\Windows Kits\10&quot; -c 
$ xmake
</code></pre>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/159">#159</a></p>
<p>相关完整工程example见：<a href="https://github.com/xmake-io/xmake/tree/master/tests/projects/wdk">WDK examples</a></p>
<h3 id="umdf-">umdf驱动程序</h3>
<pre><code class="lang-lua">target(&quot;echo&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.umdf&quot;)
    add_files(&quot;driver/*.c&quot;) 
    add_files(&quot;driver/*.inx&quot;)
    add_includedirs(&quot;exe&quot;)

target(&quot;app&quot;)
    add_rules(&quot;wdk.binary&quot;, &quot;wdk.env.umdf&quot;)
    add_files(&quot;exe/*.cpp&quot;) 
</code></pre>
<h3 id="kmdf-">kmdf驱动程序</h3>
<pre><code class="lang-lua">target(&quot;nonpnp&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.kmdf&quot;)
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TraceEvents(LEVEL,FLAGS,MSG,...)&quot;, &quot;-func:Hexdump((LEVEL,FLAGS,MSG,...))&quot;)
    add_files(&quot;driver/*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
    add_files(&quot;driver/*.rc&quot;)

target(&quot;app&quot;)
    add_rules(&quot;wdk.binary&quot;, &quot;wdk.env.kmdf&quot;)
    add_files(&quot;exe/*.c&quot;) 
    add_files(&quot;exe/*.inf&quot;)
</code></pre>
<h3 id="wdm-">wdm驱动程序</h3>
<pre><code class="lang-lua">target(&quot;kcs&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.wdm&quot;)
    add_values(&quot;wdk.man.flags&quot;, &quot;-prefix Kcs&quot;)
    add_values(&quot;wdk.man.resource&quot;, &quot;kcsCounters.rc&quot;)
    add_values(&quot;wdk.man.header&quot;, &quot;kcsCounters.h&quot;)
    add_values(&quot;wdk.man.counter_header&quot;, &quot;kcsCounters_counters.h&quot;)
    add_files(&quot;*.c&quot;, &quot;*.rc&quot;, &quot;*.man&quot;) 
</code></pre>
<pre><code class="lang-lua">target(&quot;msdsm&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.wdm&quot;)
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TracePrint((LEVEL,FLAGS,MSG,...))&quot;)
    add_files(&quot;*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
    add_files(&quot;*.rc&quot;, &quot;*.inf&quot;)
    add_files(&quot;*.mof|msdsm.mof&quot;)
    add_files(&quot;msdsm.mof&quot;, {values = {wdk_mof_header = &quot;msdsmwmi.h&quot;}}) 
</code></pre>
<h3 id="-">生成驱动包</h3>
<p>可以通过以下命令生成.cab驱动包：</p>
<pre><code class="lang-console">$ xmake [p|package]
$ xmake [p|package] -o outputdir
</code></pre>
<p>输出的目录结构如下：</p>
<pre><code>  - drivers
    - sampledsm
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
</code></pre><h3 id="-">驱动签名</h3>
<p>默认编译禁用签名，可以通过<code>set_values(&quot;wdk.sign.mode&quot;, ...)</code>设置签名模式来启用签名。</p>
<h4 id="-">测试签名</h4>
<p>测试签名一般本机调试时候用，可以使用xmake自带的test证书来进行签名，例如：</p>
<pre><code class="lang-lua">target(&quot;msdsm&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.wdm&quot;)
    set_values(&quot;wdk.sign.mode&quot;, &quot;test&quot;)
</code></pre>
<p>不过这种情况下，需要用户手动在管理员模式下，执行一遍：<code>$xmake l utils.wdk.testcert install</code>，来生成和注册test证书到本机环境。<br>这个只需要执行一次就行了，后续就可以正常编译和签名了。</p>
<p>当然也可以使用本机已有的有效证书去签名。</p>
<p>从sha1来选择合适的证书进行签名：</p>
<pre><code class="lang-lua">target(&quot;msdsm&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.wdm&quot;)
    set_values(&quot;wdk.sign.mode&quot;, &quot;test&quot;)
    set_values(&quot;wdk.sign.thumbprint&quot;, &quot;032122545DCAA6167B1ADBE5F7FDF07AE2234AAA&quot;)
</code></pre>
<p>从store/company来选择合适的证书进行签名：</p>
<pre><code class="lang-lua">target(&quot;msdsm&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.wdm&quot;)
    set_values(&quot;wdk.sign.mode&quot;, &quot;test&quot;)
    set_values(&quot;wdk.sign.store&quot;, &quot;PrivateCertStore&quot;)
    set_values(&quot;wdk.sign.company&quot;, &quot;tboox.org(test)&quot;)
</code></pre>
<h4 id="-">正式签名</h4>
<p>通过指定对应的正式签名证书文件进行签名：</p>
<pre><code class="lang-lua">target(&quot;msdsm&quot;)
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.wdm&quot;)
    set_values(&quot;wdk.sign.mode&quot;, &quot;release&quot;)
    set_values(&quot;wdk.sign.company&quot;, &quot;xxxx&quot;)
    set_values(&quot;wdk.sign.certfile&quot;, path.join(os.projectdir(), &quot;xxxx.cer&quot;))
</code></pre>
<h3 id="-">生成低版本驱动</h3>
<p>如果想在wdk10环境编译生成win7, win8等低版本系统支持的驱动，可以通过设置<code>wdk.env.winver</code>来切换系统版本：</p>
<pre><code class="lang-lua">set_values(&quot;wdk.env.winver&quot;, &quot;win10&quot;)
set_values(&quot;wdk.env.winver&quot;, &quot;win10_rs3&quot;)
set_values(&quot;wdk.env.winver&quot;, &quot;win81&quot;)
set_values(&quot;wdk.env.winver&quot;, &quot;win8&quot;)
set_values(&quot;wdk.env.winver&quot;, &quot;win7&quot;)
set_values(&quot;wdk.env.winver&quot;, &quot;win7_sp1&quot;)
set_values(&quot;wdk.env.winver&quot;, &quot;win7_sp2&quot;)
set_values(&quot;wdk.env.winver&quot;, &quot;win7_sp3&quot;)
</code></pre>
<p>我们也可以手动指定编译的目标程序支持的windows版本：</p>
<pre><code class="lang-console">$ xmake f --wdk_winver=[win10_rs3|win8|win7|win7_sp1]
$ xmake
</code></pre>
<h2 id="winsdk-">WinSDK程序</h2>
<pre><code class="lang-lua">target(&quot;usbview&quot;)
    add_rules(&quot;win.sdk.application&quot;)

    add_files(&quot;*.c&quot;, &quot;*.rc&quot;)
    add_files(&quot;xmlhelper.cpp&quot;, {rule = &quot;win.sdk.dotnet&quot;})
</code></pre>
<p>更多详情可以参考：<a href="https://github.com/xmake-io/xmake/issues/173">#173</a></p>
<h2 id="mfc-">MFC程序</h2>
<h3 id="mfc-">MFC静态库</h3>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;win.sdk.mfc.static&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<h3 id="mfc-">MFC动态库</h3>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;win.sdk.mfc.shared&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<h3 id="mfc-">MFC应用程序（静态链接）</h3>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;win.sdk.mfc.static_app&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<h3 id="mfc-">MFC应用程序（动态链接）</h3>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;win.sdk.mfc.shared_app&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<h2 id="ios-macos-">iOS/MacOS程序</h2>
<h3 id="app-">App应用程序</h3>
<p>用于生成<em>.app/</em>.ipa应用程序，同时支持iOS/MacOS。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;xcode.application&quot;)
    add_files(&quot;src/*.m&quot;, &quot;src/**.storyboard&quot;, &quot;src/*.xcassets&quot;)
    add_files(&quot;src/Info.plist&quot;)
</code></pre>
<h4 id="-">创建工程</h4>
<p>我们也可以通过模板工程快速创建：</p>
<pre><code class="lang-console">$ xmake create -t xcode.macapp -l objc test
$ xmake create -t xcode.iosapp -l objc test
</code></pre>
<h4 id="-">编译</h4>
<pre><code class="lang-console">$ xmake f -p [iphoneos|macosx]
$ xmake
[ 18%]: compiling.xcode.release src/Assets.xcassets
[ 27%]: processing.xcode.release src/Info.plist
[ 72%]: compiling.xcode.release src/Base.lproj/Main.storyboard
[ 81%]: compiling.xcode.release src/Base.lproj/LaunchScreen.storyboard
[ 45%]: ccache compiling.release src/ViewController.m
[ 63%]: ccache compiling.release src/AppDelegate.m
[ 54%]: ccache compiling.release src/SceneDelegate.m
[ 36%]: ccache compiling.release src/main.m
[ 90%]: linking.release test
[100%]: generating.xcode.release test.app
[100%]: build ok!
</code></pre>
<h4 id="-">配置签名</h4>
<p>对于iOS程序，默认会检测系统先用可用签名来签名app，当然我们也可以手动指定其他签名证书：</p>
<pre><code class="lang-console">$ xmake f -p iphoneos --xcode_codesign_identity=&#39;Apple Development: xxx@gmail.com (T3NA4MRVPU)&#39; --xcode_mobile_provision=&#39;iOS Team Provisioning Profile: org.tboox.test --xcode_bundle_identifier=org.tboox.test&#39;
$ xmake
</code></pre>
<p>如果每次这么配置签名觉得繁琐的话，可以设置到<code>xmake global</code>全局配置中，也可以在xmake.lua中对每个target单独设置：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;xcode.application&quot;)
    add_files(&quot;src/*.m&quot;, &quot;src/**.storyboard&quot;, &quot;src/*.xcassets&quot;)
    add_files(&quot;src/Info.plist&quot;)
    add_values(&quot;xcode.bundle_identifier&quot;, &quot;org.tboox.test&quot;)
    add_values(&quot;xcode.codesign_identity&quot;, &quot;Apple Development: xxx@gmail.com (T3NA4MRVPU)&quot;)
    add_values(&quot;xcode.mobile_provision&quot;, &quot;iOS Team Provisioning Profile: org.tboox.test&quot;)
</code></pre>
<p>那如何知道我们需要的签名配置呢？一种就是在xcode里面查看，另外xmake也提供了一些辅助工具可以dump出当前可用的所有签名配置：</p>
<pre><code class="lang-console">$ xmake l private.tools.codesign.dump
==================================== codesign identities ====================================
{ 
  &quot;Apple Development: waruqi@gmail.com (T3NA4MRVPU)&quot; = &quot;AF73C231A0C35335B72761BD3759694739D34EB1&quot; 
}

===================================== mobile provisions =====================================
{ 
  &quot;iOS Team Provisioning Profile: org.tboox.test&quot; = &quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;AppIDName&lt;/key&gt;
    &lt;string&gt;XC org tboox test5&lt;/string&gt;
    &lt;key&gt;ApplicationIdentifierPrefix&lt;/key&gt;
    &lt;array&gt;
    &lt;string&gt;43AAQM58X3&lt;/string&gt;
...
</code></pre>
<p>我们也提供了其他辅助工具来对已有的ipa/app程序进行重签名，例如：</p>
<pre><code class="lang-console">$ xmake l utils.ipa.resign test.ipa|test.app [codesign_identity] [mobile_provision] [bundle_identifier]
</code></pre>
<p>其中，后面的签名参数都是可选的，如果没设置，那么默认会探测使用一个有效的签名：</p>
<pre><code class="lang-console">$ xmake l utils.ipa.resign test.ipa
$ xmake l utils.ipa.resign test.app &quot;Apple Development: waruqi@gmail.com (T3NA4MRVPU)&quot;
$ xmake l utils.ipa.resign test.ipa &quot;Apple Development: waruqi@gmail.com (T3NA4MRVPU)&quot; iOS Team Provisioning Profile: org.tboox.test&quot; org.tboox.test
</code></pre>
<h4 id="-">运行应用程序</h4>
<p>目前仅支持运行macos程序：</p>
<pre><code class="lang-console">$ xmake run
</code></pre>
<p>效果如下：</p>
<p><img src="/assets/img/guide/macapp.png" alt=""></p>
<h4 id="-">生成程序包</h4>
<p>如果是iOS程序会生成ipa安装包，如果是macos会生成dmg包（dmg包生成暂时还在开发中）。</p>
<pre><code class="lang-console">$ xmake package
output: build/iphoneos/release/arm64/test.ipa
package ok!
</code></pre>
<p>我们也提供了辅助工具，来对指定app程序进行打包：</p>
<pre><code class="lang-console">$ xmake l utils.ipa.package test.app output.ipa [iconfile.png]
</code></pre>
<h4 id="-">安装</h4>
<p>如果是iOS程序会安装ipa到设备，如果是macos会安装app到/Applications目录。</p>
<pre><code class="lang-console">$ xmake install
</code></pre>
<p>我们也提供了辅助工具，来对指定ipa/app程序安装到设备：</p>
<pre><code class="lang-console">$ xmake l utils.ipa.install test.app
$ xmake l utils.ipa.install test.ipa
</code></pre>
<h4 id="-">卸载</h4>
<p>!&gt; 目前仅支持macos程序卸载</p>
<pre><code class="lang-console">$ xmake uninstall
</code></pre>
<h3 id="framework-">Framework库程序</h3>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;xcode.framework&quot;)
    add_files(&quot;src/*.m&quot;)
    add_files(&quot;src/Info.plist&quot;)
</code></pre>
<p>我们也可以通过模板工程快速创建：</p>
<pre><code class="lang-console">$ xmake create -t xcode.framework -l objc test
</code></pre>
<h3 id="bundle-">Bundle程序</h3>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_rules(&quot;xcode.bundle&quot;)
    add_files(&quot;src/*.m&quot;)
    add_files(&quot;src/Info.plist&quot;)
</code></pre>
<p>我们也可以通过模板工程快速创建：</p>
<pre><code class="lang-console">$ xmake create -t xcode.bundle -l objc test
</code></pre>
<h2 id="protobuf-">Protobuf程序</h2>
<h3 id="-c-">使用c库</h3>
<pre><code class="lang-lua">add_requires(&quot;protobuf-c&quot;)

target(&quot;console_c&quot;)
    set_kind(&quot;binary&quot;)
    add_packages(&quot;protobuf-c&quot;)

    add_files(&quot;src/*.c&quot;)
    add_files(&quot;src/*.proto&quot;, {rules = &quot;protobuf.c&quot;})
</code></pre>
<h3 id="-c-">使用c++库</h3>
<pre><code class="lang-lua">add_requires(&quot;protobuf-cpp&quot;)

target(&quot;console_c++&quot;)
    set_kind(&quot;binary&quot;)
    set_languages(&quot;c++11&quot;)

    add_packages(&quot;protobuf-cpp&quot;)

    add_files(&quot;src/*.cpp&quot;)
    add_files(&quot;src/*.proto&quot;, {rules = &quot;protobuf.cpp&quot;})
</code></pre>
<h2 id="lexyacc-">Lex&amp;Yacc程序</h2>
<pre><code class="lang-lua">target(&quot;calc&quot;)
    set_kind(&quot;binary&quot;)
    add_rules(&quot;lex&quot;, &quot;yacc&quot;)
    add_files(&quot;src/*.l&quot;, &quot;src/*.y&quot;)
</code></pre>
</article>
</body>
</html>