<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="//cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/guide/configuration">https://xmake.io/#/guide/configuration</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <p>Set compilation configuration before building project with command <code>xmake f|config</code>.</p>
<p>And if you want to known more options, please run: <code>xmake f --help</code>ã€‚</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>    You can use short or long command option, for example: &lt;br&gt;<br>    <code>xmake f</code> or <code>xmake config</code>.&lt;br&gt;<br>    <code>xmake f -p linux</code> or <code>xmake config --plat=linux</code>.<br>&lt;/p&gt;

</p>
<h2 id="target-platforms">Target Platforms</h2>
<h3 id="current-host">Current Host</h3>
<pre><code class="lang-bash">$ xmake
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>    XMake will detect the current host platform automatically and build project.<br>&lt;/p&gt;

</p>
<h3 id="linux">Linux</h3>
<pre><code class="lang-bash">$ xmake f -p linux [-a i386|x86_64]
$ xmake
</code></pre>
<h3 id="android">Android</h3>
<pre><code class="lang-bash">$ xmake f -p android --ndk=~/files/android-ndk-r10e/ [-a armeabi-v7a|arm64-v8a]
$ xmake
</code></pre>
<p>If you want to set the other android toolchains, you can use <a href="#-bin">--bin</a> option.</p>
<p>For example:</p>
<pre><code class="lang-bash">$ xmake f -p android --ndk=~/files/android-ndk-r10e/ -a arm64-v8a --bin=~/files/android-ndk-r10e/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin
</code></pre>
<p>The <a href="#-bin">--bin</a> option is used to set <code>bin</code> directory of toolchains.</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>Please attempt to set <code>--arch=</code> option if it had failed to check compiler.<br>&lt;/p&gt;

</p>
<h3 id="iphoneos">iPhoneOS</h3>
<pre><code class="lang-bash">$ xmake f -p iphoneos [-a armv7|armv7s|arm64|i386|x86_64]
$ xmake
</code></pre>
<h3 id="windows">Windows</h3>
<pre><code class="lang-bash">$ xmake f -p windows [-a x86|x64]
$ xmake
</code></pre>
<h3 id="mingw">Mingw</h3>
<pre><code class="lang-bash">$ xmake f -p mingw --sdk=/usr/local/i386-mingw32-4.3.0/ [-a i386|x86_64]
$ xmake
</code></pre>
<h3 id="apple-watchos">Apple WatchOS</h3>
<pre><code class="lang-bash">$ xmake f -p watchos [-a i386|armv7k]
$ xmake
</code></pre>
<h2 id="cross-compilation">Cross Compilation</h2>
<p>Generally, if we need to compile and generate object files that can be run on other devices in the current pc environment, we need to compile and generate them through the corresponding cross-compilation tool chain, such as compiling linux programs on win/macos, or Compile object files of other embedded devices, etc.</p>
<p>The usual cross-compilation tool chain is based on gcc/clang, and most of them have a structure similar to the following:</p>
<pre><code>/home/toolchains_sdkdir
   - bin
       - arm-linux-armeabi-gcc
       - arm-linux-armeabi-ld
       - ...
   - lib
       - libxxx.a
   - include
       - xxx.h
</code></pre><p>Each toolchain has a corresponding include/lib directory, which is used to place some system libraries and header files, such as libc, stdc++, etc., and a series of tools for compiling the tool chain are placed under the bin directory. E.g:</p>
<pre><code>arm-linux-armeabi-ar
arm-linux-armeabi-as
arm-linux-armeabi-c++
arm-linux-armeabi-cpp
arm-linux-armeabi-g++
arm-linux-armeabi-gcc
arm-linux-armeabi-ld
arm-linux-armeabi-nm
arm-linux-armeabi-strip
</code></pre><p>The <code>arm-linux-armeabi-</code> prefix is cross, which is used to mark the target platform and architecture, and is mainly used to distinguish it from the host&#39;s own gcc/clang.</p>
<p>The gcc/g++ inside is the c/c++ compiler, which can also be used as a linker. When linking, it will internally call ld to link, and automatically add some c++ libraries.<br>Cpp is a preprocessor, as is an assembler, ar is used to generate a static library, and strip is used to crop out some symbol information, making the target program smaller. nm is used to view the list of exported symbols.</p>
<h3 id="automatic-detection-and-compilation">Automatic detection and compilation</h3>
<p>If our cross-compilation tool chain is the above structure, xmake will automatically detect and identify the structure of the SDK, extract the cross and include/lib path location, users usually do not need to do additional parameter settings, just configure the SDK The root directory can be compiled, for example:</p>
<pre><code class="lang-bash">$ xmake f -p cross --sdk=/home/toolchains_sdkdir
$ xmake
</code></pre>
<p>Among them, <code>-p cross</code> is used to specify that the current platform is a cross-compilation platform, and <code>--sdk=</code> is used to specify the root directory of the cross toolchain.</p>
<p>Note: We can also specify the <code>-p linux</code> platform to configure cross compilation, the effect is the same, the only difference is that the name of the linux platform is additionally identified, which is convenient for xmake.lua to determine the platform by<code>is_plat (&quot;linux&quot;)</code> .</p>
<p>At this time, xmake will automatically detect the prefix name cross of gcc and other compilers: <code>arm-linux-armeabi-</code>, and when compiling, it will also automatically add search options for<code>link library</code> and <code>header files</code> :</p>
<pre><code>-I/home/toolchains_sdkdir/include 
-L/home/toolchains_sdkdir/lib
</code></pre><p>These are handled automatically by xmake, there is no need to configure them manually.</p>
<h3 id="manually-configure-and-compile">Manually configure and compile</h3>
<p>If the above automatic detection fails to completely compile for some tool chains, you need to manually set some configuration parameters related to cross compilation to adjust to these special tool chains. I will explain how to configure them one by one.</p>
<h3 id="set-toolchain-bin-directory">Set toolchain bin directory</h3>
<p>For the irregular tool chain directory structure, by simply setting the <a href="https://xmake.io/#/zh-cn/guide/configuration?id=-sdk">--sdk</a> option, it is impossible to completely detect the passing situation Next, you can continue to set the location of the bin directory of the toolchain through this option.</p>
<p>For example: for some special cross toolchains, the compiler bin directory is not in the <code>/home/toolchains_sdkdir/bin</code> position, but is instead in <code>/usr/opt/bin</code></p>
<p>At this time, we can add the parameter setting of the bin directory on the basis of setting the sdk parameter to adjust the bin directory of the tool chain.</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/home/toolchains_sdkdir --bin=/usr/opt/bin
$ xmake
</code></pre>
<h3 id="set-tool-prefix-for-cross-toolchain">Set tool prefix for cross toolchain</h3>
<p>Like aarch64-linux-android-, usually if you configure --sdk or --bin, xmake will automatically detect it, you don&#39;t need to set it manually.</p>
<p>But for some very special tool chains, if there are multiple cross prefix tool bins in a directory at the same time, you need to manually set this configuration to distinguish which bin you need to choose.</p>
<p>For example, there are two different compilers in the bin directory of toolchains:</p>
<pre><code>/opt/bin
  - armv7-linux-gcc 
  - aarch64-linux-gcc
</code></pre><p>We now want to choose the armv7 version, then we can append <code>--cross=</code> to configure the compiler tool prefix name, for example:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/toolsdk --bin=/opt/bin --cross=armv7-linux-
</code></pre>
<h3 id="set-the-c-c-compiler">Set the c/c++ compiler</h3>
<p>If you want to continue to subdivide and select compilers, continue to add relevant compiler options, for example:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --cc=armv7-linux-clang --cxx=armv7-linux-clang++
</code></pre>
<p>Of course, we can also specify the full path of the compiler.</p>
<p><code>--cc</code> is used to specify the name of the c compiler, and <code>--cxx</code> is used to specify the name of the c++ compiler.</p>
<p>Note: If the cc/cxx environment variable exists, the value specified in the current environment variable will be used first.</p>
<p>If the specified compiler name is not a name recognized by xmake (with gcc, clang, etc.), then the compiler tool detection will fail.</p>
<p>At this time we can pass:</p>
<pre><code class="lang-bash">xmake f --cxx=clang++@/home/xxx/c++mips.exe
</code></pre>
<p>Set the c ++ mips.exe compiler as the clang ++-like way to compile.</p>
<p>That is to say, while specifying the compiler as <code>c++mips.exe</code>, tell xmake that it is basically the same as clang ++ usage and parameter options.</p>
<h3 id="set-the-c-c-linker">Set the c/c++ linker</h3>
<p>If you want to continue to subdivide and select the linker, continue to add related linker options, for example:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --ld=armv7-linux-clang++ --sh=armv7-linux-clang++ --ar=armv7-linux-ar
</code></pre>
<p>ld specifies the executable program linker, sh specifies the shared library program linker, and ar specifies the archiver that generates the static library.</p>
<p>Note: If there are ld/sh/ar environment variables, the value specified in the current environment variable will be used first.</p>
<h3 id="set-header-file-and-library-search-directory">Set header file and library search directory</h3>
<p>If there are additional other include/lib directories in the SDK that are not in the standard structure, resulting in cross compilation can not find the library and header files, then we can append the search path through <code>--includedirs</code> and<code>--linkdirs</code>, and then Add additional link libraries via <code>--links</code>.</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/toolsdk --includedirs=/usr/toolsdk/xxx/include --linkdirs=/usr/toolsdk/xxx/lib --links=pthread
</code></pre>
<p>Note: If you want to specify multiple search directories, you can use <code>:</code> or <code>;</code> to separate, which is the path separator of different host platforms, use <code>:</code> under linux / macos, and <code>;</code> under win.</p>
<h3 id="set-compile-and-link-options">Set compile and link options</h3>
<p>We can also configure some additional compilation and linking options through <code>--cflags</code>,<code>--cxxflags</code>, <code>--ldflags</code>, <code>--shflags</code> and <code>--arflags</code> according to the actual situation.</p>
<ul>
<li>cflags: specify c compilation parameters</li>
<li>cxxflags: specify c ++ compilation parameters</li>
<li>cxflags: specify c / c ++ compilation parameters</li>
<li>asflags: specify assembler compilation parameters</li>
<li>ldflags: specify executable program link parameters</li>
<li>shflags: specify dynamic library program link parameters</li>
<li>arflags: specify the generation parameters of the static library</li>
</ul>
<p>e.g:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/toolsdk --cflags=&quot;-DTEST -I/xxx/xxx&quot; --ldflags=&quot;-lpthread&quot;
</code></pre>
<h3 id="project-description-settings">Project description settings</h3>
<h4 id="set_toolchains">set_toolchains</h4>
<p>This sets up different tool chains for a specific target individually. Unlike set_toolset, this interface is an overall switch for a complete tool chain, such as cc/ld/sh and a series of tool sets.</p>
<p>This is also a recommended practice, because most compiler tool chains like gcc/clang, the compiler and the linker are used together. To cut it, you have to cut it as a whole. Separate and scattered switch settings will be cumbersome.</p>
<p>For example, we switch the test target to two tool chains of clang+yasm:</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    set_toolchains(&quot;clang&quot;, &quot;yasm&quot;)
</code></pre>
<h4 id="set_toolset">set_toolset</h4>
<p>If you feel that it is more complicated to configure through the command line each time, some configurations can be pre-configured in xmake.lua to simplify the command configuration. For example, the specification of the compiler can be set individually for each target through set_toolset.</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    set_toolset(&quot;cxx&quot;, &quot;clang&quot;)
    set_toolset(&quot;ld&quot;, &quot;clang++&quot;)
</code></pre>
<p>Force the compiler and linker of the test target to use the clang compiler, or specify the compiler name or path in the cross-compilation tool chain.</p>
<h4 id="set_config">set_config</h4>
<p>We can also set the default value of each configuration parameter in the <code>xmake f/config</code> command through <code>set_config</code>. This is a global api and will take effect for each target.</p>
<pre><code class="lang-lua">set_config(&quot;cflags&quot;, &quot;-DTEST&quot;)
set_config(&quot;sdk&quot;, &quot;/home/xxx/tooksdk&quot;)
set_config(&quot;cc&quot;, &quot;gcc&quot;)
set_config(&quot;ld&quot;, &quot;g++&quot;)
</code></pre>
<p>However, we can still use xmake f --name = value` to modify the default configuration in xmake.lua.</p>
<h3 id="custom-build-platform">Custom build platform</h3>
<p>If the target program has a corresponding platform to be specified after a cross tool chain is compiled, and it needs to be configured in xmake.lua according to different cross compilation platforms, and some additional compilation parameters need to be configured, then the <code>-p cross</code> setting above Can not meet the demand.</p>
<p>In fact, the <code>-p/-plat=</code> parameter can also be set to other custom values. You only need to maintain the corresponding relationship with <code>is_plat</code>. All non-built-in platform names will default to cross-compilation mode, for example:</p>
<pre><code class="lang-bash">$ xmake f -p myplat --sdk=/usr/local/arm-xxx-gcc/
$ xmake
</code></pre>
<p>We passed in the myplat custom platform name as the current cross-toolchain compilation platform, and then we set the corresponding settings for this platform in xmake.lua:</p>
<pre><code class="lang-lua">if is_plat(&quot;myplat&quot;) then
    add_defines(&quot;TEST&quot;)
end
</code></pre>
<p>In this way, xmake can be easily extended to deal with various compilation platforms, users can extend their own support for freebsd, netbsd, sunos and other cross-compiling platforms.</p>
<p>I excerpted a cross-compilation configuration written before porting libuv, and intuitively feel:</p>
<pre><code class="lang-lua">-- for gragonfly/freebsd/netbsd/openbsd platform
if is_plat(&quot;gragonfly&quot;, &quot;freebsd&quot;, &quot;netbsd&quot;, &quot;openbsd&quot;) then
    add_files(&quot;src/unix/bsd-ifaddrs.c&quot;)
    add_files(&quot;src/unix/freebsd.c&quot;)
    add_files(&quot;src/unix/kqueue.c&quot;)
    add_files(&quot;src/unix/posix-hrtime.c&quot;)
    add_headerfiles(&quot;(include/uv-bsd.h)&quot;)
end 

-- for sunos platform
if is_plat(&quot;sunos&quot;) then
    add_files(&quot;src/unix/no-proctitle.c&quot;)
    add_files(&quot;src/unix/sunos.c&quot;)
    add_defines(&quot;__EXTENSIONS_&quot;, &quot;_XOPEN_SOURCE=600&quot;)
    add_headerfiles(&quot;(include/uv-sunos.h)&quot;)
end
</code></pre>
<p>Then, we can switch these platforms to compile:</p>
<pre><code class="lang-bash">$ xmake f -p [gragonfly|freebsd|netbsd|openbsd|sunos] --sdk=/home/arm-xxx-gcc/
$ xmake
</code></pre>
<p>In addition, the built-in Linux platform also supports cross-compilation. If you do nâ€™t want to configure other platform names, you can cross-compile as the linux platform.</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/local/arm-xxx-gcc/
$ xmake
</code></pre>
<p>As long as the <code>--sdk=</code> and other parameters are set, the cross-compilation mode of the Linux platform will be enabled.</p>
<h3 id="toolchain-configuration">Toolchain configuration</h3>
<p>!&gt; This feature requires v2.3.4 or later to support</p>
<p>The above describes the general cross-compilation toolchain configuration. If some specific toolchains need to be imported into additional scenarios such as <code>--ldflags/--includedirs</code>, it is more cumbersome<br>Therefore, xmake also has some common tool chains built-in, which can save the complicated configuration process of cross-compilation tool chain, and only need to execute:</p>
<pre><code class="lang-bash">$ xmake f --toolchain=gnu-rm --sdk=/xxx/
$ xmake
</code></pre>
<p>You can quickly switch the designated cross-compilation tool chain. If this tool chain needs to add some specific flags settings, it will be automatically set up to simplify configuration.</p>
<p>Among them, gnu-rm is the built-in GNU Arm Embedded Toolchain.</p>
<p>For example, we can also quickly switch from the entire gcc tool chain to the clang or llvm tool chain, no longer need to make <code>xmake f --cc=clang --cxx=clang --ld=clang++</code> one by one.</p>
<pre><code class="lang-bash">$ xmake f --toolchain=clang
$ xmake
</code></pre>
<p>or</p>
<pre><code class="lang-bash">$ xmake f --toolchain=llvm --sdk=/xxx/llvm
$ xmake
</code></pre>
<p>The specific tool chains supported by xmake can be viewed with the following command:</p>
<pre><code class="lang-bash">$ xmake show -l toolchains
xcode         Xcode IDE
vs            VisualStudio IDE
yasm          The Yasm Modular Assembler
clang         A C language family frontend for LLVM
go            Go Programming Language Compiler
dlang         D Programming Language Compiler
sdcc          Small Device C Compiler
cuda          CUDA Toolkit
ndk           Android NDK
rust          Rust Programming Language Compiler
llvm          A collection of modular and reusable compiler and toolchain technologies
cross         Common cross compilation toolchain
nasm          NASM Assembler
gcc           GNU Compiler Collection
mingw         Minimalist GNU for Windows
gnu-rm        GNU Arm Embedded Toolchain
envs          Environment variables toolchain
fasm          Flat Assembler
</code></pre>
<h4 id="custom-toolchain">Custom toolchain</h4>
<p>In addition, we can also customize the toolchain in xmake.lua, and then specify the switch through <code>xmake f --toolchain=myclang</code>, for example:</p>
<pre><code class="lang-lua">toolchain(&quot;myclang&quot;)
    set_kind(&quot;standalone&quot;)
    set_toolset(&quot;cc&quot;, &quot;clang&quot;)
    set_toolset(&quot;cxx&quot;, &quot;clang&quot;, &quot;clang++&quot;)
    set_toolset(&quot;ld&quot;, &quot;clang++&quot;, &quot;clang&quot;)
    set_toolset(&quot;sh&quot;, &quot;clang++&quot;, &quot;clang&quot;)
    set_toolset(&quot;ar&quot;, &quot;ar&quot;)
    set_toolset(&quot;ex&quot;, &quot;ar&quot;)
    set_toolset(&quot;strip&quot;, &quot;strip&quot;)
    set_toolset(&quot;mm&quot;, &quot;clang&quot;)
    set_toolset(&quot;mxx&quot;, &quot;clang&quot;, &quot;clang++&quot;)
    set_toolset(&quot;as&quot;, &quot;clang&quot;)

    - ...
</code></pre>
<p>For details about this piece, you can go to the <a href="/manual/custom_toolchain">Custom Toolchain</a>.</p>
<p>For more details, please see: <a href="https://github.com/xmake-io/xmake/issues/780">#780</a></p>
<h4 id="mingw-toolchain">MingW Toolchain</h4>
<p>Compiling with the mingw toolchain is actually cross-compilation, but because this is more commonly used, xmake specifically adds a mingw platform to quickly handle compilation using the mingw toolchain.</p>
<p>Therefore, xmake&#39;s toolchain detection for mingw will be more perfect. Under macos, basically even the sdk path does not need to be configured, and can be directly detected, only need to switch to the mingw platform to compile.</p>
<pre><code class="lang-bash">$ xmake f -p mingw
$ xmake -v
configure
{
    ld = /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-g++
    ndk_stdcxx = true
    plat = mingw
    mingw = /usr/local/opt/mingw-w64
    buildir = build
    arch = x86_64
    xcode = /Applications/Xcode.app
    mode = release
    cxx = /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-gcc
    cross = x86_64-w64-mingw32-
    theme = default
    kind = static
    ccache = true
    host = macosx
    clean = true
    bin = /usr/local/opt/mingw-w64/bin
}
[  0%]: ccache compiling.release src/main.cpp
/usr/local/bin/ccache /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-gcc -c -fvisibility=hidden -O3 -m64 -o build/.objs/test/mingw/x86_64/release/src/main.cpp.obj src/main.cpp
[100%]: linking.release test.exe
/usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-g++ -o build/mingw/x86_64/release/test.exe build/.objs/test/mingw/x86_64/release/src/main.cpp.obj -s -fvisibility=hidden -m64
build ok!
</code></pre>
<p>Here we have added the <code>-v</code> parameter and looked at the detailed compile commands and detected mingw toolchain configuration values, where cross is automatically detected as:<code>x86_64-w64-mingw32-</code>, and the bin directory is also automatically detected , As well as compilers and linkers.</p>
<p>Although it is not possible to automatically detect the sdk path on linux/win, we can also manually specify the sdk path. It should be noted that xmake specifically provides a <code>--mingw =</code> parameter for mingw to specify the tool chain root of mingw The directory has the same effect as <code>--sdk =</code>, but it can be set as a global configuration.</p>
<pre><code class="lang-bash">$ xmake g --mingw=/home/mingwsdk
$ xmake f -p mingw
$ xmake
</code></pre>
<p>After setting the <code>--mingw</code> root directory to the global configuration through the<code>xmake g/global</code> command, after each compilation and switching of the compilation platform, there is no need to specify an additional mingw toolchain path, which is convenient for use.</p>
<p>In addition, the usage of other tool chain configuration parameters is the same as that described above. For example, <code>--cross</code>,<code>--bin=</code>, etc. can be adjusted according to the actual needs of the environment. Own mingw tool chain.</p>
<h4 id="llvm-toolchain">LLVM Toolchain</h4>
<p>The tool chain of llvm is relatively standard, only need to set the sdk configuration path to use:</p>
<pre><code class="lang-bash">$ xmake f -p cross --toolchain=llvm --sdk=&quot;C:\Program Files\LLVM&quot;
$ xmake
</code></pre>
<h4 id="gnu-rm-toolchain">GNU-RM Toolchain</h4>
<p>toolchain downlaod url: <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads#">https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads#</a></p>
<pre><code class="lang-bash">$ xmake f -p cross --toolchain=gnu-rm --sdk=/xxx/cc-arm-none-eabi-9-2019-q4-major
$ xmake
</code></pre>
<h3 id="common-cross-compilation-configuration">Common Cross-compilation configuration</h3>
<table>
<thead>
<tr>
<th>Configuration Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#-sdk">--sdk</a></td>
<td>Set the sdk root directory of toolchains</td>
</tr>
<tr>
<td><a href="#-bin">--bin</a></td>
<td>Set the <code>bin</code> directory of toolchains</td>
</tr>
<tr>
<td><a href="#-cross">--cross</a></td>
<td>Set the prefix of compilation tools</td>
</tr>
<tr>
<td><a href="#-as">--as</a></td>
<td>Set <code>asm</code> assembler</td>
</tr>
<tr>
<td><a href="#-cc">--cc</a></td>
<td>Set <code>c</code> compiler</td>
</tr>
<tr>
<td><a href="#-cxx">--cxx</a></td>
<td>Set <code>c++</code> compiler</td>
</tr>
<tr>
<td><a href="#-mm">--mm</a></td>
<td>Set <code>objc</code> compiler</td>
</tr>
<tr>
<td><a href="#-mxx">--mxx</a></td>
<td>Set <code>objc++</code> compiler</td>
</tr>
<tr>
<td><a href="#-sc">--sc</a></td>
<td>Set <code>swift</code> compiler</td>
</tr>
<tr>
<td><a href="#-gc">--gc</a></td>
<td>Set <code>golang</code> compiler</td>
</tr>
<tr>
<td><a href="#-dc">--dc</a></td>
<td>Set <code>dlang</code> compiler</td>
</tr>
<tr>
<td><a href="#-rc">--rc</a></td>
<td>Set <code>rust</code> compiler</td>
</tr>
<tr>
<td><a href="#-cu">--cu</a></td>
<td>Set <code>cuda</code> compiler</td>
</tr>
<tr>
<td><a href="#-ld">--ld</a></td>
<td>Set <code>c/c++/objc/asm</code> linker</td>
</tr>
<tr>
<td><a href="#-sh">--sh</a></td>
<td>Set <code>c/c++/objc/asm</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-ar">--ar</a></td>
<td>Set <code>c/c++/objc/asm</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-scld">--scld</a></td>
<td>Set <code>swift</code> linker</td>
</tr>
<tr>
<td><a href="#-scsh">--scsh</a></td>
<td>Set <code>swift</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-gcld">--gcld</a></td>
<td>Set <code>golang</code> linker</td>
</tr>
<tr>
<td><a href="#-gcar">--gcar</a></td>
<td>Set <code>golang</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-dcld">--dcld</a></td>
<td>Set <code>dlang</code> linker</td>
</tr>
<tr>
<td><a href="#-dcsh">--dcsh</a></td>
<td>Set <code>dlang</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-dcar">--dcar</a></td>
<td>Set <code>dlang</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-rcld">--rcld</a></td>
<td>Set <code>rust</code> linker</td>
</tr>
<tr>
<td><a href="#-rcsh">--rcsh</a></td>
<td>Set <code>rust</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-rcar">--rcar</a></td>
<td>Set <code>rust</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-cu-ccbin">--cu-ccbin</a></td>
<td>Set <code>cuda</code> host compiler</td>
</tr>
<tr>
<td><a href="#-culd">--culd</a></td>
<td>Set <code>cuda</code> linker</td>
</tr>
<tr>
<td><a href="#-asflags">--asflags</a></td>
<td>Set <code>asm</code> assembler option</td>
</tr>
<tr>
<td><a href="#-cflags">--cflags</a></td>
<td>Set <code>c</code> compiler option</td>
</tr>
<tr>
<td><a href="#-cxflags">--cxflags</a></td>
<td>Set <code>c/c++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-cxxflags">--cxxflags</a></td>
<td>Set <code>c++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-mflags">--mflags</a></td>
<td>Set <code>objc</code> compiler option</td>
</tr>
<tr>
<td><a href="#-mxflags">--mxflags</a></td>
<td>Set <code>objc/c++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-mxxflags">--mxxflags</a></td>
<td>Set <code>objc++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-scflags">--scflags</a></td>
<td>Set <code>swift</code> compiler option</td>
</tr>
<tr>
<td><a href="#-gcflags">--gcflags</a></td>
<td>Set <code>golang</code> compiler option</td>
</tr>
<tr>
<td><a href="#-dcflags">--dcflags</a></td>
<td>Set <code>dlang</code> compiler option</td>
</tr>
<tr>
<td><a href="#-rcflags">--rcflags</a></td>
<td>Set <code>rust</code> compiler option</td>
</tr>
<tr>
<td><a href="#-cuflags">--cuflags</a></td>
<td>Set <code>cuda</code> compiler option</td>
</tr>
<tr>
<td><a href="#-ldflags">--ldflags</a></td>
<td>Set  linker option</td>
</tr>
<tr>
<td><a href="#-shflags">--shflags</a></td>
<td>Set  shared library linker option</td>
</tr>
<tr>
<td><a href="#-arflags">--arflags</a></td>
<td>Set  static library archiver option</td>
</tr>
</tbody>
</table>
<p>&lt;p class=&quot;tip&quot;&gt;<br>if you want to known more options, please run: <code>xmake f --help</code>ã€‚<br>&lt;/p&gt;

</p>
<h4 id="-sdk">--sdk</h4>
<ul>
<li>Set the sdk root directory of toolchains</li>
</ul>
<p>xmake provides a convenient and flexible cross-compiling support.<br>In most cases, we need not to configure complex toolchains prefix, for example: <code>arm-linux-</code></p>
<p>As long as this toolchains meet the following directory structure:</p>
<pre><code>/home/toolchains_sdkdir
   - bin
       - arm-linux-gcc
       - arm-linux-ld
       - ...
   - lib
       - libxxx.a
   - include
       - xxx.h
</code></pre><p>Thenï¼Œwe can only configure the sdk directory and build it.</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/home/toolchains_sdkdir
$ xmake
</code></pre>
<p>xmake will detect the prefix: arm-linux- and add the include and library search directory automatically.</p>
<pre><code>-I/home/toolchains_sdkdir/include -L/home/toolchains_sdkdir/lib
</code></pre><h4 id="-bin">--bin</h4>
<ul>
<li>Set the <code>bin</code> directory of toolchains</li>
</ul>
<p>We need set it manually if the toolchains /bin directory is in other places, for example:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/home/toolchains_sdkdir --bin=/usr/opt/bin
$ xmake
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>Before v2.2.1 version, this parameter name is <code>--toolchains</code>, exists more ambiguous, so we changed to <code>--bin=</code> to set the bin directory.<br>&lt;/p&gt;

</p>
<h4 id="-cross">--cross</h4>
<ul>
<li>Set the prefix of compilation tools</li>
</ul>
<p>For example, under the same toolchains directory at the same time, there are two different compilers:</p>
<pre><code>/opt/bin
 - armv7-linux-gcc
 - aarch64-linux-gcc
</code></pre><p>If we want to use the <code>armv7-linux-gcc</code> compiler, we can run the following command:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/toolsdk --bin=/opt/bin --cross=armv7-linux-
</code></pre>
<h4 id="-as">--as</h4>
<ul>
<li>Set <code>asm</code> assembler</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --as=armv7-linux-as
</code></pre>
<p>If the &#39;AS&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>We can set a unknown compiler as like-gcc/clang compiler, .e.g <code>xmake f --as=gcc@/home/xxx/asmips.exe</code><br>&lt;/p&gt;

</p>
<h4 id="-cc">--cc</h4>
<ul>
<li>Set c compiler</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --cc=armv7-linux-clang
</code></pre>
<p>If the &#39;CC&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>We can set a unknown compiler as like-gcc/clang compiler, .e.g <code>xmake f --cc=gcc@/home/xxx/ccmips.exe</code><br>&lt;/p&gt;

</p>
<h4 id="-cxx">--cxx</h4>
<ul>
<li>Set <code>c++</code> compiler</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --cxx=armv7-linux-clang++
</code></pre>
<p>If the &#39;CXX&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>We can set a unknown compiler as like-gcc/clang compiler, .e.g <code>xmake f --cxx=g++@/home/xxx/c++mips.exe</code><br>&lt;/p&gt;

</p>
<h4 id="-ld">--ld</h4>
<ul>
<li>Set <code>c/c++/objc/asm</code> linker</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --ld=armv7-linux-clang++
</code></pre>
<p>If the &#39;LD&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>We can set a unknown compiler as like-gcc/clang linker, .e.g <code>xmake f --ld=g++@/home/xxx/c++mips.exe</code><br>&lt;/p&gt;

</p>
<h4 id="-sh">--sh</h4>
<ul>
<li>Set <code>c/c++/objc/asm</code> shared library linker</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --sh=armv7-linux-clang++
</code></pre>
<p>If the &#39;SH&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>We can set a unknown compiler as like-gcc/clang linker, .e.g <code>xmake f --sh=g++@/home/xxx/c++mips.exe</code><br>&lt;/p&gt;

</p>
<h4 id="-ar">--ar</h4>
<ul>
<li>Set <code>c/c++/objc/asm</code> static library archiver</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --ar=armv7-linux-ar
</code></pre>
<p>If the &#39;AR&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>We can set a unknown compiler as like-ar archiver, .e.g <code>xmake f --ar=ar@/home/xxx/armips.exe</code><br>&lt;/p&gt;

</p>
<h2 id="global-configuration">Global Configuration</h2>
<p>You can save to the global configuration for simplfying operation.</p>
<p>For example:</p>
<pre><code class="lang-bash">$ xmake g --ndk=~/files/android-ndk-r10e/
</code></pre>
<p>Now, we config and build project for android again.</p>
<pre><code class="lang-bash">$ xmake f -p android
$ xmake
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>    You can use short or long command option, for example: <code>xmake g</code> or <code>xmake global</code>.&lt;br&gt;<br>&lt;/p&gt;

</p>
<h2 id="clean-configuration">Clean Configuration</h2>
<p>We can clean all cached configuration and re-configure project.</p>
<pre><code class="lang-bash">$ xmake f -c
$ xmake
</code></pre>
<p>or </p>
<pre><code class="lang-bash">$ xmake f -p iphoneos -c
$ xmake
</code></pre>
</article>
</body>
</html>