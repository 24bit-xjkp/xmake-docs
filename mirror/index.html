<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="//cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/">https://xmake.io/#/</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <h2 id="introduction">Introduction</h2>
<p>xmake is a cross-platform build utility based on lua. </p>
<p>The project focuses on making development and building easier and provides many features (.e.g package, install, plugin, macro, action, option, task ...),<br>so that any developer can quickly pick it up and enjoy the productivity boost when developing and building project.</p>
<h2 id="installation">Installation</h2>
<h4 id="master">Master</h4>
<h4 id="via-curl">via curl</h4>
<pre><code class="lang-bash">bash <(curl -fsSL https://xmake.io/shget.text)
</code></pre>
<h4 id="via-wget">via wget</h4>
<pre><code class="lang-bash">bash <(wget https://xmake.io/shget.text -O -)
</code></pre>
<h4 id="via-powershell">via powershell</h4>
<pre><code class="lang-powershell">Invoke-Expression (Invoke-Webrequest &#39;https://xmake.io/psget.text&#39; -UseBasicParsing).Content
</code></pre>
<h4 id="windows">Windows</h4>
<h5 id="via-installer">via installer</h5>
<ol>
<li>Download xmake windows installer from <a href="https://github.com/xmake-io/xmake/releases">Releases</a></li>
<li>Run xmake-[version].exe</li>
</ol>
<h5 id="via-scoop">via scoop</h5>
<pre><code class="lang-bash">scoop install xmake
</code></pre>
<h4 id="macos">MacOS</h4>
<pre><code class="lang-bash">$ brew install xmake
</code></pre>
<h4 id="linux">Linux</h4>
<p>On Archlinux:</p>
<pre><code class="lang-bash">$ yaourt xmake
</code></pre>
<p>On Ubuntu:</p>
<pre><code class="lang-bash">$ sudo add-apt-repository ppa:tboox/xmake
$ sudo apt update
$ sudo apt install xmake
</code></pre>
<p>Or add xmake package source manually:</p>
<pre><code>deb http://ppa.launchpad.net/tboox/xmake/ubuntu yakkety main 
deb-src http://ppa.launchpad.net/tboox/xmake/ubuntu yakkety main 
</code></pre><p>Then we run:</p>
<pre><code class="lang-bash">$ sudo apt update
$ sudo apt install xmake
</code></pre>
<p>Or download deb package to install it:</p>
<ol>
<li>Download xmake <code>.deb</code> install package from <a href="https://github.com/xmake-io/xmake/releases">Releases</a> </li>
<li>Run <code>dpkg -i xmake-xxxx.deb</code></li>
</ol>
<h4 id="compilation">Compilation</h4>
<p>Compile and install:</p>
<pre><code class="lang-bash">$ git clone https://github.com/xmake-io/xmake.git
$ cd ./xmake
$ ./scripts/get.sh __local__
</code></pre>
<p>Only install and update lua scripts:</p>
<pre><code class="lang-bash">$ ./scripts/get.sh __local__ __install_only__
</code></pre>
<p>Uninstall:</p>
<pre><code class="lang-bash">$ ./scripts/get.sh __uninstall__
</code></pre>
<p>Or compile and install via make:</p>
<pre><code class="lang-bash">$ make build; sudo make install
</code></pre>
<p>Install to other given directory:</p>
<pre><code class="lang-bash">$ sudo make install prefix=/usr/local
</code></pre>
<p>Uninstall:</p>
<pre><code class="lang-bash">$ sudo make uninstall
</code></pre>
<h4 id="update">Update</h4>
<p>We can run <code>xmake update</code> to update xmake version after v2.2.3 and we can also update to the given version:</p>
<pre><code class="lang-bash">$ xmake update 2.2.4
</code></pre>
<p>We can also specify an update to the master/dev branch version:</p>
<pre><code class="lang-bash">$ xmake update master
$ xmake update dev
</code></pre>
<p>Finally, if we want to uninstall xmake, it is also supported: <code>xmake update --uninstall</code>.</p>
<h2 id="quick-start">Quick Start</h2>
<p><a href="https://asciinema.org/a/133693"><img src="https://asciinema.org/a/133693.png" alt="asciicast"></a></p>
<h4 id="create-project">Create Project</h4>
<pre><code class="lang-bash">$ xmake create -l c -P ./hello
</code></pre>
<p>And xmake will generate some files for c language project:</p>
<pre><code>hello
├── src
│   └── main.c
└── xmake.lua
</code></pre><p>It is a simple console program only for printing <code>hello xmake!</code></p>
<p>The content of <code>xmake.lua</code> is very simple:</p>
<pre><code class="lang-lua">target("hello")
    set_kind("binary")
    add_files("src/*.c") 
</code></pre>
<p>Support languages:</p>
<ul>
<li>c/c++</li>
<li>objc/c++</li>
<li>cuda</li>
<li>asm</li>
<li>swift</li>
<li>dlang</li>
<li>golang</li>
<li>rust</li>
</ul>
<p><p class="tip"><br>    If you want to known more options, please run: <code>xmake create --help</code><br></p>

</p>
<h4 id="build-project">Build Project</h4>
<pre><code class="lang-bash">$ xmake
</code></pre>
<h4 id="run-program">Run Program</h4>
<pre><code class="lang-bash">$ xmake run hello
</code></pre>
<h4 id="debug-program">Debug Program</h4>
<pre><code class="lang-bash">$ xmake run -d hello 
</code></pre>
<p>It will start the debugger (.e.g lldb, gdb, windbg, vsjitdebugger, ollydbg ..) to load our program.</p>
<pre><code class="lang-bash">[lldb]$target create "build/hello"
Current executable set to &#39;build/hello&#39; (x86_64).
[lldb]$b main
Breakpoint 1: where = hello`main, address = 0x0000000100000f50
[lldb]$r
Process 7509 launched: &#39;/private/tmp/hello/build/hello&#39; (x86_64)
Process 7509 stopped
* thread #1: tid = 0x435a2, 0x0000000100000f50 hello`main, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1
    frame #0: 0x0000000100000f50 hello`main
hello`main:
->  0x100000f50 <+0>:  pushq  %rbp
    0x100000f51 <+1>:  movq   %rsp, %rbp
    0x100000f54 <+4>:  leaq   0x2b(%rip), %rdi          ; "hello world!"
    0x100000f5b <+11>: callq  0x100000f64               ; symbol stub for: puts
[lldb]$
</code></pre>
<p><p class="tip"><br>    You can also use short command option, for exmaple: <code>xmake r</code> or <code>xmake run</code><br></p>

</p>
<h2 id="project-examples">Project Examples</h2>
<h4 id="executable-program">Executable Program</h4>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*c")
</code></pre>
<h4 id="static-library-program">Static Library Program</h4>
<pre><code class="lang-lua">target("library")
    set_kind("static")
    add_files("src/library/*.c")

target("test")
    set_kind("binary")
    add_files("src/*c")
    add_deps("library")
</code></pre>
<p>We use <code>add_deps</code> to link a static library to test target.</p>
<h4 id="share-library-program">Share Library Program</h4>
<pre><code class="lang-lua">target("library")
    set_kind("shared")
    add_files("src/library/*.c")

target("test")
    set_kind("binary")
    add_files("src/*c")
    add_deps("library")
</code></pre>
<p>We use <code>add_deps</code> to link a share library to test target.</p>
<h4 id="qt-program">Qt Program</h4>
<p>Create an empty project:</p>
<pre><code class="lang-console">$ xmake create -l c++ -t console_qt test
$ xmake create -l c++ -t static_qt test
$ xmake create -l c++ -t shared_qt test
$ xmake create -l c++ -t quickapp_qt test
</code></pre>
<p>xmake will detect Qt SDK automatically and we can also set the SDK directory manually.</p>
<pre><code class="lang-console">$ xmake f --qt=~/Qt/Qt5.9.1
</code></pre>
<p>If you want to use the MinGW Qt environment on windows, you can set the MinGW platform configuration and specify the SDK path for the MinGW compilation environment, for example:</p>
<pre><code class="lang-console">$ xmake f -p mingw --sdk=C:\Qt\Qt5.10.1\Tools\mingw530_32 
</code></pre>
<p>If you want to known more information, you can see <a href="https://github.com/xmake-io/xmake/issues/160">#160</a>.</p>
<h5 id="static-library">Static Library</h5>
<pre><code class="lang-lua">target("qt_static_library")
    add_rules("qt.static")
    add_files("src/*.cpp")
    add_frameworks("QtNetwork", "QtGui")
</code></pre>
<h5 id="shared-library">Shared Library</h5>
<pre><code class="lang-lua">target("qt_shared_library")
    add_rules("qt.shared")
    add_files("src/*.cpp")
    add_frameworks("QtNetwork", "QtGui")
</code></pre>
<h5 id="console-program">Console Program</h5>
<pre><code class="lang-lua">target("qt_console")
    add_rules("qt.console")
    add_files("src/*.cpp")
</code></pre>
<h5 id="quick-application">Quick Application</h5>
<pre><code class="lang-lua">target("qt_quickapp")
    add_rules("qt.application")
    add_files("src/*.cpp") 
    add_files("src/qml.qrc")
    add_frameworks("QtQuick")
</code></pre>
<h5 id="widgets-application">Widgets Application</h5>
<pre><code class="lang-lua">target("qt_widgetapp")
    add_rules("qt.application")
    add_files("src/*.cpp") 
    add_files("src/mainwindow.ui")
    add_files("src/mainwindow.h")  -- add files with Q_OBJECT meta (only for qt.moc)
    add_frameworks("QtWidgets")
</code></pre>
<h5 id="android-application">Android Application</h5>
<p>After the 2.2.6 version, you can directly switch to the android platform to compile the Quick/Widgets application, generate the apk package, and install it to the device via the <code>xmake install</code> command.</p>
<pre><code class="lang-console">$ xmake create -t quickapp_qt -l c ++ appdemo
$ cd appdemo
$ xmake f -p android --ndk=~/Downloads/android-ndk-r19c/ --android_sdk=~/Library/Android/sdk/ -c
$ xmake
[0%]: compiling.qt.qrc src/qml.qrc
[ 50%]: ccache compiling.release src/main.cpp
[100%]: linking.release libappdemo.so
[100%]: generating.qt.app appdemo.apk
</code></pre>
<p>Then install to the device:</p>
<pre><code class="lang-console">$ xmake install
installing appdemo ...
installing build/android/release/appdemo.apk ..
success
install ok!👌
</code></pre>
<h4 id="cuda-program">Cuda Program</h4>
<p>Create an empty project:</p>
<pre><code class="lang-console">$ xmake create -P test -l cuda
$ cd test
$ xmake
</code></pre>
<pre><code class="lang-lua">-- define target
target("cuda_console")
    set_kind("binary")
    add_files("src/*.cu")
    -- generate SASS code for SM architecture of current host
    add_cugencodes("native")
    -- generate PTX code for the virtual architecture to guarantee compatibility
    add_cugencodes("compute_30")
</code></pre>
<p><p class="tip"><br>Starting with v2.2.7, the default build will enable device-link. (see <a href="https://devblogs.nvidia.com/separate-compilation-linking-cuda-device-code/">Separate Compilation and Linking of CUDA C++ Device Code</a>)<br>If you want to disable device-link, you can set it with <code>add_values("cuda.devlink", false)</code>.<br></p>

</p>
<p>xmake will detect Cuda SDK automatically and we can also set the SDK directory manually.</p>
<pre><code class="lang-console">$ xmake f --cuda=/usr/local/cuda-9.1/ 
$ xmake
</code></pre>
<p>If you want to known more information, you can see <a href="https://github.com/xmake-io/xmake/issues/158">#158</a>.</p>
<h4 id="wdk-driver-program">WDK Driver Program</h4>
<p>xmake will detect WDK automatically and we can also set the WDK directory manually.</p>
<pre><code class="lang-console">$ xmake f --wdk="G:\Program Files\Windows Kits\10" -c
$ xmake
</code></pre>
<p>If you want to known more information, you can see <a href="https://github.com/xmake-io/xmake/issues/159">#159</a>.</p>
<h5 id="umdf-driver-program">UMDF Driver Program</h5>
<pre><code class="lang-lua">target("echo")
    add_rules("wdk.driver", "wdk.env.umdf")
    add_files("driver/*.c") 
    add_files("driver/*.inx")
    add_includedirs("exe")

target("app")
    add_rules("wdk.binary", "wdk.env.umdf")
    add_files("exe/*.cpp") 
</code></pre>
<h5 id="kmdf-driver-program">KMDF Driver Program</h5>
<pre><code class="lang-lua">target("nonpnp")
    add_rules("wdk.driver", "wdk.env.kmdf")
    add_values("wdk.tracewpp.flags", "-func:TraceEvents(LEVEL,FLAGS,MSG,...)", "-func:Hexdump((LEVEL,FLAGS,MSG,...))")
    add_files("driver/*.c", {rule = "wdk.tracewpp"}) 
    add_files("driver/*.rc")

target("app")
    add_rules("wdk.binary", "wdk.env.kmdf")
    add_files("exe/*.c") 
    add_files("exe/*.inf")
</code></pre>
<h5 id="wdm-driver-program">WDM Driver Program</h5>
<pre><code class="lang-lua">target("kcs")
    add_rules("wdk.driver", "wdk.env.wdm")
    add_values("wdk.man.flags", "-prefix Kcs")
    add_values("wdk.man.resource", "kcsCounters.rc")
    add_values("wdk.man.header", "kcsCounters.h")
    add_values("wdk.man.counter_header", "kcsCounters_counters.h")
    add_files("*.c", "*.rc", "*.man") 
</code></pre>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    add_values("wdk.tracewpp.flags", "-func:TracePrint((LEVEL,FLAGS,MSG,...))")
    add_files("*.c", {rule = "wdk.tracewpp"}) 
    add_files("*.rc", "*.inf")
    add_files("*.mof|msdsm.mof")
    add_files("msdsm.mof", {values = {wdk_mof_header = "msdsmwmi.h"}}) 
</code></pre>
<h5 id="package-driver">Package Driver</h5>
<p>We can run the following command to generate a .cab driver package.</p>
<pre><code class="lang-console">$ xmake [p|package]
$ xmake [p|package] -o outputdir
</code></pre>
<p>The output files like:</p>
<pre><code>  - drivers
    - sampledsm
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
       - debug/x86/sampledsm.cab
       - release/x64/sampledsm.cab
</code></pre><h5 id="driver-signing">Driver Signing</h5>
<p>The driver signing is disabled when we compile driver in default case,<br>but we can add <code>set_values("wdk.sign.mode")</code> to enable test/release sign.</p>
<h6 id="testsign">TestSign</h6>
<p>We can use test certificate of xmake to do testsign, but please run <code>$xmake l utils.wdk.testcert</code> install as admin to install a test certificate first (only once)!</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
</code></pre>
<p>Or we set a valid certificate thumbprint to do it in local machine.</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
    set_values("wdk.sign.thumbprint", "032122545DCAA6167B1ADBE5F7FDF07AE2234AAA")
</code></pre>
<p>We can also do testsign via setting store/company info.</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "test")
    set_values("wdk.sign.store", "PrivateCertStore")
    set_values("wdk.sign.company", "tboox.org(test)")
</code></pre>
<h6 id="releasesign">ReleaseSign</h6>
<p>We can set a certificate file for release signing.</p>
<pre><code class="lang-lua">target("msdsm")
    add_rules("wdk.driver", "wdk.env.wdm")
    set_values("wdk.sign.mode", "release")
    set_values("wdk.sign.company", "xxxx")
    set_values("wdk.sign.certfile", path.join(os.projectdir(), "xxxx.cer"))
</code></pre>
<h5 id="support-low-version-system">Support Low-version System</h5>
<p>We can set <code>wdk.env.winver</code> to generate a driver package that is compatible with a low version system.</p>
<pre><code class="lang-lua">set_values("wdk.env.winver", "win10")
set_values("wdk.env.winver", "win10_rs3")
set_values("wdk.env.winver", "win81")
set_values("wdk.env.winver", "win8")
set_values("wdk.env.winver", "win7")
set_values("wdk.env.winver", "win7_sp1")
set_values("wdk.env.winver", "win7_sp2")
set_values("wdk.env.winver", "win7_sp3")
</code></pre>
<p>We can also set windows version for WDK driver program:</p>
<pre><code class="lang-console">$ xmake f --wdk_winver=[win10_rs3|win8|win7|win7_sp1]
$ xmake
</code></pre>
<h4 id="winsdk-application-program">WinSDK Application Program</h4>
<pre><code class="lang-lua">target("usbview")
    add_rules("win.sdk.application")

    add_files("*.c", "*.rc")
    add_files("xmlhelper.cpp", {rule = "win.sdk.dotnet"})
</code></pre>
<p>If you want to known more information, you can see <a href="https://github.com/xmake-io/xmake/issues/173">#173</a>.</p>
<h2 id="configuration">Configuration</h2>
<p>Set compilation configuration before building project with command <code>xmake f|config</code>.</p>
<p>And if you want to known more options, please run: <code>xmake f --help</code>。</p>
<p><p class="tip"><br>    You can use short or long command option, for exmaple: <br><br>    <code>xmake f</code> or <code>xmake config</code>.<br><br>    <code>xmake f -p linux</code> or <code>xmake config --plat=linux</code>.<br></p>

</p>
<h4 id="target-platforms">Target Platforms</h4>
<h5 id="current-host">Current Host</h5>
<pre><code class="lang-bash">$ xmake
</code></pre>
<p><p class="tip"><br>    XMake will detect the current host platform automatically and build project.<br></p>

</p>
<h5 id="linux">Linux</h5>
<pre><code class="lang-bash">$ xmake f -p linux [-a i386|x86_64]
$ xmake
</code></pre>
<h5 id="android">Android</h5>
<pre><code class="lang-bash">$ xmake f -p android --ndk=~/files/android-ndk-r10e/ [-a armeabi-v7a|arm64-v8a]
$ xmake
</code></pre>
<p>If you want to set the other android toolchains, you can use <a href="#-bin">--bin</a> option.</p>
<p>For example:</p>
<pre><code class="lang-bash">$ xmake f -p android --ndk=~/files/android-ndk-r10e/ -a arm64-v8a --bin=~/files/android-ndk-r10e/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin
</code></pre>
<p>The <a href="#-bin">--bin</a> option is used to set <code>bin</code> directory of toolchains.</p>
<p><p class="tip"><br>Please attempt to set <code>--arch=</code> option if it had failed to check compiler.<br></p>

</p>
<h5 id="iphoneos">iPhoneOS</h5>
<pre><code class="lang-bash">$ xmake f -p iphoneos [-a armv7|armv7s|arm64|i386|x86_64]
$ xmake
</code></pre>
<h5 id="windows">Windows</h5>
<pre><code class="lang-bash">$ xmake f -p windows [-a x86|x64]
$ xmake
</code></pre>
<h5 id="mingw">Mingw</h5>
<pre><code class="lang-bash">$ xmake f -p mingw --sdk=/usr/local/i386-mingw32-4.3.0/ [-a i386|x86_64]
$ xmake
</code></pre>
<h5 id="apple-watchos">Apple WatchOS</h5>
<pre><code class="lang-bash">$ xmake f -p watchos [-a i386|armv7k]
$ xmake
</code></pre>
<h5 id="cross-compilation">Cross Compilation</h5>
<p>For linux platform:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/local/arm-linux-gcc/ [--bin=/sdk/bin] [--cross=arm-linux-]
$ xmake
</code></pre>
<p>Fro other cross platform:</p>
<pre><code class="lang-bash">$ xmake f -p cross --sdk=/usr/local/arm-xxx-gcc/ [--bin=/sdk/bin] [--cross=arm-linux-]
$ xmake
</code></pre>
<p>For custem cross platform (<code>is_plat("myplat")</code>):</p>
<pre><code class="lang-bash">$ xmake f -p myplat --sdk=/usr/local/arm-xxx-gcc/ [--bin=/sdk/bin] [--cross=arm-linux-]
$ xmake
</code></pre>
<table>
<thead>
<tr>
<th>Configuration Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#-sdk">--sdk</a></td>
<td>Set the sdk root directory of toolchains</td>
</tr>
<tr>
<td><a href="#-bin">--bin</a></td>
<td>Set the <code>bin</code> directory of toolchains</td>
</tr>
<tr>
<td><a href="#-cross">--cross</a></td>
<td>Set the prefix of compilation tools</td>
</tr>
<tr>
<td><a href="#-as">--as</a></td>
<td>Set <code>asm</code> assembler</td>
</tr>
<tr>
<td><a href="#-cc">--cc</a></td>
<td>Set <code>c</code> compiler</td>
</tr>
<tr>
<td><a href="#-cxx">--cxx</a></td>
<td>Set <code>c++</code> compiler</td>
</tr>
<tr>
<td><a href="#-mm">--mm</a></td>
<td>Set <code>objc</code> compiler</td>
</tr>
<tr>
<td><a href="#-mxx">--mxx</a></td>
<td>Set <code>objc++</code> compiler</td>
</tr>
<tr>
<td><a href="#-sc">--sc</a></td>
<td>Set <code>swift</code> compiler</td>
</tr>
<tr>
<td><a href="#-gc">--gc</a></td>
<td>Set <code>golang</code> compiler</td>
</tr>
<tr>
<td><a href="#-dc">--dc</a></td>
<td>Set <code>dlang</code> compiler</td>
</tr>
<tr>
<td><a href="#-rc">--rc</a></td>
<td>Set <code>rust</code> compiler</td>
</tr>
<tr>
<td><a href="#-cu">--cu</a></td>
<td>Set <code>cuda</code> compiler</td>
</tr>
<tr>
<td><a href="#-ld">--ld</a></td>
<td>Set <code>c/c++/objc/asm</code> linker</td>
</tr>
<tr>
<td><a href="#-sh">--sh</a></td>
<td>Set <code>c/c++/objc/asm</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-ar">--ar</a></td>
<td>Set <code>c/c++/objc/asm</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-scld">--scld</a></td>
<td>Set <code>swift</code> linker</td>
</tr>
<tr>
<td><a href="#-scsh">--scsh</a></td>
<td>Set <code>swift</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-gcld">--gcld</a></td>
<td>Set <code>golang</code> linker</td>
</tr>
<tr>
<td><a href="#-gcar">--gcar</a></td>
<td>Set <code>golang</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-dcld">--dcld</a></td>
<td>Set <code>dlang</code> linker</td>
</tr>
<tr>
<td><a href="#-dcsh">--dcsh</a></td>
<td>Set <code>dlang</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-dcar">--dcar</a></td>
<td>Set <code>dlang</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-rcld">--rcld</a></td>
<td>Set <code>rust</code> linker</td>
</tr>
<tr>
<td><a href="#-rcsh">--rcsh</a></td>
<td>Set <code>rust</code> shared library linker</td>
</tr>
<tr>
<td><a href="#-rcar">--rcar</a></td>
<td>Set <code>rust</code> static library archiver</td>
</tr>
<tr>
<td><a href="#-cu-cxx">--cu-cxx</a></td>
<td>Set <code>cuda</code> host compiler</td>
</tr>
<tr>
<td><a href="#-culd">--culd</a></td>
<td>Set <code>cuda</code> linker</td>
</tr>
<tr>
<td><a href="#-asflags">--asflags</a></td>
<td>Set <code>asm</code> assembler option</td>
</tr>
<tr>
<td><a href="#-cflags">--cflags</a></td>
<td>Set <code>c</code> compiler option</td>
</tr>
<tr>
<td><a href="#-cxflags">--cxflags</a></td>
<td>Set <code>c/c++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-cxxflags">--cxxflags</a></td>
<td>Set <code>c++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-mflags">--mflags</a></td>
<td>Set <code>objc</code> compiler option</td>
</tr>
<tr>
<td><a href="#-mxflags">--mxflags</a></td>
<td>Set <code>objc/c++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-mxxflags">--mxxflags</a></td>
<td>Set <code>objc++</code> compiler option</td>
</tr>
<tr>
<td><a href="#-scflags">--scflags</a></td>
<td>Set <code>swift</code> compiler option</td>
</tr>
<tr>
<td><a href="#-gcflags">--gcflags</a></td>
<td>Set <code>golang</code> compiler option</td>
</tr>
<tr>
<td><a href="#-dcflags">--dcflags</a></td>
<td>Set <code>dlang</code> compiler option</td>
</tr>
<tr>
<td><a href="#-rcflags">--rcflags</a></td>
<td>Set <code>rust</code> compiler option</td>
</tr>
<tr>
<td><a href="#-cuflags">--cuflags</a></td>
<td>Set <code>cuda</code> compiler option</td>
</tr>
<tr>
<td><a href="#-ldflags">--ldflags</a></td>
<td>Set  linker option</td>
</tr>
<tr>
<td><a href="#-shflags">--shflags</a></td>
<td>Set  shared library linker option</td>
</tr>
<tr>
<td><a href="#-arflags">--arflags</a></td>
<td>Set  static library archiver option</td>
</tr>
</tbody>
</table>
<p><p class="tip"><br>if you want to known more options, please run: <code>xmake f --help</code>。<br></p>

</p>
<h6 id="-sdk">--sdk</h6>
<ul>
<li>Set the sdk root directory of toolchains</li>
</ul>
<p>xmake provides a convenient and flexible cross-compiling support.<br>In most cases, we need not to configure complex toolchains prefix, for example: <code>arm-linux-</code></p>
<p>As long as this toolchains meet the following directory structure:</p>
<pre><code>/home/toolchains_sdkdir
   - bin
       - arm-linux-gcc
       - arm-linux-ld
       - ...
   - lib
       - libxxx.a
   - include
       - xxx.h
</code></pre><p>Then，we can only configure the sdk directory and build it.</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/home/toolchains_sdkdir
$ xmake
</code></pre>
<p>xmake will detect the prefix: arm-linux- and add the include and library search directory automatically.</p>
<pre><code>-I/home/toolchains_sdkdir/include -L/home/toolchains_sdkdir/lib
</code></pre><h6 id="-bin">--bin</h6>
<ul>
<li>Set the <code>bin</code> directory of toolchains</li>
</ul>
<p>We need set it manually if the toolchains /bin directory is in other places, for example:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/home/toolchains_sdkdir --bin=/usr/opt/bin
$ xmake
</code></pre>
<p><p class="tip"><br>Before v2.2.1 version, this parameter name is <code>--toolchains</code>, exists more ambiguous, so we changed to <code>--bin=</code> to set the bin directory.<br></p>

</p>
<h6 id="-cross">--cross</h6>
<ul>
<li>Set the prefix of compilation tools</li>
</ul>
<p>For example, under the same toolchains directory at the same time, there are two different compilers:</p>
<pre><code>/opt/bin
 - armv7-linux-gcc
 - aarch64-linux-gcc
</code></pre><p>If we want to use the <code>armv7-linux-gcc</code> compiler, we can run the following command:</p>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/usr/toolsdk --bin=/opt/bin --cross=armv7-linux-
</code></pre>
<h6 id="-as">--as</h6>
<ul>
<li>Set <code>asm</code> assembler</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --as=armv7-linux-as
</code></pre>
<p>If the &#39;AS&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p><p class="tip"><br>We can set a unknown compiler as like-gcc/clang compiler, .e.g <code>xmake f --as=gcc@/home/xxx/asmips.exe</code><br></p>

</p>
<h6 id="-cc">--cc</h6>
<ul>
<li>Set c compiler</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --cc=armv7-linux-clang
</code></pre>
<p>If the &#39;CC&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p><p class="tip"><br>We can set a unknown compiler as like-gcc/clang compiler, .e.g <code>xmake f --cc=gcc@/home/xxx/ccmips.exe</code><br></p>

</p>
<h6 id="-cxx">--cxx</h6>
<ul>
<li>Set <code>c++</code> compiler</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --cxx=armv7-linux-clang++
</code></pre>
<p>If the &#39;CXX&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p><p class="tip"><br>We can set a unknown compiler as like-gcc/clang compiler, .e.g <code>xmake f --cxx=g++@/home/xxx/c++mips.exe</code><br></p>

</p>
<h6 id="-ld">--ld</h6>
<ul>
<li>Set <code>c/c++/objc/asm</code> linker</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --ld=armv7-linux-clang++
</code></pre>
<p>If the &#39;LD&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p><p class="tip"><br>We can set a unknown compiler as like-gcc/clang linker, .e.g <code>xmake f --ld=g++@/home/xxx/c++mips.exe</code><br></p>

</p>
<h6 id="-sh">--sh</h6>
<ul>
<li>Set <code>c/c++/objc/asm</code> shared library linker</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --sh=armv7-linux-clang++
</code></pre>
<p>If the &#39;SH&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p><p class="tip"><br>We can set a unknown compiler as like-gcc/clang linker, .e.g <code>xmake f --sh=g++@/home/xxx/c++mips.exe</code><br></p>

</p>
<h6 id="-ar">--ar</h6>
<ul>
<li>Set <code>c/c++/objc/asm</code> static library archiver</li>
</ul>
<pre><code class="lang-bash">$ xmake f -p linux --sdk=/user/toolsdk --ar=armv7-linux-ar
</code></pre>
<p>If the &#39;AR&#39; environment variable exists, it will use the values specified in the current environment variables.</p>
<p><p class="tip"><br>We can set a unknown compiler as like-ar archiver, .e.g <code>xmake f --ar=ar@/home/xxx/armips.exe</code><br></p>

</p>
<h4 id="global-configuration">Global Configuration</h4>
<p>You can save to the global configuration for simplfying operation.</p>
<p>For example:</p>
<pre><code class="lang-bash">$ xmake g --ndk=~/files/android-ndk-r10e/
</code></pre>
<p>Now, we config and build project for android again.</p>
<pre><code class="lang-bash">$ xmake f -p android
$ xmake
</code></pre>
<p><p class="tip"><br>    You can use short or long command option, for exmaple: <code>xmake g</code> or <code>xmake global</code>.<br><br></p>

</p>
<h4 id="clean-configuration">Clean Configuration</h4>
<p>We can clean all cached configuration and re-configure projecct.</p>
<pre><code class="lang-bash">$ xmake f -c
$ xmake
</code></pre>
<p>or </p>
<pre><code class="lang-bash">$ xmake f -p iphoneos -c
$ xmake
</code></pre>
<h2 id="syntax-description">Syntax Description</h2>
<p>xmake&#39;s project description file xmake.lua is based on the lua syntax, but in order to make the project build logic more convenient and concise, xmake encapsulates it, making writing xmake.lua not as cumbersome as some makefiles.</p>
<p>Basically write a simple project build description, just three lines, for example:</p>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<h4 id="scope">Scope</h4>
<p>The description syntax of xmake is divided by scope, which is mainly divided into:</p>
<ul>
<li>external scope</li>
<li>Internal scope</li>
<li>Interface scope</li>
</ul>
<p>Which ones belong to the outside and which ones belong to the inside? if you look at the comments below, you know what it is:</p>
<pre><code class="lang-lua">-- external scope
target("test")

    -- external scope
    set_kind("binary")
    add_files("src/*.c")

    on_run(function ()
        -- Internal scope
        end)

    after_package(function ()
        -- Internal scope
        end)

-- external scope
task("hello")

    -- external scope
    on_run(function ()
        -- Internal scope
        end)
</code></pre>
<p>Simply put, all within the custom script <code>function () end</code> belongs to the internal scope, which is the script scope, and all other places belong to the external scope. .</p>
<h5 id="external-scope">external Scope</h5>
<p>For most projects, you don&#39;t need complicated engineering descriptions, and you don&#39;t need custom scripting support. You just need a simple <code>set_xxx</code> or <code>add_xxx</code> to meet your needs.</p>
<p>Then according to the 28th law, 80% of the cases, we only need to write:</p>
<pre><code class="lang-lua">target("test")
    set_kind("static")
    add_files("src/test/*.c")

target("demo")
    add_deps("test")
    set_kind("binary")
    add_links("test")
    add_files("src/demo/*.c")
</code></pre>
<p>No complicated api calls, no complicated variable definitions, and if judgments and for loops. It&#39;s succinct and readable. At a glance, it doesn&#39;t matter if you don&#39;t understand lua grammar.</p>
<p>As a simple description of the syntax, it looks a bit like a function call, you will know how to configure it at a basic point of programming.</p>
<p>In order to be concise and secure, in this scope, many lua built-in apis are not open, especially related to writing files and modifying the operating environment, only providing some basic read-only interfaces, and logical operations.</p>
<p>The current external scope lating lua built-in apis are:</p>
<ul>
<li>table</li>
<li>string</li>
<li>pairs</li>
<li>ipairs</li>
<li>print</li>
<li>os</li>
</ul>
<p>Of course, although the built-in lua api does not provide much, xmake also provides a lot of extension APIs. It is not much to describe the api. For details, please refer to: [API Manual] (<a href="https://xmake.io/#/zh/manual">https://xmake.io/#/zh/manual</a>)</p>
<p>There are also some auxiliary apis, for example:</p>
<ul>
<li>dirs: scan to get all the directories in the currently specified path</li>
<li>files: scan to get all the files in the current specified path</li>
<li>format: format string, short version of string.format</li>
</ul>
<p>There are also variable definitions and logical operations that can be used. after all, it is based on lua. The basic syntax is still there. We can switch the compiled files by if:</p>
<pre><code class="lang-lua">target("test")
    set_kind("static")
    if is_plat("iphoneos") then
        add_files("src/test/ios/*.c")
    else
        add_files("src/test/*.c")
    end
</code></pre>
<p>It should be noted that the variable definition is divided into global variables and local variables. The local variables are only valid for the current xmake.lua, and do not affect the child xmake.lua.</p>
<pre><code class="lang-lua">-- local variables, only valid for current xmake.lua
local var1 = 0

-- global variables that affect all subsmake.lua included after includes()
var2 = 1

Includes("src")
</code></pre>
<h5 id="internal-scope">Internal Scope</h5>
<p>Also known as plug-ins, script scope, provide more complex and flexible script support, generally used to write some custom scripts, plug-in development, custom task tasks, custom modules, etc.</p>
<p>Usually included by <code>function () end</code>, and passed to the <code>on_xxx</code>, <code>before_xxx</code> and <code>after_xxx</code> interfaces, are all self-scoped.</p>
<p>E.g:</p>
<pre><code class="lang-lua">-- custom script
target("hello")
    after_build(function ()
        -- Internal scope
        end)

-- custom tasks, plugins
task("hello")
    on_run(function ()
        -- Internal scope
        end)
</code></pre>
<p>In this scope, not only can you use most lua apis, but you can also use many extension modules provided by xmake. All extension modules are imported through import.</p>
<p>For details, please refer to: <a href="https://xmake.io/#/zh/manual?id=import">import module document</a></p>
<p>Here we give a simple example, after the compilation is complete, ldid signature on the ios target program:</p>
<pre><code class="lang-lua">target("iosdemo")
    set_kind("binary")
    add_files("*.m")
    after_build(function (target)

        -- Execute signature, if it fails, automatically interrupt, giving a highlight error message
        Os.run("ldid -S$(projectdir)/entitlements.plist %s", target:targetfile())
    end)
</code></pre>
<p>It should be noted that in the internal scope, all calls are enabled with the exception catching mechanism. if the operation is wrong, xmake will be automatically interrupted and an error message will be given.</p>
<p>Therefore, the script is written without the cumbersome <code>if retval then</code> judgment, and the script logic is more clear.</p>
<h5 id="interface-scope">Interface Scope</h5>
<p>All descriptions of api settings in the external scope are also scoped. They are called in different places and have different scopes of influence, for example:</p>
<pre><code class="lang-lua">-- global root scope, affecting all targets, including subproject target settings in includes()
add_defines("DEBUG")

-- define or enter the demo target scope (support multiple entry to append settings)
target("demo")
    set_kind("shared")
    add_files("src/*.c")
    -- the current target scope only affects the current target
    add_defines("DEBUG2")

-- option settings, only local settings are supported, not affected by global api settings
option("test")
    -- local scope of the current option
    set_default(false)

-- other target settings, -DDEBUG will also be set
target("demo2")
    set_kind("binary")
    add_files("src/*.c")

-- re-enter the demo target scope
target("demo")
    -- append macro definitions, only valid for the current demo target
    add_defines("DEBUG3")
</code></pre>
<p>Normally, entering another target/option domain setting will automatically leave the previous target/option field, but sometimes in order to compare some scope pollution, we can show off a domain, for example:</p>
<pre><code class="lang-lua">option("test")
    set_default(false)
option_end()

target("demo")
    set_kind("binary")
    add_files("src/*.c")
target_end()
</code></pre>
<p>Call <code>option_end()</code>, <code>target_end()</code> to explicitly leave the current target/option field setting.</p>
<h5 id="scope-indentation">Scope indentation</h5>
<p>Indentation in xmake.lua is just a specification for more clear distinction. The current setting is for that scope, although it is ok even if it is not indented, but it is not very readable. .</p>
<p>e.g:</p>
<pre><code class="lang-lua">target("xxxx")
    set_kind("binary")
    add_files("*.c")
</code></pre>
<p>with</p>
<pre><code class="lang-lua">target("xxxx")
set_kind("binary")
add_files("*.c")
</code></pre>
<p>The above two methods are the same in effect, but in understanding, the first one is more intuitive. At first glance, you know that <code>add_files</code> is only set for target, not global.</p>
<p>Therefore, proper indentation helps to better maintain xmake.lua</p>
<p>Finally attached, tbox&#39;s <a href="https://github.com/tboox/tbox/blob/master/src/tbox/xmake.lua">xmake.lua</a> description, for reference only. .</p>
<h4 id="syntax-simplification">Syntax simplification</h4>
<p>The configuration field syntax of xmake.lua is very flexible and can be used in a variety of complex and flexible configurations in the relevant domain, but for many streamlined small block configurations, this time is slightly redundant:</p>
<pre><code class="lang-lua">option("test1")
    set_default(true)
    set_showmenu(true)
    set_description("test1 option")

option("test2")
    set_default(true)
    set_showmeu(true)

option("test3")
    set_default("hello")
</code></pre>
<p>xmake 2.2.6 or later, for the above small block option domain settings, we can simplify the description into a single line:</p>
<pre><code class="lang-lua">option("test1", {default = true, showmenu = true, description = "test1 option"})
option("test2", {default = true, showmenu = true})
option("test3", {default = "hello"})
</code></pre>
<p>In addition to the option field, this simplified writing is also supported for other domains, such as:</p>
<pre><code class="lang-lua">target("demo")
    set_kind("binary")
    add_files("src/*.c")
</code></pre>
<p>Simplified to:</p>
<pre><code class="lang-lua">target("demo", {kind = "binary", files = "src/*.c"})
</code></pre>
<p>Of course, if the configuration requirements are more complicated, or the original multi-line setting method is more convenient, this depends on your own needs to evaluate which method is used.</p>
<h2 id="dependency-package-management">Dependency Package Management</h2>
<h4 id="local-package-mode">Local Package Mode</h4>
<p>By including a dependency package directory and a binary package file in the project, it is convenient to integrate some third-party dependency libraries. This method is relatively simple and straightforward, but the disadvantages are also obvious and inconvenient to manage.</p>
<p>Take the tbox project as an example. The dependency package is as follows:</p>
<pre><code>- base.pkg
- zlib.pkg
- polarssl.pkg
- openssl.pkg
- mysql.pkg
- pcre.pkg
- ...
</code></pre><p>If you want the current project to recognize loading these packages, you first need to specify the package directory path, for example:</p>
<pre><code class="lang-lua">add_packagedirs("packages")
</code></pre>
<p>Once specified, you can add integration package dependencies in the target scope via the <a href="https://xmake.io/#/zh/manual?id=targetadd_packages">add_packages</a> interface, for example:</p>
<pre><code class="lang-lua">target("tbox")
    add_packages("zlib", "polarssl", "pcre", "mysql")
</code></pre>
<p>So how to generate a *.pkg package, if it is based on xmake project, the generation method is very simple, only need:</p>
<pre><code class="lang-console">$ cd tbox
$ xmake package
</code></pre>
<p>You can generate a tbox.pkg cross-platform package in the build directory for use by third-party projects. I can also directly set the output directory and compile and generate it into the other project, for example:</p>
<pre><code class="lang-console">$ cd tbox
$ xmake package -o ../test/packages
</code></pre>
<p>In this way, the test project can pass <a href="https://xmake.io/#/zh/manual?id=targetadd_packages">add_packages</a> and <a href="https://xmake.io/#/zh/manual?id= add_packagedirs">add_packagedirs</a> to configure and use the tbox.pkg package.</p>
<p>For a detailed description of the built-in package, you can also refer to the following related article, which is described in detail: <a href="https://tboox.org/cn/2016/08/06/add-package-and-autocheck/">Dependency package addition and automatic detection mechanism</a></p>
<h4 id="system-search-mode">System Search Mode</h4>
<p>If you feel that the above built-in package management method is very inconvenient, you can use the extension interface [lib.detect.find_package] provided by xmake (<a href="https://xmake.io/#/zh/manual?id=detect-find_package">https://xmake.io/#/zh/manual?id=detect-find_package</a>) to find the system. Existing dependencies.</p>
<p>Currently this interface supports the following package management support:</p>
<ul>
<li>vcpkg</li>
<li>homebrew</li>
<li>pkg-config</li>
</ul>
<p>And through the system and third-party package management tools for the installation of the dependency package, and then integrated with xmake, for example, we look for an openssl package:</p>
<pre><code class="lang-lua">local packages = find_packages("openssl", "zlib")
</code></pre>
<p>The returned results are as follows:</p>
<pre><code class="lang-lua">{
    {links = {"ssl", "crypto"}, linkdirs = {"/usr/local/lib"}, includedirs = {"/usr/local/include"}},
    {links = {"z"}, linkdirs = {"/usr/local/lib"}, includedirs = {"/usr/local/include"}}
}
</code></pre>
<p>If the search is successful, return a table containing all the package information, if it fails, return nil</p>
<p>The return result here can be directly passed as the parameter of <code>target:add</code>, <code>option:add</code>, which is used to dynamically increase the configuration of <code>target/option</code>:</p>
<pre><code class="lang-lua">option("zlib")
    set_showmenu(true)
    before_check(function (option)
        option:add(find_packages("openssl", "zlib"))
    end)
</code></pre>
<pre><code class="lang-lua">target("test")
    on_load(function (target)
        target:add(find_packages("openssl", "zlib"))
    end)
</code></pre>
<p>If third-party tools such as <code>homebrew</code>, <code>pkg-config</code> are installed on the system, then this interface will try to use them to improve the search results.</p>
<p>For a more complete description of the usage, please refer to the <a href="https://xmake.io/#/en/manual?id=find_packages">find_packages</a> interface documentation.</p>
<h5 id="homebrew-integration-support">Homebrew Integration Support</h5>
<p>Since homebrew is generally installed directly into the system, users do not need to do any integration work, <code>lib.detect.find_package</code> has been natively seamlessly supported.</p>
<h5 id="vcpkg-integration-support">Vcpkg Integration Support</h5>
<p>Currently xmake v2.2.2 version already supports vcpkg, users only need to install vcpkg, execute <code>$ vcpkg integrate install</code>, xmake will automatically detect the root path of vcpkg from the system, and then automatically adapt the bread.</p>
<p>Of course, we can also manually specify the root path of vcpkg to support:</p>
<pre><code class="lang-console">$ xmake f --vcpkg=f:\vcpkg
</code></pre>
<p>Or we can set it to the global configuration to avoid repeating the settings each time we switch configurations:</p>
<pre><code class="lang-console">$ xmake g --vcpkg=f:\vcpkg
</code></pre>
<h4 id="remote-dependency-mode">Remote dependency mode</h4>
<p>This has been initially supported after the 2.2.2 version, the usage is much simpler, just set the corresponding dependency package, for example:</p>
<pre><code class="lang-lua">add_requires("tbox 1.6.*", "libpng ~1.16", "zlib")

target("test")
    set_kind("binary")
    add_files("src/*.c")
    add_packages("tbox", "libpng", "zlib")
</code></pre>
<p>The above <code>add_requires</code> is used to describe the dependencies required by the current project, and <code>add_packages</code> is used to apply dependencies to the test target. Only settings will automatically add links, linkdirs, includedirs, etc.</p>
<p>Then directly compile:</p>
<pre><code class="lang-console">$ xmake
</code></pre>
<p>xmake will remotely pull the relevant source package, then automatically compile and install, finally compile the project, and link the dependency package. The specific effect is shown in the following figure:</p>
<p><img src="/assets/img/index/package_manage.png" width="80%" /></p>
<p>For more information and progress on package dependency management see the related issues: <a href="https://github.com/xmake-io/xmake/issues/69">Remote package management</a></p>
<h5 id="currently-supported-features">Currently Supported Features</h5>
<ul>
<li>Semantic version support, for example: ">= 1.1.0 < 1.2", "~1.6", "1.2.x", "1.*"</li>
<li>Provide multi-warehouse management support such as official package warehouse, self-built private warehouse, project built-in warehouse, etc.</li>
<li>Cross-platform package compilation integration support (packages of different platforms and different architectures can be installed at the same time, fast switching use)</li>
<li>Debug dependency package support, source code debugging</li>
</ul>
<h5 id="dependency-package-processing-mechanism">Dependency Package Processing Mechanism</h5>
<p>Here we briefly introduce the processing mechanism of the entire dependency package:</p>
<p><div align="center"><br><img src="/assets/img/index/package_arch.png" width="80%" /><br></div>

</p>
<ol>
<li>Priority check for the current system directory, whether there is a specified package under the third-party package management, if there is a matching package, then you do not need to download and install (of course you can also set the system package)</li>
<li>Retrieve the package matching the corresponding version, then download, compile, and install (Note: installed in a specific xmake directory, will not interfere with the system library environment)</li>
<li>Compile the project, and finally automatically link the enabled dependencies</li>
</ol>
<h5 id="semantic-version-settings">Semantic Version Settings</h5>
<p>Xmake&#39;s dependency package management fully supports semantic version selection, for example: "~1.6.1". For a detailed description of the semantic version, see: <a href="https://semver.org/">https://semver.org/</a></p>
<p>Some semantic versions are written:</p>
<pre><code class="lang-lua">add_requires("tbox 1.6.*", "pcre 1.3.x", "libpng ^1.18")
add_requires("libpng ~1.16", "zlib 1.1.2 || >=1.2.11 <1.3.0")
</code></pre>
<p>The semantic version parser currently used by xmake is the <a href="https://github.com/uael/sv">sv</a> library contributed by <a href="https://github.com/uael">uael</a>, which also has a description of the version. For detailed instructions, please refer to the following: <a href="https://github.com/uael/sv#versions">Version Description</a></p>
<p>Of course, if we have no special requirements for the current version of the dependency package, then we can write directly:</p>
<pre><code class="lang-lua">add_requires("tbox", "libpng", "zlib")
</code></pre>
<p>This will use the latest version of the package known, or the source code compiled by the master branch. If the current package has a git repo address, we can also specify a specific branch version:</p>
<pre><code class="lang-lua">add_requires("tbox master")
add_requires("tbox dev")
</code></pre>
<h5 id="extra-package-information-settings">Extra Package Information Settings</h5>
<h6 id="optional-package-settings">Optional Package Settings</h6>
<p>If the specified dependency package is not supported by the current platform, or if the compilation and installation fails, then xmake will compile the error, which is reasonable for some projects that must rely on certain packages to work.<br>However, if some packages are optional dependencies, they can be set to optional packages even if they are not compiled properly.</p>
<pre><code class="lang-lua">add_requires("tbox", {optional = true})
</code></pre>
<h6 id="disable-system-library">Disable System Library</h6>
<p>With the default settings, xmake will first check to see if the system library exists (if no version is required). If the user does not want to use the system library and the library provided by the third-party package management, then you can set:</p>
<pre><code class="lang-lua">add_requires("tbox", {system = false})
</code></pre>
<h6 id="using-the-debug-version-of-the-package">Using the debug version of the package</h6>
<p>If we want to debug the dependencies at the same time, we can set them to use the debug version of the package (provided that this package supports debug compilation):</p>
<pre><code class="lang-lua">add_requires("tbox", {debug = true})
</code></pre>
<p>If the current package does not support debug compilation, you can submit the modified compilation rules in the repository to support the debug, for example:</p>
<pre><code class="lang-lua">package("openssl")
    on_install("linux", "macosx", function (package)
        os.vrun("./config %s --prefix=\"%s\"", package:debug() and "--debug" or "", package:installdir())
        os.vrun("make -j4")
        os.vrun("make install")
    end)
</code></pre>
<h6 id="passing-additional-compilation-information-to-the-package">Passing additional compilation information to the package</h6>
<p>Some packages have various compile options at compile time, and we can pass them in. Of course, the package itself supports:</p>
<pre><code class="lang-lua">add_requires("tbox", {configs = {small=true}})
</code></pre>
<p>Pass <code>--small=true</code> to the tbox package so that compiling the installed tbox package is enabled.</p>
<h5 id="install-third-party-packages">Install third-party packages</h5>
<p>After version 2.2.5, xmake supports support for dependency libraries in third-party package managers, such as: conan, brew, vcpkg, etc.</p>
<p>Add a homebrew dependency package:</p>
<pre><code class="lang-lua">add_requires("brew::zlib", {alias = "zlib"}})
add_requires("brew::pcre2/libpcre2-8", {alias = "pcre2"}})

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("pcre2", "zlib")
</code></pre>
<p>Add a dependency package for vcpkg:</p>
<pre><code class="lang-lua">add_requires("vcpkg::zlib", "vcpkg::pcre2")

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("vcpkg::zlib", "vcpkg::pcre2")
</code></pre>
<p>Add a conan dependency package:</p>
<pre><code class="lang-lua">add_requires("CONAN::zlib/1.2.11@conan/stable", {alias = "zlib", debug = true})
add_requires("CONAN::OpenSSL/1.0.2n@conan/stable", {alias = "openssl", 
    configs = {options = "OpenSSL:shared=True"}})

target("test")
    set_kind("binary")
    add_files("src/*.c") 
    add_packages("openssl", "zlib")
</code></pre>
<p>After executing xmake to compile:</p>
<pre><code class="lang-console">ruki:test_package ruki$ xmake
checking for the architecture ... x86_64
checking for the Xcode directory ... /Applications/Xcode.app
checking for the SDK version of Xcode ... 10.14
note: try installing these packages (pass -y to skip confirm)?
  -> CONAN::zlib/1.2.11@conan/stable  (debug)
  -> CONAN::OpenSSL/1.0.2n@conan/stable  
please input: y (y/n)

  => installing CONAN::zlib/1.2.11@conan/stable .. ok
  => installing CONAN::OpenSSL/1.0.2n@conan/stable .. ok

[  0%]: ccache compiling.release src/main.c
[100%]: linking.release test
</code></pre>
<h5 id="using-self-built-private-package-warehouse">Using self-built private package warehouse</h5>
<p>If the required package is not in the official repository <a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a>, we can submit the contribution code to the repository for support.<br>But if some packages are only for personal or private projects, we can create a private repository repo. The repository organization structure can be found at: <a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a></p>
<p>For example, now we have a private repository repo:<a href="mailto:`git@github.com">`git@github.com</a>:myrepo/xmake-repo.git`</p>
<p>We can add the repository with the following command:</p>
<pre><code class="lang-console">$ xmake repo --add myrepo git@github.com:myrepo/xmake-repo.git
</code></pre>
<p>Starting with v2.2.3, support for adding repos for specified branches, for example:</p>
<pre><code class="lang-console">$ xmake repo --add myrepo git@github.com:myrepo/xmake-repo.git dev
</code></pre>
<p>Or we write directly in xmake.lua:</p>
<pre><code class="lang-lua">add_repositories("my-repo git@github.com:myrepo/xmake-repo.git")
</code></pre>
<p>If we just want to add one or two private packages, this time to build a git repo is too big, we can directly put the package repository into the project, for example:</p>
<pre><code>projectdir
  - myrepo
    - packages
      - t/tbox/xmake.lua
      - z/zlib/xmake.lua
  - src
    - main.c
  - xmake.lua
</code></pre><p>The above myrepo directory is your own private package repository, built into your own project, and then add this repository location in xmake.lua:</p>
<pre><code class="lang-lua">add_repositories("my-repo myrepo")
</code></pre>
<p>This can be referred to <a href="https://github.com/tboox/benchbox">benchbox</a> project, which has a built-in private repository.</p>
<p>We can even build a package without directly building a package description into the project xmake.lua, which is useful for relying on one or two packages, for example:</p>
<pre><code class="lang-lua">package("libjpeg")

    set_urls("http://www.ijg.org/files/jpegsrc.$(version).tar.gz")

    add_versions("v9c", "650250979303a649e21f87b5ccd02672af1ea6954b911342ea491f351ceb7122")

    on_install("windows", function (package)
        os.mv("jconfig.vc", "jconfig.h")
        os.vrun("nmake -f makefile.vc")
        os.cp("*.h", package:installdir("include"))
        os.cp("libjpeg.lib", package:installdir("lib"))
    end)

    on_install("macosx", "linux", function (package)
        import("package.tools.autoconf").install(package)
    end)

package_end()

add_requires("libjpeg")

target("test")
    set_kind("binary")
    add_files("src/*.c")
    add_packages("libjpeg")
</code></pre>
<h5 id="package-management-command-use">Package Management Command Use</h5>
<p>The package management command <code>$ xmake require</code> can be used to manually display the download, install, uninstall, retrieve, and view package information.</p>
<h6 id="install-the-specified-package">Install the specified package</h6>
<pre><code class="lang-console">$ xmake require tbox
</code></pre>
<p>Install the specified version package:</p>
<pre><code class="lang-console">$ xmake require tbox "~1.6"
</code></pre>
<p>Force a re-download of the installation and display detailed installation information:</p>
<pre><code class="lang-console">$ xmake require -f -v tbox "1.5.x"
</code></pre>
<p>Pass additional setup information:</p>
<pre><code class="lang-console">$ xmake require --extra="debug=true,config={small=true}" tbox
</code></pre>
<p>Install the debug package and pass the compilation configuration information of <code>small=true</code> to the package.</p>
<h6 id="uninstalling-the-specified-package">Uninstalling the specified package</h6>
<pre><code class="lang-console">$ xmake require --uninstall tbox
</code></pre>
<p>This will completely uninstall the removal package file.</p>
<h6 id="view-package-details">View package details</h6>
<pre><code class="lang-console">$ xmake require --info tbox
</code></pre>
<h6 id="search-for-packages-in-the-current-warehouse">Search for packages in the current warehouse</h6>
<pre><code class="lang-console">$ xmake require --search tbox
</code></pre>
<p>This is to support fuzzy search and lua pattern matching search:</p>
<pre><code class="lang-console">$ xmake require --search pcr
</code></pre>
<p>Will also search for pcre, pcre2 and other packages.</p>
<h6 id="list-the-currently-installed-packages">List the currently installed packages</h6>
<pre><code class="lang-console">$ xmake require --list
</code></pre>
<h5 id="warehouse-management-command-use">Warehouse Management Command Use</h5>
<p>As mentioned above, adding a private repository is available (supporting local path addition):</p>
<pre><code class="lang-console">$ xmake repo --add myrepo git@github.com:myrepo/xmake-repo.git
</code></pre>
<p>We can also remove a repository that has already been installed:</p>
<pre><code class="lang-console">$ xmake repo --remove myrepo
</code></pre>
<p>Or view all the added warehouses:</p>
<pre><code class="lang-console">$ xmake repo --list
</code></pre>
<p>If the remote repository has updates, you can manually perform a warehouse update to get more and the latest packages:</p>
<pre><code class="lang-console">$ xmake repo -u
</code></pre>
<h5 id="submit-the-package-to-the-official-warehouse">Submit the package to the official warehouse</h5>
<p>If you need a package that is not supported by the current official repository, you can commit it to the official repository after local tuning: <a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a></p>
<p>For detailed contribution descriptions, see: <a href="https://github.com/xmake-io/xmake-repo/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a></p>
<h2 id="faq">FAQ</h2>
<h4 id="how-to-get-verbose-command-line-arguments-info-">How to get verbose command-line arguments info?</h4>
<p>Get the help info of the main command.</p>
<pre><code class="lang-bash">$ xmake [-h|--help]
</code></pre>
<p>Get the help info of the configuration command.</p>
<pre><code class="lang-bash">$ xmake f [-h|--help]
</code></pre>
<p>Get the help info of the givent action or plugin command.</p>
<pre><code class="lang-bash">$ xmake [action|plugin] [-h|--help]
</code></pre>
<p>For example:</p>
<pre><code class="lang-bash">$ xmake run --help
</code></pre>
<h4 id="how-to-suppress-all-output-info-">How to suppress all output info?</h4>
<pre><code class="lang-bash">$ xmake [-q|--quiet]
</code></pre>
<h4 id="how-to-do-if-xmake-fails-">How to do if xmake fails?</h4>
<p>Please attempt to clean configuration and rebuild it first.</p>
<pre><code class="lang-bash">$ xmake f -c
$ xmake
</code></pre>
<p>If it fails again, please add <code>-v</code> or <code>--verbose</code> options to get more verbose info.</p>
<p>For exmaple: </p>
<pre><code class="lang-hash">$ xmake [-v|--verbose] 
</code></pre>
<p>And add <code>--backtrace</code> to get the verbose backtrace info, then you can submit these infos to <a href="https://github.com/xmake-io/xmake/issues">issues</a>.</p>
<pre><code class="lang-bash">$ xmake -v --backtrace
</code></pre>
<h4 id="how-to-see-verbose-compiling-warnings-">How to see verbose compiling warnings?</h4>
<pre><code class="lang-bash">$ xmake [-w|--warning] 
</code></pre>
<h4 id="how-to-scan-source-code-and-generate-xmake-lua-automaticlly">How to scan source code and generate xmake.lua automaticlly</h4>
<p>You only need run the following command:</p>
<pre><code class="lang-bash">$ xmake
</code></pre>
<p>xmake will scan all source code in current directory and build it automaticlly. </p>
<p>And we can run it directly.</p>
<pre><code class="lang-bash">$ xmake run
</code></pre>
<p>If we only want to generate xmake.lua file, we can run:</p>
<pre><code class="lang-bash">$ xmake f -y
</code></pre>
<p>If you want to known more information please see <a href="https://tboox.org/2017/01/07/build-without-makefile/">Scan source codes and build project without makefile</a></p>
</article>
</body>
</html>