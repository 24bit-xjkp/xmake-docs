<h2 id="-">接口规范</h2>
<h4 id="-">命名规范</h4>
<p>接口的命名，是有按照预定义的一些规范来命名的，这样更加方便理解和易于使用，目前命名按照如下一些规则：</p>
<table>
<thead>
<tr>
<th>接口规则</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_</code>, <code>has_</code>前缀的接口</td>
<td>表示为条件判断</td>
</tr>
<tr>
<td><code>set_</code>前缀的接口</td>
<td>表示为覆盖设置</td>
</tr>
<tr>
<td><code>add_</code>前缀的接口</td>
<td>表示为追加设置</td>
</tr>
<tr>
<td><code>s</code>后缀的接口</td>
<td>表示支持多值传入，例如：<code>add_files(&quot;*.c&quot;, &quot;test.cpp&quot;)</code></td>
</tr>
<tr>
<td><code>on_</code>前缀的接口</td>
<td>表示为覆盖内置脚本</td>
</tr>
<tr>
<td><code>before_</code>前缀的接口</td>
<td>表示为在内置脚本运行前，执行此脚本</td>
</tr>
<tr>
<td><code>after_</code>前缀的接口</td>
<td>表示为在内置脚本运行后，执行此脚本</td>
</tr>
<tr>
<td><code>scope(&quot;name&quot;)</code>的接口</td>
<td>表示为定义一个描述域，例如：<code>target(&quot;xxx&quot;)</code>, <code>option(&quot;xxx&quot;)</code></td>
</tr>
<tr>
<td>描述域/描述设置</td>
<td>建议缩进表示</td>
</tr>
</tbody>
</table>
<h2 id="-">接口文档</h2>
<h4 id="-">条件判断</h4>
<p>条件判断的api，一般用于必须要处理特定平台的编译逻辑的场合。。通常跟lua的if语句配合使用。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#is_os">is_os</a></td>
<td>判断当前构建目标的操作系统</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#is_arch">is_arch</a></td>
<td>判断当前编译架构</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#is_plat">is_plat</a></td>
<td>判断当前编译平台</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#is_host">is_host</a></td>
<td>判断当前主机环境操作系统</td>
<td>&gt;= 2.1.4</td>
</tr>
<tr>
<td><a href="#is_mode">is_mode</a></td>
<td>判断当前编译模式</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#is_kind">is_kind</a></td>
<td>判断当前编译类型</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#is_option">is_option</a></td>
<td>判断选项是否启用</td>
<td>&gt;= 2.0.1 &lt; 2.2.2 已废弃</td>
</tr>
<tr>
<td><a href="#is_config">is_config</a></td>
<td>判断指定配置是否为给定的值</td>
<td>&gt;= 2.2.2</td>
</tr>
<tr>
<td><a href="#has_config">has_config</a></td>
<td>判断配置是否启用或者存在</td>
<td>&gt;= 2.2.2</td>
</tr>
<tr>
<td><a href="#has_package">has_package</a></td>
<td>判断依赖包是否被启用或者存在</td>
<td>&gt;= 2.2.3</td>
</tr>
</tbody>
</table>
<h5 id="is_os">is_os</h5>
<h6 id="-">判断当前构建目标的操作系统</h6>
<pre><code class="lang-lua">-- 如果当前操作系统是ios
if is_os(&quot;ios&quot;) then
    add_files(&quot;src/xxx/*.m&quot;)
end
</code></pre>
<p>目前支持的操作系统有：</p>
<ul>
<li>windows</li>
<li>linux</li>
<li>android</li>
<li>macosx</li>
<li>ios</li>
</ul>
<h5 id="is_arch">is_arch</h5>
<h6 id="-">判断当前编译架构</h6>
<p>用于检测编译配置：<code>xmake f -a armv7</code></p>
<pre><code class="lang-lua">-- 如果当前架构是x86_64或者i386
if is_arch(&quot;x86_64&quot;, &quot;i386&quot;) then
    add_files(&quot;src/xxx/*.c&quot;)
end

-- 如果当前平台是armv7, arm64, armv7s, armv7-a
if is_arch(&quot;armv7&quot;, &quot;arm64&quot;, &quot;armv7s&quot;, &quot;armv7-a&quot;) then
    -- ...
end
</code></pre>
<p>如果像上面那样一个个去判断所有arm架构，也许会很繁琐，毕竟每个平台的架构类型很多，xmake提供了类似<a href="#targetadd_files">add_files</a>中的通配符匹配模式，来更加简洁的进行判断：</p>
<pre><code class="lang-lua">--如果当前平台是arm平台
if is_arch(&quot;arm*&quot;) then
    -- ...
end
</code></pre>
<p>用<code>*</code>就可以匹配所有了。。</p>
<h5 id="is_plat">is_plat</h5>
<h6 id="-">判断当前编译平台</h6>
<p>用于检测编译配置：<code>xmake f -p iphoneos</code></p>
<pre><code class="lang-lua">-- 如果当前平台是android
if is_plat(&quot;android&quot;) then
    add_files(&quot;src/xxx/*.c&quot;)
end

-- 如果当前平台是macosx或者iphoneos
if is_plat(&quot;macosx&quot;, &quot;iphoneos&quot;) then
    add_frameworks(&quot;Foundation&quot;)
end
</code></pre>
<p>目前支持的平台有：</p>
<ul>
<li>windows</li>
<li>cross</li>
<li>linux</li>
<li>macosx</li>
<li>android</li>
<li>iphoneos</li>
<li>watchos</li>
</ul>
<p>当然你也可以自己扩展添加自己的平台，甚至直接指定自己的平台名：</p>
<pre><code class="lang-bash">$ xmake f -p other --sdk=...
</code></pre>
<p>如果指定的平台名不存在，就会自动切到<code>cross</code>平台进行交叉编译，但是缺可以通过<code>is_plat(&quot;other&quot;)</code>来判断自己的平台逻辑。</p>
<h5 id="is_host">is_host</h5>
<h6 id="-">判断当前主机环境的操作系统</h6>
<p>有些编译平台是可以在多个不同的操作系统进行构建的，例如：android的ndk就支持linux,macOS还有windows环境。</p>
<p>这个时候就可以通过这个接口，区分当前是在哪个系统环境下进行的构建。</p>
<pre><code class="lang-lua">-- 如果当前主机环境是windows
if is_host(&quot;windows&quot;) then
    add_includedirs(&quot;C:\\includes&quot;)
else
    add_includedirs(&quot;/usr/includess&quot;)
end
</code></pre>
<p>目前支持的主机环境有：</p>
<ul>
<li>windows</li>
<li>linux</li>
<li>macosx</li>
</ul>
<p>你也可以通过<a href="#var-host">$(host)</a>内置变量或者<a href="#os-host">os.host</a>接口，来进行获取</p>
<h5 id="is_mode">is_mode</h5>
<h6 id="-">判断当前编译模式</h6>
<p>用于检测编译配置：<code>xmake f -m debug</code></p>
<p>编译模式的类型并不是内置的，可以自由指定，一般指定：<code>debug</code>, <code>release</code>, <code>profile</code> 这些就够用了，当然你也可以在xmake.lua使用其他模式名来判断。</p>
<pre><code class="lang-lua">-- 如果当前编译模式是debug
if is_mode(&quot;debug&quot;) then

    -- 添加DEBUG编译宏
    add_defines(&quot;DEBUG&quot;)

    -- 启用调试符号
    set_symbols(&quot;debug&quot;)

    -- 禁用优化
    set_optimize(&quot;none&quot;)

end

-- 如果是release或者profile模式
if is_mode(&quot;release&quot;, &quot;profile&quot;) then

    -- 如果是release模式
    if is_mode(&quot;release&quot;) then

        -- 隐藏符号
        set_symbols(&quot;hidden&quot;)

        -- strip所有符号
        set_strip(&quot;all&quot;)

        -- 忽略帧指针
        add_cxflags(&quot;-fomit-frame-pointer&quot;)
        add_mxflags(&quot;-fomit-frame-pointer&quot;)

    -- 如果是profile模式
    else

        -- 启用调试符号
        set_symbols(&quot;debug&quot;)

    end

    -- 添加扩展指令集
    add_vectorexts(&quot;sse2&quot;, &quot;sse3&quot;, &quot;ssse3&quot;, &quot;mmx&quot;)
end
</code></pre>
<h5 id="is_kind">is_kind</h5>
<h6 id="-">判断当前编译类型</h6>
<p>判断当前是否编译的是动态库还是静态库，用于检测编译配置：<code>xmake f -k [static|shared]</code></p>
<p>一般用于如下场景：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 通过配置设置目标的kind
    set_kind(&quot;$(kind)&quot;)
    add_files(&quot;src/*c&quot;)

    -- 如果当前编译的是静态库，那么添加指定文件
    if is_kind(&quot;static&quot;) then
        add_files(&quot;src/xxx.c&quot;)
    end
</code></pre>
<p>编译配置的时候，可手动切换，编译类型：</p>
<pre><code class="lang-bash"># 编译静态库
$ xmake f -k static
$ xmake
</code></pre>
<pre><code class="lang-bash"># 编译动态库
$ xmake f -k shared
$ xmake
</code></pre>
<h5 id="is_option">is_option</h5>
<h6 id="-">判断选项是否启用</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>此接口在2.2.2版本之后已经弃用，请使用<a href="#has_config">has_config</a>来代替。<br>&lt;/p&gt;

</p>
<p>用于检测自定义的编译配置选型：<code>xmake f --xxxx=y</code></p>
<p>如果某个自动检测选项、手动设置选项被启用，那么可以通过<code>is_option</code>接口来判断，例如：</p>
<pre><code class="lang-lua">-- 如果手动启用了xmake f --demo=y 选项
if is_option(&quot;demo&quot;) then

    -- 编译demo目录下的代码
    add_subdirs(&quot;src/demo&quot;)
end
</code></pre>
<h5 id="is_config">is_config</h5>
<h6 id="-">判断指定配置是否为给定的值</h6>
<p>此接口从2.2.2版本开始引入，用于判断指定配置是否为给定的值，可用于描述域。</p>
<p>例如：</p>
<pre><code class="lang-console">$ xmake f --test=hello1
</code></pre>
<pre><code class="lang-lua">-- 自定义一个配置选项到命令行菜单
option(&quot;test&quot;)
    set_showmenu(&quot;true&quot;)
    set_description(&quot;The test config option&quot;)
option_end()

-- 如果自定义的test配置值是hello1或者hello2
if is_config(&quot;test&quot;, &quot;hello1&quot;, &quot;hello2&quot;) then
    add_defines(&quot;HELLO&quot;)
end
</code></pre>
<p>不仅如此，我们还可以设置模式匹配规则去判断值，例如：</p>
<pre><code class="lang-lua">-- 如果自定义的test配置值带有hello前缀
if is_config(&quot;test&quot;, &quot;hello.*&quot;) then
    add_defines(&quot;HELLO&quot;)
end
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>此接口不仅能够判断通过<a href="#option">option</a>定义的自定义配置选项，同时还能判断内置的全局配置、本地配置。<br>&lt;/p&gt;

</p>
<h5 id="has_config">has_config</h5>
<h6 id="-">判断配置是否启用或者存在</h6>
<p>此接口从2.2.2版本开始引入，用于检测自定义或者内置的编译配置是否存在或启用，可用于描述域。</p>
<p>例如以下配置情况，都会返回true:</p>
<pre><code class="lang-console"># 启用某个配置选项（如果是boolean类型配置）
$ xmake f --test1=y
$ xmake f --test1=yes
$ xmake f --test1=true

# 设置某个配置选项的值
$ xmake f --test2=value
</code></pre>
<pre><code class="lang-lua">-- 如果test1或者test2被设置或者启用
if has_config(&quot;test1&quot;, &quot;test2&quot;) then
    add_defines(&quot;TEST&quot;)
end
</code></pre>
<p>而下面的情况则会禁用配置，返回false：</p>
<pre><code class="lang-console"># 禁用配置（如果是boolean类型配置）
$ xmake f --test1=n
$ xmake f --test1=no
$ xmake f --test1=false
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>此接口不仅能够判断内置的全局配置、本地配置，同时还可以判断通过<a href="#option">option</a>定义的自定义配置选项。<br>&lt;/p&gt;


</p>
<h5 id="has_package">has_package</h5>
<h6 id="-">判断依赖包是否启用或者存在</h6>
<p>此接口从2.2.3版本开始引入，用于检测远程依赖包是否存在或启用，可用于描述域。</p>
<p>一般配合<a href="#add_requires">add_requires</a>一起使用，例如：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox&quot;, {optional = true})

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_packages(&quot;tbox&quot;)

    if has_package(&quot;tbox&quot;) then
        add_defines(&quot;HAVE_TBOX&quot;)
    end
</code></pre>
<p>如果通过<code>add_requires</code>添加的可选依赖包，远程下载安装失败，或者当前平台不支持导致实际上没有被正常安装上，那么<code>has_package</code>就会返回false，<br>表示不存在，然后对其他flags定义甚至源文件编译控制做一些特殊处理。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>此接口跟<a href="#has_config">has_config</a>的区别在于，<a href="#has_config">has_config</a>用于<a href="#option">option</a>，而它用于<a href="#add_requires">add_requires</a>。<br>&lt;/p&gt;

</p>
<h4 id="-">全局接口</h4>
<p>全局接口影响整个工程描述，被调用后，后面被包含进来的所有子<code>xmake.lua</code>都会受影响。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#includes">includes</a></td>
<td>添加子工程文件和目录</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#set_modes">set_modes</a></td>
<td>设置支持的编译模式</td>
<td>&gt;= 2.1.2</td>
</tr>
<tr>
<td><a href="#set_project">set_project</a></td>
<td>设置工程名</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#set_version">set_version</a></td>
<td>设置工程版本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#set_xmakever">set_xmakever</a></td>
<td>设置最小xmake版本</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#add_subdirs">add_subdirs</a></td>
<td>添加子工程目录</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#add_subfiles">add_subfiles</a></td>
<td>添加子工程文件</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#add_moduledirs">add_moduledirs</a></td>
<td>添加模块目录</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#add_plugindirs">add_plugindirs</a></td>
<td>添加插件目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#add_packagedirs">add_packagedirs</a></td>
<td>添加包目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#get_config">get_config</a></td>
<td>获取给的配置值</td>
<td>&gt;= 2.2.2</td>
</tr>
<tr>
<td><a href="#set_config">set_config</a></td>
<td>设置默认的配置值</td>
<td>&gt;= 2.2.2</td>
</tr>
<tr>
<td><a href="#add_requires">add_requires</a></td>
<td>添加需要的依赖包</td>
<td>&gt;= 2.2.2</td>
</tr>
<tr>
<td><a href="#add_repositories">add_repositories</a></td>
<td>添加依赖包仓库</td>
<td>&gt;= 2.2.2</td>
</tr>
</tbody>
</table>
<h5 id="includes">includes</h5>
<h6 id="-">添加子工程文件和目录</h6>
<p>同时支持子工程文件和目录的添加，用于替代<a href="#add_subdirs">add_subdirs</a>和<a href="#add_subfiles">add_subfiles</a>接口。</p>
<p>另外，此接口在2.2.5之后的版本，提供了一些内置的辅助函数，可以直接includes后使用，具体有哪些内置函数可以看下：<a href="https://github.com/xmake-io/xmake/tree/master/xmake/includes">https://github.com/xmake-io/xmake/tree/master/xmake/includes</a></p>
<p>关于这块的更加完整的说明，可以看下：<a href="https://github.com/xmake-io/xmake/issues/342">https://github.com/xmake-io/xmake/issues/342</a></p>
<h5 id="set_modes">set_modes</h5>
<h6 id="-">设置支持的编译模式</h6>
<p>这个是可选接口，一般情况下不需要设置，目前仅用于对工程增加更加细致的描述信息，方便vs工程的多模式生成，以及其他xmake插件中获取模式信息。</p>
<p>例如：</p>
<pre><code class="lang-lua">set_modes(&quot;debug&quot;, &quot;release&quot;)
</code></pre>
<p>如果设置了这个，xmake就知道当前工程支持哪些编译模式，这样生成vs工程文件的时候，只需要：</p>
<pre><code class="lang-bash">$ xmake project -k vs2017
</code></pre>
<p>不再需要额外手动指定需要的编译模式了，此外其他一些想要获取工程信息的插件，也许也会需要这些设置信息。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>当然，对于<a href="#is_mode">is_mode</a>接口，<code>set_modes</code>不是必须的，就算不设置，也是可以通过<code>is_mode</code>正常判断当前的编译模式。<br>&lt;/p&gt;

</p>
<h5 id="set_project">set_project</h5>
<h6 id="-">设置工程名</h6>
<p>设置工程名，在doxygen自动文档生成插件、工程文件生成插件中会用到，一般设置在xmake.lua的最开头，当然放在其他地方也是可以的</p>
<pre><code class="lang-lua">-- 设置工程名
set_project(&quot;tbox&quot;)

-- 设置工程版本
set_version(&quot;1.5.1&quot;)
</code></pre>
<h5 id="set_version">set_version</h5>
<h6 id="-">设置工程版本</h6>
<p>设置项目版本，可以放在xmake.lua任何地方，一般放在最开头，例如：</p>
<pre><code class="lang-lua">set_version(&quot;1.5.1&quot;)
</code></pre>
<p>以tbox为例，如果调用<a href="#targetset_config_header">set_config_header</a>设置了<code>config.h</code>，那么会自动生成如下宏：</p>
<pre><code class="lang-c">// version
#define TB_CONFIG_VERSION &quot;1.5.1&quot;
#define TB_CONFIG_VERSION_MAJOR 1
#define TB_CONFIG_VERSION_MINOR 5
#define TB_CONFIG_VERSION_ALTER 1
#define TB_CONFIG_VERSION_BUILD 201510220917
</code></pre>
<p>2.1.7版本支持buildversion的配置：</p>
<pre><code class="lang-lua">set_version(&quot;1.5.1&quot;, {build = &quot;%Y%m%d%H%M&quot;})
</code></pre>
<h5 id="set_xmakever">set_xmakever</h5>
<h6 id="-xmake-">设置最小xmake版本</h6>
<p>用于处理xmake版本兼容性问题，如果项目的<code>xmake.lua</code>，通过这个接口设置了最小xmake版本支持，那么用户环境装的xmake低于要求的版本，就会提示错误。</p>
<p>一般情况下，建议默认对其进行设置，这样对用户比较友好，如果<code>xmake.lua</code>中用到了高版本的api接口，用户那边至少可以知道是否因为版本不对导致的构建失败。</p>
<p>设置如下：</p>
<pre><code class="lang-lua">-- 设置最小版本为：2.1.0，低于此版本的xmake编译此工程将会提示版本错误信息
set_xmakever(&quot;2.1.0&quot;)
</code></pre>
<h5 id="add_subdirs">add_subdirs</h5>
<h6 id="-">添加子工程目录</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>xmake 2.x以上版本，请尽量使用<a href="#includes">includes</a>这个接口，这个是add_subdirs和add_subfiles的通用版本，并且支持一些内建扩展模块。<br>&lt;/p&gt;

</p>
<p>每个子工程对应一个<code>xmake.lua</code>的工程描述文件。</p>
<p>虽然一个<code>xmake.lua</code>也可以描述多个子工程模块，但是如果工程越来越大，越来越复杂，适当的模块化是很有必要的。。</p>
<p>这就需要<code>add_subdirs</code>了，将每个子模块放到不同目录中，并为其建立一个新的<code>xmake.lua</code>独立去维护它，例如：</p>
<pre><code>./tbox
├── src
│   ├── demo
│   │   └── xmake.lua (用来描述测试模块)
│   └── tbox
│       └── xmake.lua（用来描述libtbox库模块）
└── xmake.lua（用该描述通用配置信息，以及对子模块的维护）
`
</code></pre><p>在<code>tbox/xmake.lua</code>中通过<code>add_subdirs</code>将拥有<code>xmale.lua</code>的子模块的目录，添加进来，就可以了，例如：</p>
<pre><code class="lang-lua">-- 添加libtbox库模块目录
add_subdirs(&quot;src/tbox&quot;) 

-- 如果xmake f --demo=y，启用了demo模块，那么包含demo目录
if is_option(&quot;demo&quot;) then 
    add_subdirs(&quot;src/demo&quot;) 
end
</code></pre>
<p>默认情况下，xmake会去编译在所有xmake.lua中描述的所有target目标，如果只想编译指定目标，可以执行：</p>
<pre><code class="lang-bash"># 仅仅编译tbox库模块
$ xmake build tbox
</code></pre>
<p>需要注意的是，每个子<code>xmake.lua</code>中所有的路径设置都是相对于当前这个子<code>xmake.lua</code>所在的目录的，都是相对路径，这样方便维护</p>
<h5 id="add_subfiles">add_subfiles</h5>
<h6 id="-">添加子工程文件</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>xmake 2.x以上版本，请尽量使用<a href="#includes">includes</a>这个接口，这个是add_subdirs和add_subfiles的通用版本，并且支持一些内建扩展模块。<br>&lt;/p&gt;

</p>
<p><code>add_subfiles</code>的作用与<a href="#add_subdirs">add_subdirs</a>类似，唯一的区别就是：这个接口直接指定<code>xmake.lua</code>文件所在的路径，而不是目录，例如：</p>
<pre><code class="lang-lua">add_subfiles(&quot;src/tbox/xmake.lua&quot;)
</code></pre>
<h5 id="add_moduledirs">add_moduledirs</h5>
<h6 id="-">添加模块目录</h6>
<p>xmake内置的扩展模块都在<code>xmake/modules</code>目录下，可通过<a href="#import">import</a>来导入他们，如果自己在工程里面实现了一些扩展模块，<br>可以放置在这个接口指定的目录下，import也就会能找到，并且优先进行导入。</p>
<p>例如定义一个<code>find_openssl.lua</code>的扩展模块，用于扩展内置的<a href="#detect-find_package">lib.detect.find_package</a>接口，则只需要将它放置在：</p>
<pre><code>projectdir/xmake/modules/detect/packages/find_openssl.lua
</code></pre><p>然后在工程<code>xmake.lua</code>下指定这个模块目录，<code>find_package</code>就可以自动找到了：</p>
<pre><code class="lang-lua">add_moduledirs(&quot;projectdir/xmake/modules&quot;)
</code></pre>
<h5 id="add_plugindirs">add_plugindirs</h5>
<h6 id="-">添加插件目录</h6>
<p>xmake内置的插件都是放在<code>xmake/plugins</code>目录下，但是对于用户自定义的一些特定工程的插件，如果不想放置在xmake安装目录下，那么可以在<code>xmake.lua</code>中进行配置指定的其他插件路径。</p>
<pre><code class="lang-lua">-- 将当前工程下的plugins目录设置为自定义插件目录
add_plugindirs(&quot;$(projectdir)/plugins&quot;)
</code></pre>
<p>这样，xmake在编译此工程的时候，也就加载这些插件。</p>
<h5 id="add_packagedirs">add_packagedirs</h5>
<h6 id="-">添加包目录</h6>
<p>通过设置依赖包目录，可以方便的集成一些第三方的依赖库，以tbox工程为例，其依赖包如下：</p>
<pre><code>- base.pkg
- zlib.pkg
- polarssl.pkg
- openssl.pkg
- mysql.pkg
- pcre.pkg
- ...
</code></pre><p>如果要让当前工程识别加载这些包，首先要指定包目录路径，例如：</p>
<pre><code class="lang-lua">add_packagedirs(&quot;packages&quot;)
</code></pre>
<p>指定好后，就可以在target作用域中，通过<a href="#add_packages">add_packages</a>接口，来添加集成包依赖了，例如：</p>
<pre><code class="lang-lua">target(&quot;tbox&quot;)
    add_packages(&quot;zlib&quot;, &quot;polarssl&quot;, &quot;pcre&quot;, &quot;mysql&quot;)
</code></pre>
<h5 id="get_config">get_config</h5>
<h6 id="-">获取给定的配置值</h6>
<p>此接口从2.2.2版本开始引入，用于快速获取给定的配置值，可用于描述域。</p>
<pre><code class="lang-lua">if get_config(&quot;myconfig&quot;) == &quot;xxx&quot; then
    add_defines(&quot;HELLO&quot;)
end
</code></pre>
<h5 id="set_config">set_config</h5>
<h6 id="-">设置给定的默认配置值</h6>
<p>此接口从2.2.2版本开始引入，用于快速在xmake.lua中设置一个默认配置值，仅用于描述域。</p>
<p>之前很多配置，包括编译工具链，构建目录等只能通过<code>$ xmake f --name=value</code>的方式来配置，如果我们想写死在xmake.lua提供一个默认值，就可以通过下面的方式来配置：</p>
<pre><code class="lang-lua">set_config(&quot;name&quot;, &quot;value&quot;)
set_config(&quot;buildir&quot;, &quot;other/buildir&quot;)
set_config(&quot;cc&quot;, &quot;gcc&quot;)
set_config(&quot;ld&quot;, &quot;g++&quot;)
</code></pre>
<p>不过，我们还是可以通过<code>$ xmake f --name=value</code>的方式，去修改xmake.lua中的默认配置。</p>
<h5 id="add_requires">add_requires</h5>
<h6 id="-">添加需要的依赖包</h6>
<p>xmake的依赖包管理是完全支持语义版本选择的，例如：&quot;~1.6.1&quot;，对于语义版本的具体描述见：<a href="https://semver.org/">https://semver.org/</a></p>
<p>一些语义版本写法：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox 1.6.*&quot;, &quot;pcre 1.3.x&quot;, &quot;libpng ^1.18&quot;)
add_requires(&quot;libpng ~1.16&quot;, &quot;zlib 1.1.2 || &gt;=1.2.11 &lt;1.3.0&quot;)
</code></pre>
<p>目前xmake使用的语义版本解析器是<a href="https://github.com/uael">uael</a>贡献的<a href="https://github.com/uael/sv">sv</a>库，里面也有对版本描述写法的详细说明，可以参考下：<a href="https://github.com/uael/sv#versions">版本描述说明</a></p>
<p>当然，如果我们对当前的依赖包的版本没有特殊要求，那么可以直接这么写：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox&quot;, &quot;libpng&quot;, &quot;zlib&quot;)
</code></pre>
<p>这会使用已知的最新版本包，或者是master分支的源码编译的包，如果当前包有git repo地址，我们也能指定特定分支版本：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox master&quot;)
add_requires(&quot;tbox dev&quot;)
</code></pre>
<p>如果指定的依赖包当前平台不支持，或者编译安装失败了，那么xmake会编译报错，这对于有些必须要依赖某些包才能工作的项目，这是合理的。<br>但是如果有些包是可选的依赖，即使没有也可以正常编译使用的话，可以设置为可选包：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox&quot;, {optional = true})
</code></pre>
<p>默认的设置，xmake会去优先检测系统库是否存在（如果没设置版本要求），如果用户完全不想使用系统库以及第三方包管理提供的库，那么可以设置：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox&quot;, {system = false})
</code></pre>
<p>如果我们想同时源码调试依赖包，那么可以设置为使用debug版本的包（当然前提是这个包支持debug编译）：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox&quot;, {debug = true})
</code></pre>
<p>如果当前包还不支持debug编译，可在仓库中提交修改编译规则，对debug进行支持，例如：</p>
<pre><code class="lang-lua">package(&quot;openssl&quot;)
    on_install(&quot;linux&quot;, &quot;macosx&quot;, function (package)
        os.vrun(&quot;./config %s --prefix=\&quot;%s\&quot;&quot;, package:debug() and &quot;--debug&quot; or &quot;&quot;, package:installdir())
        os.vrun(&quot;make -j4&quot;)
        os.vrun(&quot;make install&quot;)
    end)
</code></pre>
<p>某些包在编译时候有各种编译选项，我们也可以传递进来，当然包本身得支持：</p>
<pre><code class="lang-lua">add_requires(&quot;tbox&quot;, {config = {small=true}})
</code></pre>
<p>传递<code>--small=true</code>给tbox包，使得编译安装的tbox包是启用此选项的。</p>
<p>v2.2.3之后，可以通过<a href="#option">option</a>和<a href="#has_config">has_config</a>配合，在自己定义配置选项参数中控制是否需要添加某个依赖包：</p>
<pre><code class="lang-lua">option(&quot;luajit&quot;)
    set_default(false)
    set_showmenu(true)
    set_category(&quot;option&quot;)
    set_description(&quot;Enable the luajit runtime engine.&quot;)
option_end()

if has_config(&quot;luajit&quot;) then
    add_requires(&quot;luajit&quot;)
else
    add_requires(&quot;lua&quot;)
end
</code></pre>
<p>我们可以通过<code>$xmake f --luajit=y</code>去切换依赖包。</p>
<p>并且我们也新增了group参数，来分组依赖包，同一个组下的所有依赖包，只能有一个生效启用，启用顺序依赖<code>add_requires</code>添加的顺序:</p>
<pre><code class="lang-lua">add_requires(&quot;openssl&quot;, {group = &quot;ssl&quot;, optional = true})
add_requires(&quot;mbedtls&quot;, {group = &quot;ssl&quot;, optional = true})

target(&quot;test&quot;)
    add_packages(&quot;openssl&quot;, &quot;mbedtls&quot;)
</code></pre>
<p>例如上面，所以同时依赖两个ssl包，实际上只会启用生效实际安装成功的那一个ssl包，并不会同时链接两个依赖包。</p>
<p>2.2.5版本之后，xmake支持对对第三方包管理器里面的依赖库安装支持，例如：conan，brew, vcpkg等</p>
<p>添加homebrew的依赖包：</p>
<pre><code class="lang-lua">add_requires(&quot;brew::zlib&quot;, {alias = &quot;zlib&quot;}})
add_requires(&quot;brew::pcre2/libpcre2-8&quot;, {alias = &quot;pcre2&quot;}})

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;) 
    add_packages(&quot;pcre2&quot;, &quot;zlib&quot;)
</code></pre>
<p>添加vcpkg的依赖包：</p>
<pre><code class="lang-lua">add_requires(&quot;vcpkg::zlib&quot;, &quot;vcpkg::pcre2&quot;)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;) 
    add_packages(&quot;vcpkg::zlib&quot;, &quot;vcpkg::pcre2&quot;)
</code></pre>
<p>添加conan的依赖包：</p>
<pre><code class="lang-lua">add_requires(&quot;CONAN::zlib/1.2.11@conan/stable&quot;, {alias = &quot;zlib&quot;, debug = true})
add_requires(&quot;CONAN::OpenSSL/1.0.2n@conan/stable&quot;, {alias = &quot;openssl&quot;, 
    configs = {options = &quot;OpenSSL:shared=True&quot;}})

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;) 
    add_packages(&quot;openssl&quot;, &quot;zlib&quot;)
</code></pre>
<p>执行xmake进行编译后：</p>
<pre><code class="lang-console">ruki:test_package ruki$ xmake
checking for the architecture ... x86_64
checking for the Xcode directory ... /Applications/Xcode.app
checking for the SDK version of Xcode ... 10.14
note: try installing these packages (pass -y to skip confirm)?
  -&gt; CONAN::zlib/1.2.11@conan/stable  (debug)
  -&gt; CONAN::OpenSSL/1.0.2n@conan/stable  
please input: y (y/n)

  =&gt; installing CONAN::zlib/1.2.11@conan/stable .. ok
  =&gt; installing CONAN::OpenSSL/1.0.2n@conan/stable .. ok

[  0%]: ccache compiling.release src/main.c
[100%]: linking.release test
</code></pre>
<p>关于这块的更多详情见：<a href="https://github.com/xmake-io/xmake/issues/339">https://github.com/xmake-io/xmake/issues/339</a></p>
<p>添加clib的依赖包：</p>
<p>clib是一款基于源码的依赖包管理器，拉取的依赖包是直接下载对应的库源码，集成到项目中编译，而不是二进制库依赖。</p>
<p>其在xmake中集成也很方便，唯一需要注意的是，还需要自己添加上对应库的源码到xmake.lua，例如：</p>
<pre><code class="lang-lua">add_requires(&quot;clib::clibs/bytes@0.0.4&quot;, {alias = &quot;bytes&quot;})

target(&quot;xmake-test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;clib/bytes/*.c&quot;)
    add_files(&quot;src/*.c&quot;) 
    add_packages(&quot;bytes&quot;)
</code></pre>
<h5 id="add_repositories">add_repositories</h5>
<h6 id="-">添加依赖包仓库</h6>
<p>如果需要的包不在官方仓库<a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a>中，我们可以提交贡献代码到仓库进行支持。<br>但如果有些包仅用于个人或者私有项目，我们可以建立一个私有仓库repo，仓库组织结构可参考：<a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a></p>
<p>比如，现在我们有一个一个私有仓库repo：<a href="mailto:`git@github.com">`git@github.com</a>:myrepo/xmake-repo.git`</p>
<p>我们可以通过此接口来添加：</p>
<pre><code class="lang-lua">add_repositories(&quot;my-repo git@github.com:myrepo/xmake-repo.git&quot;)
</code></pre>
<p>如果我们只是想添加一两个私有包，这个时候特定去建立一个git repo太小题大做了，我们可以直接把包仓库放置项目里面，例如：</p>
<pre><code>projectdir
  - myrepo
    - packages
      - t/tbox/xmake.lua
      - z/zlib/xmake.lua
  - src
    - main.c
  - xmake.lua
</code></pre><p>上面myrepo目录就是自己的私有包仓库，内置在自己的项目里面，然后在xmake.lua里面添加一下这个仓库位置：</p>
<pre><code class="lang-lua">add_repositories(&quot;my-repo myrepo&quot;)
</code></pre>
<p>这个可以参考<a href="https://github.com/tboox/benchbox">benchbox</a>项目，里面就内置了一个私有仓库。</p>
<h4 id="-">工程目标</h4>
<p>定义和设置子工程模块，每个<code>target</code>对应一个子工程，最后会生成一个目标程序，有可能是可执行程序，也有可能是库模块。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>target的接口，都是可以放置在target外面的全局作用域中的，如果在全局中设置，那么会影响所有子工程target。<br>&lt;/p&gt;

</p>
<p>例如：</p>
<pre><code class="lang-lua">-- 会同时影响test和test2目标
add_defines(&quot;DEBUG&quot;)

target(&quot;test&quot;)
    add_files(&quot;*.c&quot;)

target(&quot;test2&quot;)
    add_files(&quot;*.c&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br><code>target</code>域是可以重复进入来实现分离设置的。<br>&lt;/p&gt;


</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#target">target</a></td>
<td>定义工程目标</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#target_end">target_end</a></td>
<td>结束定义工程目标</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetset_kind">set_kind</a></td>
<td>设置目标编译类型</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_strip">set_strip</a></td>
<td>设置是否strip信息</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_enabled">set_enabled</a></td>
<td>设置是否启用或禁用目标</td>
<td>&gt;= 2.2.2</td>
</tr>
<tr>
<td><a href="#targetset_default">set_default</a></td>
<td>设置是否为默认构建安装目标</td>
<td>&gt;= 2.1.3</td>
</tr>
<tr>
<td><a href="#targetset_options">set_options</a></td>
<td>设置关联选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_symbols">set_symbols</a></td>
<td>设置符号信息</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_basename">set_basename</a></td>
<td>设置目标文件名</td>
<td>&gt;= 2.1.2</td>
</tr>
<tr>
<td><a href="#targetset_filename">set_filename</a></td>
<td>设置目标文件全名</td>
<td>&gt;= 2.1.2</td>
</tr>
<tr>
<td><a href="#targetset_warnings">set_warnings</a></td>
<td>设置警告级别</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_optimize">set_optimize</a></td>
<td>设置优化级别</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_languages">set_languages</a></td>
<td>设置代码语言标准</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_headerdir">set_headerdir</a></td>
<td>设置头文件安装目录</td>
<td>&gt;= 1.0.1 &lt; 2.2.5 已废弃</td>
</tr>
<tr>
<td><a href="#targetset_targetdir">set_targetdir</a></td>
<td>设置生成目标文件目录</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_objectdir">set_objectdir</a></td>
<td>设置对象文件生成目录</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_dependir">set_dependir</a></td>
<td>设置依赖文件生成目录</td>
<td>&gt;= 2.2.2</td>
</tr>
<tr>
<td><a href="#targetadd_imports">add_imports</a></td>
<td>为所有自定义脚本预先导入扩展模块</td>
<td>&gt;= 2.1.7</td>
</tr>
<tr>
<td><a href="#targetadd_rules">add_rules</a></td>
<td>添加规则到目标</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#targeton_load">on_load</a></td>
<td>自定义目标加载脚本</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#targeton_link">on_link</a></td>
<td>自定义链接脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#targeton_build">on_build</a></td>
<td>自定义编译脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targeton_build_file">on_build_file</a></td>
<td>自定义编译脚本, 实现单文件构建</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#targeton_build_files">on_build_files</a></td>
<td>自定义编译脚本, 实现多文件构建</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#targeton_clean">on_clean</a></td>
<td>自定义清理脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targeton_package">on_package</a></td>
<td>自定义打包脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targeton_install">on_install</a></td>
<td>自定义安装脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targeton_uninstall">on_uninstall</a></td>
<td>自定义卸载脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targeton_run">on_run</a></td>
<td>自定义运行脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetbefore_link">before_link</a></td>
<td>在链接之前执行一些自定义脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#targetbefore_build">before_build</a></td>
<td>在构建之前执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetbefore_build_file">before_build_file</a></td>
<td>自定义编译前的脚本, 实现单文件构建</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#targetbefore_build_files">before_build_files</a></td>
<td>自定义编译前的脚本, 实现多文件构建</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#targetbefore_clean">before_clean</a></td>
<td>在清除之前执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetbefore_package">before_package</a></td>
<td>在打包之前执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetbefore_install">before_install</a></td>
<td>在安装之前执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetbefore_uninstall">before_uninstall</a></td>
<td>在卸载之前执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetbefore_run">before_run</a></td>
<td>在运行之前执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetafter_link">after_link</a></td>
<td>在链接之后执行一些自定义脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#targetafter_build">after_build</a></td>
<td>在构建之后执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetafter_build_file">after_build_file</a></td>
<td>自定义编译后的脚本, 实现单文件构建</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#targetafter_build_files">after_build_files</a></td>
<td>自定义编译后的脚本, 实现多文件构建</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#targetafter_clean">after_clean</a></td>
<td>在清除之后执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetafter_package">after_package</a></td>
<td>在打包之后执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetafter_install">after_install</a></td>
<td>在安装之后执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetafter_uninstall">after_uninstall</a></td>
<td>在卸载之后执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetafter_run">after_run</a></td>
<td>在运行之后执行一些自定义脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetset_config_h">set_config_h</a></td>
<td>设置自动生成的配置头文件路径</td>
<td>&gt;= 1.0.1 &lt; 2.1.5 已废弃</td>
</tr>
<tr>
<td><a href="#targetset_config_h">set_config_h_prefix</a></td>
<td>设置自动生成的头文件中宏定义命名前缀</td>
<td>&gt;= 1.0.1 &lt; 2.1.5 已废弃</td>
</tr>
<tr>
<td><a href="#targetset_config_header">set_config_header</a></td>
<td>设置自动生成的配置头文件路径和前缀</td>
<td>&gt;= 2.1.5 &lt; 2.2.5 已废弃</td>
</tr>
<tr>
<td><a href="#targetset_pcheader">set_pcheader</a></td>
<td>设置c预编译头文件</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#targetset_pcxxheader">set_pcxxheader</a></td>
<td>设置c++预编译头文件</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#targetadd_deps">add_deps</a></td>
<td>添加子工程目标依赖</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_links">add_links</a></td>
<td>添加链接库名</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_syslinks">add_syslinks</a></td>
<td>添加系统链接库名</td>
<td>&gt;= 2.2.3</td>
</tr>
<tr>
<td><a href="#targetadd_files">add_files</a></td>
<td>添加源代码文件</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetdel_files">del_files</a></td>
<td>从前面的源文件列表中删除指定文件</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#targetadd_headers">add_headers</a></td>
<td>添加安装的头文件</td>
<td>&gt;= 1.0.1 &lt; 2.2.5 已废弃</td>
</tr>
<tr>
<td><a href="#targetadd_linkdirs">add_linkdirs</a></td>
<td>添加链接库搜索目录</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_rpathdirs">add_rpathdirs</a></td>
<td>添加运行时候动态链接库搜索目录</td>
<td>&gt;= 2.1.3</td>
</tr>
<tr>
<td><a href="#targetadd_includedirs">add_includedirs</a></td>
<td>添加头文件搜索目录</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_defines">add_defines</a></td>
<td>添加宏定义</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_undefines">add_undefines</a></td>
<td>取消宏定义</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_defines_h">add_defines_h</a></td>
<td>添加宏定义到头文件</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_undefines_h">add_undefines_h</a></td>
<td>取消宏定义到头文件</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cflags">add_cflags</a></td>
<td>添加c编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cxflags">add_cxflags</a></td>
<td>添加c/c++编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cxxflags">add_cxxflags</a></td>
<td>添加c++编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_mflags">add_mflags</a></td>
<td>添加objc编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_mxflags">add_mxflags</a></td>
<td>添加objc/objc++编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_mxxflags">add_mxxflags</a></td>
<td>添加objc++编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_scflags">add_scflags</a></td>
<td>添加swift编译选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_asflags">add_asflags</a></td>
<td>添加汇编编译选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_gcflags">add_gcflags</a></td>
<td>添加go编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_dcflags">add_dcflags</a></td>
<td>添加dlang编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_rcflags">add_rcflags</a></td>
<td>添加rust编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_cuflags">add_cuflags</a></td>
<td>添加cuda编译选项</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#targetadd_culdflags">add_culdflags</a></td>
<td>添加cuda设备链接选项</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#targetadd_ldflags">add_ldflags</a></td>
<td>添加链接选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_arflags">add_arflags</a></td>
<td>添加静态库归档选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_shflags">add_shflags</a></td>
<td>添加动态库链接选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cfunc">add_cfunc</a></td>
<td>添加单个c库函数检测</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cxxfunc">add_cxxfunc</a></td>
<td>添加单个c++库函数检测</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cfuncs">add_cfuncs</a></td>
<td>添加c库函数检测</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cxxfuncs">add_cxxfuncs</a></td>
<td>添加c++库函数接口</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_packages">add_packages</a></td>
<td>添加包依赖</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_options">add_options</a></td>
<td>添加关联选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_languages">add_languages</a></td>
<td>添加语言标准</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_vectorexts">add_vectorexts</a></td>
<td>添加向量扩展指令</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_frameworks">add_frameworks</a></td>
<td>添加链接框架</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_frameworkdirs">add_frameworkdirs</a></td>
<td>添加链接框架的搜索目录</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#targetset_tools">set_tools</a></td>
<td>设置编译链接工具链</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#targetadd_tools">add_tools</a></td>
<td>添加编译链接工具链</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#targetset_values">set_values</a></td>
<td>设置一些扩展配置值</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#targetadd_values">add_values</a></td>
<td>添加一些扩展配置值</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#targetset_rundir">set_rundir</a></td>
<td>设置运行目录</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#targetadd_runenvs">add_runenvs</a></td>
<td>添加运行环境变量</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#targetset_installdir">set_installdir</a></td>
<td>设置安装目录</td>
<td>&gt;= 2.2.5</td>
</tr>
<tr>
<td><a href="#targetadd_installfiles">add_installfiles</a></td>
<td>添加安装文件</td>
<td>&gt;= 2.2.5</td>
</tr>
<tr>
<td><a href="#targetadd_headerfiles">add_headerfiles</a></td>
<td>添加安装头文件</td>
<td>&gt;= 2.2.5</td>
</tr>
<tr>
<td><a href="#targetset_configdir">set_configdir</a></td>
<td>设置模板配置文件输出目录</td>
<td>&gt;= 2.2.5</td>
</tr>
<tr>
<td><a href="#targetset_configvar">set_configvar</a></td>
<td>设置模板配置变量</td>
<td>&gt;= 2.2.5</td>
</tr>
<tr>
<td><a href="#targetadd_configfiles">add_configfiles</a></td>
<td>添加模板配置文件</td>
<td>&gt;= 2.2.5</td>
</tr>
</tbody>
</table>
<h5 id="target">target</h5>
<h6 id="-">定义工程目标</h6>
<p>定义一个新的控制台工程目标，工程名为<code>test</code>，最后生成的目标名也是<code>test</code>。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<p>可以重复调用这个api，进入target域修改设置</p>
<pre><code class="lang-lua">-- 定义目标demo，并进入demo设置模式
target(&quot;demo&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/demo.c&quot;)

-- 定义和设置其他目标
target(&quot;other&quot;)
    ...

-- 重新进入demo目标域，添加test.c文件
target(&quot;demo&quot;)
    add_files(&quot;src/test.c&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>所有根域的设置，会全局影响所有target目标，但是不会影响option的定义。<br>&lt;/p&gt;

</p>
<pre><code class="lang-lua">-- 在根域对所有target添加-DDEBUG的宏定义，影响所有target（demo和test都会加上此宏定义）
add_defines(&quot;DEBUG&quot;)

target(&quot;demo&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/demo.c&quot;)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/test.c&quot;)
</code></pre>
<h5 id="target_end">target_end</h5>
<h6 id="-">结束定义工程目标</h6>
<p>这是一个可选的api，如果不调用，那么<code>target(&quot;xxx&quot;)</code>之后的所有设置都是针对这个target进行的，除非进入其他<code>target</code>, <code>option</code>, <code>task</code>域。</p>
<p>如果想设置完当前<code>target</code>后，显示离开<code>target</code>域，进入根域设置，那么可以通过这个api才操作，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;src/*.c&quot;)
target_end()

-- 此处已在根域
-- ...
</code></pre>
<p>如果不调用这个api的话:</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;src/*.c&quot;)

-- 此处还在上面target域中，之后的设置还是针对test进行的设置
-- ...

-- 这个时候才离开test，进入另外一个target域中
target(&quot;test2&quot;)
    ...
</code></pre>
<h5 id="target-set_kind">target:set_kind</h5>
<h6 id="-">设置目标编译类型</h6>
<p>设置目标类型，目前支持的类型有：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>binary</td>
<td>二进制程序</td>
</tr>
<tr>
<td>static</td>
<td>静态库程序</td>
</tr>
<tr>
<td>shared</td>
<td>动态库程序</td>
</tr>
</tbody>
</table>
<pre><code class="lang-lua">target(&quot;demo&quot;)
    set_kind(&quot;binary&quot;)
</code></pre>
<h5 id="target-set_strip">target:set_strip</h5>
<h6 id="-strip-">设置是否strip信息</h6>
<p>设置当前目标的strip模式，目前支持一下模式：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug</td>
<td>链接的时候，strip掉调试符号</td>
</tr>
<tr>
<td>all</td>
<td>链接的时候，strip掉所有符号，包括调试符号</td>
</tr>
</tbody>
</table>
<p>这个api一般在release模式下使用，可以生成更小的二进制程序。。</p>
<pre><code class="lang-lua">target(&quot;xxxx&quot;)
    set_strip(&quot;all&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>这个api不一定非得在target之后使用，如果没有target指定，那么将会设置到全局模式。。<br>&lt;/p&gt;

</p>
<h5 id="target-set_enabled">target:set_enabled</h5>
<h6 id="-">设置是否启用或禁用目标</h6>
<p>如果设置<code>set_enabled(false)</code>，则会直接禁用对应的target，包括target的加载和信息获取，而<a href="#targetset_default">set_default</a>仅仅只是设置默认不去编译，但是target还是能获取到相关信息的，默认也会被加载。</p>
<h5 id="target-set_default">target:set_default</h5>
<h6 id="-">设置是否为默认构建安装目标</h6>
<p>这个接口用于设置给定工程目标是否作为默认构建，如果没有调用此接口进行设置，那么这个目标就是默认被构建的，例如：</p>
<pre><code class="lang-lua">target(&quot;test1&quot;)
    set_default(false)

target(&quot;test2&quot;)
    set_default(true)

target(&quot;test3&quot;)
    ...
</code></pre>
<p>上述代码的三个目标，在执行<code>xmake</code>, <code>xmake install</code>, <code>xmake package</code>, <code>xmake run</code>等命令的时候，如果不指定目标名，那么：</p>
<table>
<thead>
<tr>
<th>目标名</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>test1</td>
<td>不会被默认构建、安装、打包和运行</td>
</tr>
<tr>
<td>test2</td>
<td>默认构建、安装、打包和运行</td>
</tr>
<tr>
<td>test3</td>
<td>默认构建、安装、打包和运行</td>
</tr>
</tbody>
</table>
<p>通过上面的例子，可以看到默认目标可以设置多个，运行的时候也会依次运行。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>    需要注意的是，<code>xmake uninstall</code>和<code>xmake clean</code>命令不受此接口设置影响，因为用户大部分情况下都是喜欢清除和卸载所有。<br>&lt;/p&gt;

</p>
<p>如果不想使用默认的目标，那么可以手动指定需要构建安装的目标：</p>
<pre><code class="lang-bash">$ xmake build targetname
$ xmake install targetname
</code></pre>
<p>如果要强制构建安装所有目标，可以传入<code>[-a|--all]</code>参数：</p>
<pre><code class="lang-bash">$ xmake build [-a|--all]
$ xmake install [-a|--all]
</code></pre>
<h5 id="target-set_options">target:set_options</h5>
<h6 id="-">设置关联选项</h6>
<p>添加选项依赖，如果通过<a href="#option">option</a>接口自定义了一些选项，那么只有在指定<code>target</code>目标域下，添加此选项，才能进行关联生效。</p>
<pre><code class="lang-lua">-- 定义一个hello选项
option(&quot;hello&quot;)
    set_default(false)
    set_showmenu(true)
    add_defines(&quot;HELLO_ENABLE&quot;)

target(&quot;test&quot;)
    -- 如果hello选项被启用了，这个时候就会将-DHELLO_ENABLE宏应用到test目标上去
    set_options(&quot;hello&quot;)
</code></pre>
<p>&lt;p class=&quot;warn&quot;&gt;<br>只有调用<code>set_options</code>进行关联生效后，<a href="#option">option</a> 中定义的一些设置才会影响到此<code>target</code>目标，例如：宏定义、链接库、编译选项等等<br>&lt;/p&gt;

</p>
<h5 id="target-set_symbols">target:set_symbols</h5>
<h6 id="-">设置符号信息</h6>
<p>设置目标的符号模式，如果当前没有定义target，那么将会设置到全局状态中，影响所有后续的目标。</p>
<p>目前主要支持一下几个级别：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug</td>
<td>添加调试符号</td>
</tr>
<tr>
<td>hidden</td>
<td>设置符号不可见</td>
</tr>
</tbody>
</table>
<p>这两个值也可以同时被设置，例如：</p>
<pre><code class="lang-lua">-- 添加调试符号, 设置符号不可见
set_symbols(&quot;debug&quot;, &quot;hidden&quot;)
</code></pre>
<p>如果没有调用这个api，默认是禁用调试符号的。。</p>
<h5 id="target-set_basename">target:set_basename</h5>
<h6 id="-">设置目标文件名</h6>
<p>默认情况下，生成的目标文件名基于<code>target(&quot;name&quot;)</code>中配置的值，例如：</p>
<pre><code class="lang-lua">-- 目标文件名为：libxxx.a
target(&quot;xxx&quot;)
    set_kind(&quot;static&quot;)

-- 目标文件名为：libxxx2.so
target(&quot;xxx2&quot;)
    set_kind(&quot;shared&quot;)
</code></pre>
<p>默认的命名方式，基本上可以满足大部分情况下的需求，但是如果有时候想要更加定制化目标文件名</p>
<p>例如，按编译模式和架构区分目标名，这个时候可以使用这个接口，来设置：</p>
<pre><code class="lang-lua">target(&quot;xxx&quot;)
    set_kind(&quot;static&quot;)
    set_basename(&quot;xxx_$(mode)_$(arch)&quot;)
</code></pre>
<p>如果这个时候，编译配置为：<code>xmake f -m debug -a armv7</code>，那么生成的文件名为：<code>libxxx_debug_armv7.a</code></p>
<p>如果还想进一步定制目标文件的目录名，可参考：<a href="#targetset_targetdir">set_targetdir</a>。</p>
<p>或者通过编写自定义脚本，实现更高级的逻辑，具体见：<a href="#targetafter_build">after_build</a>和<a href="#os-mv">os.mv</a>。</p>
<h5 id="target-set_filename">target:set_filename</h5>
<h6 id="-">设置目标文件全名</h6>
<p>它跟<a href="#targetset_basename">set_basename</a>的区别在于，<a href="#targetset_basename">set_basename</a>设置名字不带后缀跟前缀，例如：<code>libtest.a</code>，basename如果改成test2后就变成了<code>libtest2.a</code>。</p>
<p>而filename的修改，是修改整个目标文件名，包括前后缀，例如可以直接把<code>libtest.a</code>改成<code>test.dll</code>，这个对于<a href="#targetset_basename">set_basename</a>是做不到的。</p>
<h5 id="target-set_warnings">target:set_warnings</h5>
<h6 id="-">设置警告级别</h6>
<p>设置当前目标的编译的警告级别，一般支持一下几个级别：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>gcc/clang</th>
<th>msvc</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>禁用所有警告</td>
<td>-w</td>
<td>-W0</td>
</tr>
<tr>
<td>less</td>
<td>启用较少的警告</td>
<td>-W1</td>
<td>-W1</td>
</tr>
<tr>
<td>more</td>
<td>启用较多的警告</td>
<td>-W3</td>
<td>-W3</td>
</tr>
<tr>
<td>all</td>
<td>启用所有警告</td>
<td>-Wall</td>
<td>-W3 (-Wall too more warnings)</td>
</tr>
<tr>
<td>everything</td>
<td>启用全部支持的警告</td>
<td>-Wall -Wextra -Weffc++ / -Weverything</td>
<td>-Wall</td>
</tr>
<tr>
<td>error</td>
<td>将所有警告作为编译错误</td>
<td>-Werror</td>
<td>-WX</td>
</tr>
</tbody>
</table>
<p>这个api的参数是可以混合添加的，例如：</p>
<pre><code class="lang-lua">-- 启用所有警告，并且作为编译错误处理
set_warnings(&quot;all&quot;, &quot;error&quot;)
</code></pre>
<p>如果当前没有目标，调用这个api将会设置到全局模式。。</p>
<h5 id="target-set_optimize">target:set_optimize</h5>
<h6 id="-">设置优化级别</h6>
<p>设置目标的编译优化等级，如果当前没有设置目标，那么将会设置到全局状态中，影响所有后续的目标。</p>
<p>目前主要支持一下几个级别：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>gcc/clang</th>
<th>msvc</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>禁用优化</td>
<td>-O0</td>
<td>-Od</td>
</tr>
<tr>
<td>fast</td>
<td>快速优化</td>
<td>-O1</td>
<td>default</td>
</tr>
<tr>
<td>faster</td>
<td>更快的优化</td>
<td>-O2</td>
<td>-Ox</td>
</tr>
<tr>
<td>fastest</td>
<td>最快运行速度的优化</td>
<td>-O3</td>
<td>-Ox -fp:fast</td>
</tr>
<tr>
<td>smallest</td>
<td>最小化代码优化</td>
<td>-Os</td>
<td>-O1</td>
</tr>
<tr>
<td>aggressive</td>
<td>过度优化</td>
<td>-Ofast</td>
<td>-Ox -fp:fast</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<pre><code class="lang-lua">-- 最快运行速度的优化
set_optimize(&quot;fastest&quot;)
</code></pre>
<h5 id="target-set_languages">target:set_languages</h5>
<h6 id="-">设置代码语言标准</h6>
<p>设置目标代码编译的语言标准，如果当前没有目标存在，将会设置到全局模式中。。。</p>
<p>支持的语言标准目前主要有以下几个：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ansi</td>
<td>c语言标准: ansi</td>
</tr>
<tr>
<td>c89</td>
<td>c语言标准: c89</td>
</tr>
<tr>
<td>gnu89</td>
<td>c语言标准: gnu89</td>
</tr>
<tr>
<td>c99</td>
<td>c语言标准: c99</td>
</tr>
<tr>
<td>gnu99</td>
<td>c语言标准: gnu99</td>
</tr>
<tr>
<td>cxx98</td>
<td>c++语言标准: <code>c++98</code></td>
</tr>
<tr>
<td>gnuxx98</td>
<td>c++语言标准: <code>gnu++98</code></td>
</tr>
<tr>
<td>cxx11</td>
<td>c++语言标准: <code>c++11</code></td>
</tr>
<tr>
<td>gnuxx11</td>
<td>c++语言标准: <code>gnu++11</code></td>
</tr>
<tr>
<td>cxx14</td>
<td>c++语言标准: <code>c++14</code></td>
</tr>
<tr>
<td>gnuxx14</td>
<td>c++语言标准: <code>gnu++14</code></td>
</tr>
<tr>
<td>cxx1z</td>
<td>c++语言标准: <code>c++1z</code></td>
</tr>
<tr>
<td>gnuxx1z</td>
<td>c++语言标准: <code>gnu++1z</code></td>
</tr>
<tr>
<td>cxx17</td>
<td>c++语言标准: <code>c++17</code></td>
</tr>
<tr>
<td>gnuxx17</td>
<td>c++语言标准: <code>gnu++17</code></td>
</tr>
</tbody>
</table>
<p>c标准和c++标准可同时进行设置，例如：</p>
<pre><code class="lang-lua">-- 设置c代码标准：c99， c++代码标准：c++11
set_languages(&quot;c99&quot;, &quot;cxx11&quot;)
</code></pre>
<p>&lt;p class=&quot;warn&quot;&gt;<br>并不是设置了指定的标准，编译器就一定会按这个标准来编译，毕竟每个编译器支持的力度不一样，但是xmake会尽最大可能的去适配当前编译工具的支持标准。。。<br>&lt;br&gt;&lt;br&gt;<br>例如：<br>&lt;br&gt;<br>windows下vs的编译器并不支持按c99的标准来编译c代码，只能支持到c89，但是xmake为了尽可能的支持它，所以在设置c99的标准后，xmake会强制按c++代码模式去编译c代码，从一定程度上解决了windows下编译c99的c代码问题。。<br>用户不需要去额外做任何修改。。<br>&lt;/p&gt;

</p>
<h5 id="target-set_headerdir">target:set_headerdir</h5>
<h6 id="-">设置头文件安装目录</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>注，2.2.5版本之后，此接口已废弃，请使用<a href="#targetadd_headerfiles">add_headerfiles</a>代替。<br>&lt;/p&gt;

</p>
<p>设置头文件的输出目录，默认输出到build目录中。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_headerdir(&quot;$(buildir)/include&quot;)
</code></pre>
<p>对于需要安装哪些头文件，可参考<a href="#targetadd_headers">add_headers</a>接口。</p>
<h5 id="target-set_targetdir">target:set_targetdir</h5>
<h6 id="-">设置生成目标文件目录</h6>
<p>设置目标程序文件的输出目录，一般情况下，不需要设置，默认会输出在build目录下</p>
<p>而build的目录可以在工程配置的时候，手动修改：</p>
<pre><code class="lang-bash">xmake f -o /tmp/build
</code></pre>
<p>修改成<code>/tmp/build</code>后，目标文件默认输出到<code>/tmp/build</code>下面。</p>
<p>而如果用这个接口去设置，就不需要每次敲命令修改了，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_targetdir(&quot;/tmp/build&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>如果显示设置了<code>set_targetdir</code>， 那么优先选择<code>set_targetdir</code>指定的目录为目标文件的输出目录。<br>&lt;/p&gt;

</p>
<h5 id="target-set_objectdir">target:set_objectdir</h5>
<h6 id="-">设置对象文件生成目录</h6>
<p>设置目标target的对象文件(<code>*.o/obj</code>)的输出目录，例如:</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_objectdir(&quot;$(buildir)/.objs&quot;)
</code></pre>
<h5 id="target-set_dependir">target:set_dependir</h5>
<h6 id="-">设置依赖文件生成目录</h6>
<p>设置目标target的编译依赖文件(<code>.deps</code>)的输出目录，例如:</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_dependir(&quot;$(buildir)/.deps&quot;)
</code></pre>
<h5 id="target-add_imports">target:add_imports</h5>
<h6 id="-">为自定义脚本预先导入扩展模块</h6>
<p>通常，我们在<a href="#targeton_build">on_build</a>等自定义脚本内部，可以通过<code>import(&quot;core.base.task&quot;)</code>的方式导入扩展模块，<br>但是对于自定义脚本比较多的情况下，每个自定义脚本都重复导入一遍，非常的繁琐，那么可以通过这个接口，实现预先导入，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_load(function (target)
        import(&quot;core.base.task&quot;)
        import(&quot;core.project.project&quot;)

        task.run(&quot;xxxx&quot;)
    end)
    on_build(function (target)
        import(&quot;core.base.task&quot;)
        import(&quot;core.project.project&quot;)

        task.run(&quot;xxxx&quot;)
    end)
    on_install(function (target)
        import(&quot;core.base.task&quot;)
        import(&quot;core.project.project&quot;)

        task.run(&quot;xxxx&quot;)
    end)
</code></pre>
<p>通过此接口可以简化为：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_imports(&quot;core.base.task&quot;, &quot;core.project.project&quot;)
    on_load(function (target)
        task.run(&quot;xxxx&quot;)
    end)
    on_build(function (target)
        task.run(&quot;xxxx&quot;)
    end)
    on_install(function (target)
        task.run(&quot;xxxx&quot;)
    end)
</code></pre>
<h5 id="target-add_rules">target:add_rules</h5>
<h6 id="-">添加规则到目标</h6>
<p>我们可以通过预先设置规则支持的文件后缀，来扩展其他文件的构建支持：</p>
<pre><code class="lang-lua">-- 定义一个markdown文件的构建规则
rule(&quot;markdown&quot;)
    set_extensions(&quot;.md&quot;, &quot;.markdown&quot;)
    on_build(function (target, sourcefile)
        os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. &quot;.html&quot;))
    end)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)

    -- 使test目标支持markdown文件的构建规则
    add_rules(&quot;markdown&quot;)

    -- 添加markdown文件的构建
    add_files(&quot;src/*.md&quot;)
    add_files(&quot;src/*.markdown&quot;)
</code></pre>
<p>我们也可以指定应用局部文件到规则，具体使用见：<a href="#targetadd_files">add_files</a>。</p>
<h5 id="target-on_load">target:on_load</h5>
<h6 id="-">自定义目标加载脚本</h6>
<p>在target初始化加载的时候，将会执行此脚本，在里面可以做一些动态的目标配置，实现更灵活的目标描述定义，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_load(function (target)
        target:add(&quot;defines&quot;, &quot;DEBUG&quot;, &quot;TEST=\&quot;hello\&quot;&quot;)
        target:add(&quot;linkdirs&quot;, &quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;)
        target:add({includedirs = &quot;/usr/include&quot;, &quot;links&quot; = &quot;pthread&quot;})
    end)
</code></pre>
<p>可以在<code>on_load</code>里面，通过<code>target:set</code>, <code>target:add</code> 来动态添加各种target属性。</p>
<h5 id="target-on_link">target:on_link</h5>
<h6 id="-">自定义链接脚本</h6>
<p>这个是在v2.2.7之后新加的接口，用于定制化处理target的链接过程。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_link(function (target) 
        print(&quot;link it&quot;)
    end)
</code></pre>
<h5 id="target-on_build">target:on_build</h5>
<h6 id="-">自定义编译脚本</h6>
<p>覆盖target目标默认的构建行为，实现自定义的编译过程，一般情况下，并不需要这么做，除非确实需要做一些xmake默认没有提供的编译操作。</p>
<p>你可以通过下面的方式覆盖它，来自定义编译操作：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 设置自定义编译脚本
    on_build(function (target) 
        print(&quot;build it&quot;)
    end)
</code></pre>
<p>注：2.1.5版本之后，所有target的自定义脚本都可以针对不同平台和架构，分别处理，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_build(&quot;iphoneos|arm*&quot;, function (target)
        print(&quot;build for iphoneos and arm&quot;)
    end)
</code></pre>
<p>其中如果第一个参数为字符串，那么就是指定这个脚本需要在哪个<code>平台|架构</code>下，才会被执行，并且支持模式匹配，例如<code>arm*</code>匹配所有arm架构。</p>
<p>当然也可以只设置平台，不设置架构，这样就是匹配指定平台下，执行脚本：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_build(&quot;windows&quot;, function (target)
        print(&quot;build for windows&quot;)
    end)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>一旦对这个target目标设置了自己的build过程，那么xmake默认的构建过程将不再被执行。<br>&lt;/p&gt;


</p>
<h5 id="target-on_build_file">target:on_build_file</h5>
<h6 id="-">自定义编译脚本, 实现单文件构建</h6>
<p>通过此接口，可以用来hook指定target内置的构建过程，替换每个源文件编译过程：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_build_file(function (target, sourcefile, opt)
        opt.origin(target, sourcefile, opt)
    end)
</code></pre>
<p>上面代码中的<code>opt.origin</code>存有内置的构建脚本，如果hook后还是想调用内置的构建脚本去编译源文件，那么直接继续调用<code>opt.origin</code>就行了。</p>
<p>如果不想重写内置的编译脚本，仅仅只是在编译前后添加一些自己的处理，其实用：<a href="#targetbefore_build_file">target.before_build_file</a>和<a href="#targetafter_build_file">target.after_build_file</a>会更加方便，不需要调用<code>opt.origin</code>。</p>
<h5 id="target-on_build_files">target:on_build_files</h5>
<h6 id="-">自定义编译脚本, 实现多文件构建</h6>
<p>通过此接口，可以用来hook指定target内置的构建过程，替换一批同类型源文件编译过程：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_build_files(function (target, sourcebatch, opt)
        opt.origin(target, sourcebatch, opt)
    end)
</code></pre>
<p>设置此接口后，对应源文件列表中文件，就不会出现在自定义的<a href="#targeton_build_file">target.on_build_file</a>了，因为这个是包含关系。</p>
<p>其中sourcebatch描述了这批同类型源文件：</p>
<ul>
<li><code>sourcebatch.sourcekind</code>: 获取这批源文件的类型，比如：cc, as, ..</li>
<li><code>sourcebatch.sourcefiles()</code>: 获取源文件列表</li>
<li><code>sourcebatch.objectfiles()</code>: 获取对象文件列表</li>
<li><code>sourcebatch.dependfiles()</code>: 获取对应依赖文件列表，存有源文件中编译依赖信息，例如：xxx.d</li>
</ul>
<p>上面代码中的<code>opt.origin</code>存有内置的构建脚本，如果hook后还是想调用内置的构建脚本去编译源文件，那么直接继续调用<code>opt.origin</code>就行了。</p>
<h5 id="target-on_clean">target:on_clean</h5>
<h6 id="-">自定义清理脚本</h6>
<p>覆盖target目标的<code>xmake [c|clean}</code>的清理操作，实现自定义清理过程。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 设置自定义清理脚本
    on_clean(function (target) 

        -- 仅删掉目标文件
        os.rm(target:targetfile())
    end)
</code></pre>
<p>一些target接口描述如下：</p>
<table>
<thead>
<tr>
<th>target接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>target:name()</td>
<td>获取目标名</td>
</tr>
<tr>
<td>target:targetfile()</td>
<td>获取目标文件路径</td>
</tr>
<tr>
<td>target:get(&quot;kind&quot;)</td>
<td>获取目标的构建类型</td>
</tr>
<tr>
<td>target:get(&quot;defines&quot;)</td>
<td>获取目标的宏定义</td>
</tr>
<tr>
<td>target:get(&quot;xxx&quot;)</td>
<td>其他通过 <code>set_/add_</code>接口设置的target信息，都可以通过此接口来获取</td>
</tr>
<tr>
<td>target:add(&quot;links&quot;, &quot;pthread&quot;)</td>
<td>添加目标设置</td>
</tr>
<tr>
<td>target:set(&quot;links&quot;, &quot;pthread&quot;, &quot;z&quot;)</td>
<td>覆写目标设置</td>
</tr>
<tr>
<td>target:deps()</td>
<td>获取目标的所有依赖目标</td>
</tr>
<tr>
<td>target:dep(&quot;depname&quot;)</td>
<td>获取指定的依赖目标</td>
</tr>
<tr>
<td>target:sourcebatches()</td>
<td>获取目标的所有源文件列表</td>
</tr>
</tbody>
</table>
<h5 id="target-on_package">target:on_package</h5>
<h6 id="-">自定义打包脚本</h6>
<p>覆盖target目标的<code>xmake [p|package}</code>的打包操作，实现自定义打包过程，如果你想对指定target打包成自己想要的格式，可以通过这个接口自定义它。</p>
<p>这个接口还是挺实用的，例如，编译完jni后，将生成的so，打包进apk包中。</p>
<pre><code class="lang-lua">-- 定义一个android app的测试demo
target(&quot;demo&quot;)

    -- 生成动态库：libdemo.so
    set_kind(&quot;shared&quot;)

    -- 设置对象的输出目录，可选
    set_objectdir(&quot;$(buildir)/.objs&quot;)

    -- 每次编译完的libdemo.so的生成目录，设置为app/libs/armeabi
    set_targetdir(&quot;libs/armeabi&quot;)

    -- 添加jni的代码文件
    add_files(&quot;jni/*.c&quot;)

    -- 设置自定义打包脚本，在使用xmake编译完libdemo.so后，执行xmake p进行打包
    -- 会自动使用ant将app编译成apk文件
    --
    on_package(function (target) 

        -- 使用ant编译app成apk文件，输出信息重定向到日志文件
        os.run(&quot;ant debug&quot;) 
    end)
</code></pre>
<h5 id="target-on_install">target:on_install</h5>
<h6 id="-">自定义安装脚本</h6>
<p>覆盖target目标的<code>xmake [i|install}</code>的安装操作，实现自定义安装过程。</p>
<p>例如，将生成的apk包，进行安装。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 设置自定义安装脚本，自动安装apk文件
    on_install(function (target) 

        -- 使用adb安装打包生成的apk文件
        os.run(&quot;adb install -r ./bin/Demo-debug.apk&quot;)
    end)
</code></pre>
<h5 id="target-on_uninstall">target:on_uninstall</h5>
<h6 id="-">自定义卸载脚本</h6>
<p>覆盖target目标的<code>xmake [u|uninstall}</code>的卸载操作，实现自定义卸载过程。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_uninstall(function (target) 
        ...
    end)
</code></pre>
<h5 id="target-on_run">target:on_run</h5>
<h6 id="-">自定义运行脚本</h6>
<p>覆盖target目标的<code>xmake [r|run}</code>的运行操作，实现自定义运行过程。</p>
<p>例如，运行安装好的apk程序：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息
    on_run(function (target) 

        os.run(&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;)
        os.run(&quot;adb logcat&quot;)
    end)
</code></pre>
<h5 id="target-before_link">target:before_link</h5>
<h6 id="-">在链接之前执行一些自定义脚本</h6>
<p>这个是在v2.2.7之后新加的接口，用于在链接之前增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    before_link(function (target) 
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-before_build">target:before_build</h5>
<h6 id="-">在构建之前执行一些自定义脚本</h6>
<p>并不会覆盖默认的构建操作，只是在构建之前增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    before_build(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-before_build_file">target:before_build_file</h5>
<h6 id="-">自定义编译前的脚本, 实现单文件构建</h6>
<p>通过此接口，可以用来hook指定target内置的构建过程，在每个源文件编译过程之前执行一些自定义脚本：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    before_build_file(function (target, sourcefile, opt)
    end)
</code></pre>
<h5 id="target-before_build_files">target:before_build_files</h5>
<h6 id="-">自定义编译前的脚本, 实现多文件构建</h6>
<p>通过此接口，可以用来hook指定target内置的构建过程，在一批同类型源文件编译过程之前执行一些自定义脚本：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    before_build_files(function (target, sourcebatch, opt)
    end)
</code></pre>
<h5 id="target-before_clean">target:before_clean</h5>
<h6 id="-">在清理之前执行一些自定义脚本</h6>
<p>并不会覆盖默认的清理操作，只是在清理之前增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    before_clean(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-before_package">target:before_package</h5>
<h6 id="-">在打包之前执行一些自定义脚本</h6>
<p>并不会覆盖默认的打包操作，只是在打包之前增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    before_package(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-before_install">target:before_install</h5>
<h6 id="-">在安装之前执行一些自定义脚本</h6>
<p>并不会覆盖默认的安装操作，只是在安装之前增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    before_install(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-before_uninstall">target:before_uninstall</h5>
<h6 id="-">在卸载之前执行一些自定义脚本</h6>
<p>并不会覆盖默认的卸载操作，只是在卸载之前增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    before_uninstall(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-before_run">target:before_run</h5>
<h6 id="-">在运行之前执行一些自定义脚本</h6>
<p>并不会覆盖默认的运行操作，只是在运行之前增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    before_run(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-after_link">target:after_link</h5>
<h6 id="-">在链接之后执行一些自定义脚本</h6>
<p>这个是在v2.2.7之后新加的接口，用于在链接之后增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    after_link(function (target) 
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-after_build">target:after_build</h5>
<h6 id="-">在构建之后执行一些自定义脚本</h6>
<p>并不会覆盖默认的构建操作，只是在构建之后增加一些自定义的操作。</p>
<p>例如，对于ios的越狱开发，构建完程序后，需要用<code>ldid</code>进行签名操作</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    after_build(function (target)
        os.run(&quot;ldid -S %s&quot;, target:targetfile())
    end)
</code></pre>
<h5 id="target-after_build_file">target:after_build_file</h5>
<h6 id="-">自定义编译前的脚本, 实现单文件构建</h6>
<p>通过此接口，可以用来hook指定target内置的构建过程，在每个源文件编译过程之后执行一些自定义脚本：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    after_build_file(function (target, sourcefile, opt)
    end)
</code></pre>
<h5 id="target-after_build_files">target:after_build_files</h5>
<h6 id="-">自定义编译前的脚本, 实现多文件构建</h6>
<p>通过此接口，可以用来hook指定target内置的构建过程，在一批同类型源文件编译过程之后执行一些自定义脚本：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    after_build_files(function (target, sourcebatch, opt)
    end)
</code></pre>
<h5 id="target-after_clean">target:after_clean</h5>
<h6 id="-">在清理之后执行一些自定义脚本</h6>
<p>并不会覆盖默认的清理操作，只是在清理之后增加一些自定义的操作。</p>
<p>一般可用于清理编译某target自动生成的一些额外的临时文件，这些文件xmake默认的清理规则可能没有清理到，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    after_clean(function (target)
        os.rm(&quot;$(buildir)/otherfiles&quot;)
    end)
</code></pre>
<h5 id="target-after_package">target:after_package</h5>
<h6 id="-">在打包之后执行一些自定义脚本</h6>
<p>并不会覆盖默认的打包操作，只是在打包之后增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    after_package(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-after_install">target:after_install</h5>
<h6 id="-">在安装之后执行一些自定义脚本</h6>
<p>并不会覆盖默认的安装操作，只是在安装之后增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    after_install(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-after_uninstall">target:after_uninstall</h5>
<h6 id="-">在卸载之后执行一些自定义脚本</h6>
<p>并不会覆盖默认的卸载操作，只是在卸载之后增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    after_uninstall(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-after_run">target:after_run</h5>
<h6 id="-">在运行之后执行一些自定义脚本</h6>
<p>并不会覆盖默认的运行操作，只是在运行之后增加一些自定义的操作。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    after_run(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h5 id="target-set_config_h">target:set_config_h</h5>
<h6 id="-">设置自动生成的配置头文件路径</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>2.2.5版本之后，此接口已废弃，请使用<a href="#targetadd_configfiles">add_configfiles</a>。<br>2.1.5版本之后，此接口已废弃，请使用<a href="#targetset_config_header">set_config_header</a>。<br>&lt;/p&gt;

</p>
<p>如果你想在xmake配置项目成功后，或者自动检测某个选项通过后，把检测的结果写入配置头文件，那么需要调用这个接口来启用自动生成<code>config.h</code>文件。</p>
<p>使用方式例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 启用并设置需要自动生成的config.h文件路径
    set_config_h(&quot;$(buildir)/config.h&quot;)

    -- 设置自动检测生成的宏开关的名字前缀
    set_config_h_prefix(&quot;TB_CONFIG&quot;)
</code></pre>
<p>当这个target中通过下面的这些接口，对这个target添加了相关的选项依赖、包依赖、接口依赖后，如果某依赖被启用，那么对应的一些宏定义配置，会自动写入被设置的<code>config.h</code>文件中去。</p>
<ul>
<li><a href="#targetadd_options">add_options</a></li>
<li><a href="#targetadd_packages">add_packages</a></li>
<li><a href="#targetadd_cfuncs">add_cfuncs</a></li>
<li><a href="#targetadd_cxxfuncs">add_cxxfuncs</a> </li>
</ul>
<p>这些接口，其实底层都用到了<a href="#option">option</a>选项中的一些检测设置，例如：</p>
<pre><code class="lang-lua">option(&quot;wchar&quot;)

    -- 添加对wchar_t类型的检测
    add_ctypes(&quot;wchar_t&quot;)

    -- 如果检测通过，自动生成 TB_CONFIG_TYPE_HAVE_WCHAR的宏开关到config.h
    add_defines_h(&quot;$(prefix)_TYPE_HAVE_WCHAR&quot;)

target(&quot;test&quot;)

    -- 启用头文件自动生成
    set_config_h(&quot;$(buildir)/config.h&quot;)
    set_config_h_prefix(&quot;TB_CONFIG&quot;)

    -- 添加对wchar选项的依赖关联，只有加上这个关联，wchar选项的检测结果才会写入指定的config.h中去
    add_options(&quot;wchar&quot;)
</code></pre>
<h5 id="target-set_config_h_prefix">target:set_config_h_prefix</h5>
<h6 id="-">设置自动生成的头文件中宏定义命名前缀</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>2.2.5版本之后，此接口已废弃，请使用<a href="#targetadd_configfiles">add_configfiles</a>。<br>2.1.5版本之后，此接口已废弃，请使用<a href="#targetset_config_header">set_config_header</a>。<br>&lt;/p&gt;

</p>
<p>具体使用见：<a href="#targetset_config_h">set_config_h</a></p>
<p>如果设置了：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_config_h_prefix(&quot;TB_CONFIG&quot;)
</code></pre>
<p>那么，选项中<code>add_defines_h(&quot;$(prefix)_TYPE_HAVE_WCHAR&quot;)</code>的$(prefix)会自动被替换成新的前缀值。</p>
<h5 id="target-set_config_header">target:set_config_header</h5>
<h6 id="-">设置自动生成的配置头文件路径和前缀</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>2.2.5版本之后，此接口已废弃，请使用<a href="#targetadd_configfiles">add_configfiles</a>。<br>&lt;/p&gt;

</p>
<p>此接口是<a href="#targetset_config_h">set_config_h</a>和<a href="#targetset_config_h_prefix">set_config_h_prefix</a>的升级版本，2.1.5之后支持。</p>
<p>如果你想在xmake配置项目成功后，或者自动检测某个选项通过后，把检测的结果写入配置头文件，那么需要调用这个接口来启用自动生成<code>config.h</code>文件。</p>
<p>使用方式例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_config_header(&quot;$(buildir)/config.h&quot;, {prefix = &quot;TB_CONFIG&quot;})
</code></pre>
<p>上面的代码，启用并设置需要自动生成的config.h文件路径，并且设置自动检测生成的宏开关的名字前缀：<code>TB_CONFIG</code>, 当然这个前缀的设置是可选的。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_config_header(&quot;$(buildir)/config.h&quot;)
</code></pre>
<p>如果不设置前缀，将会自动根据target名生成一个唯一字串。</p>
<p>2.1.8 之后版本，支持针对每个局部配置文件，单独设置版本号，优先于全局的<a href="#set_version">set_version</a>，例如：</p>
<pre><code class="lang-lua">    set_config_header(&quot;$(buildir)/config.h&quot;, {prefix = &quot;TB_CONFIG&quot;, version = &quot;2.1.8&quot;, build = &quot;%Y%m%d%H%M&quot;})
</code></pre>
<h6 id="-">通过内置的检测规则生成配置</h6>
<p>当这个target中通过下面的这些接口，对这个target添加了相关的选项依赖、包依赖、接口依赖后，如果某依赖被启用，那么对应的一些宏定义配置，会自动写入被设置的<code>config.h</code>文件中去。</p>
<ul>
<li><a href="#targetadd_options">add_options</a></li>
<li><a href="#targetadd_packages">add_packages</a></li>
<li><a href="#targetadd_cfunc">add_cfunc</a></li>
<li><a href="#targetadd_cfuncs">add_cfuncs</a></li>
<li><a href="#targetadd_cxxfuncs">add_cxxfuncs</a> </li>
</ul>
<h6 id="-">定制化检测和生成配置头文件</h6>
<p>这些接口，其实底层都用到了<a href="#option">option</a>选项中的一些检测设置，例如：</p>
<pre><code class="lang-lua">option(&quot;wchar&quot;)

    -- 添加对wchar_t类型的检测
    add_ctypes(&quot;wchar_t&quot;)

    -- 如果检测通过，自动生成 TB_CONFIG_TYPE_HAVE_WCHAR的宏开关到config.h
    add_defines_h(&quot;$(prefix)_TYPE_HAVE_WCHAR&quot;)

target(&quot;test&quot;)

    -- 启用头文件自动生成
    set_config_header(&quot;$(buildir)/config.h&quot;, {prefix = &quot;TB_CONFIG&quot;})

    -- 添加对wchar选项的依赖关联，只有加上这个关联，wchar选项的检测结果才会写入指定的config.h中去
    add_options(&quot;wchar&quot;)
</code></pre>
<p>甚至我们可以在<code>xmake.lua</code>中自己定义个function，针对option进行封装，提供更加定制化的检测和生成config.h的过程</p>
<p>例如：这里有个需求，我们想批量检测一些头文件，如果存在则在config.h里面输出<code>HAVE_LIMITS_H</code>这样的宏开关，我们可以这么写</p>
<pre><code class="lang-lua">function add_checking_to_config(...)

    -- 批量定义option检测规则，仅检测include文件
    local options = {}
    for _, header in ipairs({...}) do 
        local define = header:upper():gsub(&quot;[%./]&quot;, &quot;_&quot;)
        option(define)
            add_cincludes(header)
            add_defines_h(&quot;HAVE_&quot; .. define) -- 生成 HAVE_LIMITS_H 这样的宏开关到config.h 
        option_end()
        table.insert(options, define)
    end

    -- 定义个内置__config空目标，仅用于关联设置automatedconfig.h，以及对应的options检测规则
    -- 因为set_config_header在全局设置，会影响所有target，对每个target都会检测生成一次宏开关
    target(&quot;__config&quot;)
        set_kind(&quot;phony&quot;)
        set_config_header(&quot;includes/automatedconfig.h&quot;)
        add_options(options)
    target_end()
end

-- 添加一些头文件检测
add_checking_to_config(&quot;arpa/inet.h&quot;, &quot;limits.h&quot;, &quot;fcntl.h&quot;, &quot;xxxx.h&quot;)
</code></pre>
<h5 id="target-set_pcheader">target:set_pcheader</h5>
<h6 id="-c-">设置c预编译头文件</h6>
<p>xmake支持通过预编译头文件去加速c程序编译，目前支持的编译器有：gcc, clang和msvc。</p>
<p>使用方式如下：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_pcheader(&quot;header.h&quot;)
</code></pre>
<h5 id="target-set_pcxxheader">target:set_pcxxheader</h5>
<h6 id="-c-">设置c++预编译头文件</h6>
<p>xmake支持通过预编译头文件去加速c++程序编译，目前支持的编译器有：gcc, clang和msvc。</p>
<p>使用方式如下：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_pcxxheader(&quot;header.h&quot;)
</code></pre>
<h5 id="target-add_deps">target:add_deps</h5>
<h6 id="-">添加子工程目标依赖</h6>
<p>添加当前目标的依赖目标，编译的时候，会去优先编译依赖的目标，然后再编译当前目标。。。</p>
<pre><code class="lang-lua">target(&quot;test1&quot;)
    set_kind(&quot;static&quot;)
    set_files(&quot;*.c&quot;)

target(&quot;test2&quot;)
    set_kind(&quot;static&quot;)
    set_files(&quot;*.c&quot;)

target(&quot;demo&quot;)
    add_deps(&quot;test1&quot;, &quot;test2&quot;)
</code></pre>
<p>上面的例子，在编译目标demo的时候，需要先编译test1, test2目标，因为demo会去用到他们</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>target会自动继承依赖目标中的配置和属性，不需要额外调用<code>add_links</code>, <code>add_linkdirs</code>和<code>add_rpathdirs</code>等接口去关联依赖目标了。<br>&lt;/p&gt;

</p>
<p>并且继承关系是支持级联的，例如：</p>
<pre><code class="lang-lua">target(&quot;library1&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;*.c&quot;)
    add_includedirs(&quot;inc&quot;) -- 默认私有头文件目录不会被继承
    add_includedirs(&quot;inc1&quot;, {public = true}) -- 此处的头文件相关目录也会被继承

target(&quot;library2&quot;)
    set_kind(&quot;static&quot;)
    add_deps(&quot;library1&quot;)
    add_files(&quot;*.c&quot;)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_deps(&quot;library2&quot;)
</code></pre>
<p>如果我们不想继承依赖target的任何配置，如何操作呢？</p>
<pre><code class="lang-lua">add_deps(&quot;dep1&quot;, &quot;dep2&quot;, {inherit = false})
</code></pre>
<p>通过显式设置inherit配置，来告诉xmake，这两个依赖的配置是否需要被继承，如果不设置，默认就是启用继承的。</p>
<p>2.2.5版本之后，可通过 <code>add_includedirs(&quot;inc1&quot;, {public = true})</code>, 设置public为true, 将includedirs的设置公开给其他依赖的子target继承。 </p>
<p>目前对于target的编译链接flags相关接口设置，都是支持继承属性的，可以人为控制是否需要导出给其他target来依赖继承，目前支持的属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>默认设置，作为当前target的私有配置，不会被依赖的其他target所继承</td>
</tr>
<tr>
<td>public</td>
<td>公有配置，当前target，依赖的子target都会被设置</td>
</tr>
<tr>
<td>interface</td>
<td>接口设置，仅被依赖的子target所继承设置，当前target不参与</td>
</tr>
</tbody>
</table>
<p>对于这块的详细说明，可以看下：<a href="https://github.com/xmake-io/xmake/issues/368">https://github.com/xmake-io/xmake/issues/368</a></p>
<h5 id="target-add_links">target:add_links</h5>
<h6 id="-">添加链接库名</h6>
<p>为当前目标添加链接库，一般这个要与<a href="#targetadd_linkdirs">add_linkdirs</a>配对使用。</p>
<pre><code class="lang-lua">target(&quot;demo&quot;)

    -- 添加对libtest.a的链接，相当于 -ltest 
    add_links(&quot;test&quot;)

    -- 添加链接搜索目录
    add_linkdirs(&quot;$(buildir)/lib&quot;)
</code></pre>
<h5 id="target-add_syslinks">target:add_syslinks</h5>
<h6 id="-">添加系统链接库名</h6>
<p>这个接口使用上跟<a href="#targetadd_links">add_links</a>类似，唯一的区别就是，通过这个接口添加的链接库顺序在所有<code>add_links</code>之后。</p>
<p>因此主要用于添加系统库依赖，因为系统库的链接顺序是非常靠后的，例如：</p>
<pre><code class="lang-lua">add_syslinks(&quot;pthread&quot;, &quot;m&quot;, &quot;dl&quot;)
target(&quot;demo&quot;)
    add_links(&quot;a&quot;, &quot;b&quot;)
    add_linkdirs(&quot;$(buildir)/lib&quot;)
</code></pre>
<p>上面的配置，即使<code>add_syslinks</code>被优先提前设置了，但最后的链接顺序依然是：<code>-la -lb -lpthread -lm -ldl</code></p>
<h5 id="target-add_files">target:add_files</h5>
<h6 id="-">添加源代码文件</h6>
<p>用于添加目标工程的源文件，甚至库文件，目前支持的一些文件类型：</p>
<table>
<thead>
<tr>
<th>支持的源文件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.c/.cpp/.cc/.cxx</td>
<td>c++文件</td>
</tr>
<tr>
<td>.s/.S/.asm</td>
<td>汇编文件</td>
</tr>
<tr>
<td>.m/.mm</td>
<td>objc文件</td>
</tr>
<tr>
<td>.swift</td>
<td>swift文件</td>
</tr>
<tr>
<td>.go</td>
<td>golang文件</td>
</tr>
<tr>
<td>.o/.obj</td>
<td>对象文件</td>
</tr>
<tr>
<td>.a/.lib</td>
<td>静态库文件，会自动合并库到目标程序</td>
</tr>
<tr>
<td>.rc</td>
<td>msvc的资源文件</td>
</tr>
</tbody>
</table>
<p>其中通配符<code>*</code>表示匹配当前目录下文件，而<code>**</code>则匹配多级目录下的文件。</p>
<p>例如：</p>
<pre><code class="lang-lua">add_files(&quot;src/test_*.c&quot;)
add_files(&quot;src/xxx/**.cpp&quot;)
add_files(&quot;src/asm/*.S&quot;, &quot;src/objc/**/hello.m&quot;)
</code></pre>
<p><code>add_files</code>的使用其实是相当灵活方便的，其匹配模式借鉴了premake的风格，但是又对其进行了改善和增强。</p>
<p>使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。</p>
<p>例如：</p>
<pre><code class="lang-lua">-- 递归添加src下的所有c文件，但是不包括src/impl/下的所有c文件
add_files(&quot;src/**.c|impl/*.c&quot;)

-- 添加src下的所有cpp文件，但是不包括src/test.cpp、src/hello.cpp以及src下所有带xx_前缀的cpp文件
add_files(&quot;src/*.cpp|test.cpp|hello.cpp|xx_*.cpp&quot;)
</code></pre>
<p>其中分隔符<code>|</code>之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用<code>|</code>分割就行了。。</p>
<p>添加文件的时候支持过滤一些文件的一个好处就是，可以为后续根据不同开关逻辑添加文件提供基础。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>为了使得描述上更加的精简，<code>|</code>之后的过滤描述都是基于起一个模式：<code>src/*.cpp</code> 中<code>*</code>之前的目录为基础的。<br>所以上面的例子后面过滤的都是在src下的文件，这个是要注意的。<br>&lt;/p&gt;

</p>
<p>2.1.6版本之后，对<code>add_files</code>进行了改进，支持基于files更细粒度的编译选项控制，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_defines(&quot;TEST1&quot;)
    add_files(&quot;src/*.c&quot;)
    add_files(&quot;test/*.c&quot;, &quot;test2/test2.c&quot;, {defines = &quot;TEST2&quot;, languages = &quot;c99&quot;, includedirs = &quot;.&quot;, cflags = &quot;-O0&quot;})
</code></pre>
<p>可以在<code>add_files</code>的最后一个参数，传入一个配置table，去控制指定files的编译选项，里面的配置参数跟target的一致，并且这些文件还会继承target的通用配置<code>-DTEST1</code>。</p>
<p>2.1.9版本之后，支持添加未知的代码文件，通过设置rule自定义规则，实现这些文件的自定义构建，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    -- ...
    add_files(&quot;src/test/*.md&quot;, {rule = &quot;markdown&quot;})
</code></pre>
<p>关于自定义构建规则的使用说明，详细见：<a href="#构建规则">构建规则</a>。</p>
<p>并且在2.1.9版本之后，可以通过force参数来强制禁用cxflags,cflags等编译选项的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p>
<pre><code class="lang-lua">add_files(&quot;src/*.c&quot;, {force = {cxflags = &quot;-DTEST&quot;, mflags = &quot;-framework xxx&quot;}})
</code></pre>
<h5 id="target-del_files">target:del_files</h5>
<h6 id="-">从前面的源代码文件列表中删除指定文件</h6>
<p>通过此接口，可以从前面<a href="targetadd_files">add_files</a>接口添加的文件列表中，删除指定的文件，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_files(&quot;src/*.c&quot;)
    del_files(&quot;src/test.c&quot;)
</code></pre>
<p>上面的例子，可以从<code>src</code>目录下添加除<code>test.c</code>以外的所有文件，当然这个也可以通过<code>add_files(&quot;src/*.c|test.c&quot;)</code>来达到相同的目的，但是这种方式更加灵活。</p>
<p>例如，我们可以条件判断来控制删除哪些文件，并且此接口也支持<a href="targetadd_files">add_files</a>的匹配模式，过滤模式，进行批量移除。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_files(&quot;src/**.c&quot;)
    del_files(&quot;src/test*.c&quot;)
    del_files(&quot;src/subdir/*.c|xxx.c&quot;)
    if is_plat(&quot;iphoneos&quot;) then
        add_files(&quot;xxx.m&quot;)
    end
</code></pre>
<p>通过上面的例子，我们可以看出<code>add_files</code>和<code>del_files</code>是根据调用顺序，进行顺序添加和删除的，并且通过<code>del_files(&quot;src/subdir/*.c|xxx.c&quot;)</code>删除一批文件，<br>并且排除<code>src/subdir/xxx.c</code>（就是说，不删除这个文件）。</p>
<h5 id="target-add_headers">target:add_headers</h5>
<h6 id="-">添加安装的头文件</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>注，2.2.5版本之后，此接口已废弃，请使用<a href="#targetadd_headerfiles">add_headerfiles</a>代替。<br>&lt;/p&gt;

</p>
<p>安装指定的头文件到build目录，如果设置了<a href="#targetset_headerdir">set_headerdir</a>， 则输出到指定目录。</p>
<p>安装规则的语法跟<a href="#targetadd_files">add_files</a>类似，例如：</p>
<pre><code class="lang-lua">    -- 安装tbox目录下所有的头文件（忽略impl目录下的文件），并且按()指定部分作为相对路径，进行安装
    add_headers(&quot;../(tbox/**.h)|**/impl/**.h&quot;)
</code></pre>
<h5 id="target-add_linkdirs">target:add_linkdirs</h5>
<h6 id="-">添加链接库搜索目录</h6>
<p>设置链接库的搜索目录，这个接口的使用方式如下：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_linkdirs(&quot;$(buildir)/lib&quot;)
</code></pre>
<p>此接口相当于gcc的<code>-Lxxx</code>链接选项。</p>
<p>一般他是与<a href="#targetadd_links">add_links</a>配合使用的，当然也可以直接通过<a href="#targetadd_ldflags">add_ldflags</a>或者<a href="#targetadd_shflags">add_shflags</a>接口来添加，也是可以的。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>如果不想在工程中写死，可以通过：<code>xmake f --linkdirs=xxx</code>或者<code>xmake f --ldflags=&quot;-L/xxx&quot;</code>的方式来设置，当然这种手动设置的目录搜索优先级更高。<br>&lt;/p&gt;

</p>
<h5 id="target-add_rpathdirs">target:add_rpathdirs</h5>
<h6 id="-">添加程序运行时动态库的加载搜索目录</h6>
<p>通过<a href="#targetadd_linkdirs">add_linkdirs</a>设置动态库的链接搜索目录后，程序被正常链接，但是在linux平台想要正常运行编译后的程序，会报加载动态库失败。</p>
<p>因为没找到动态库的加载目录，想要正常运行依赖动态库的程序，需要设置<code>LD_LIBRARY_PATH</code>环境变量，指定需要加载的动态库目录。</p>
<p>但是这种方式是全局的，影响太广，更好的方式是通过<code>-rpath=xxx</code>的链接器选项，在链接程序的时候设置好需要加载的动态库搜索路径，而xmake对其进行了封装，通过<code>add_rpathdirs</code>更好的处理跨平台问题。</p>
<p>具体使用如下：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_linkdirs(&quot;$(buildir)/lib&quot;)
    add_rpathdirs(&quot;$(buildir)/lib&quot;)
</code></pre>
<p>只需要在链接的时候，在设置下rpath目录就好了，虽然也可以通过<code>add_ldflags(&quot;-Wl,-rpath=xxx&quot;)</code>达到相同的目的，但是这个接口更加通用。</p>
<p>内部会对不同平台进行处理，像在macOS下，是不需要<code>-rpath</code>设置的，也是可以正常加载运行程序，因此针对这个平台，xmake内部会直接忽略器设置，避免链接报错。</p>
<p>而在为dlang程序进行动态库链接时，xmake会自动处理成<code>-L-rpath=xxx</code>来传入dlang的链接器，这样就避免了直接使用<code>add_ldflags</code>需要自己判断和处理不同平台和编译器问题。</p>
<p>2.1.7版本对这个接口进行了改进，支持：<code>@loader_path</code>, <code>@executable_path</code> 和 <code>$ORIGIN</code>的内置变量，来指定程序的加载目录，它们的效果基本上是一样的，主要是为了同时兼容macho, elf。</p>
<p>例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_linkdirs(&quot;$(buildir)/lib&quot;)
    add_rpathdirs(&quot;@loader_path/lib&quot;)
</code></pre>
<p>指定test程序加载当前执行目录下<code>lib/*.[so|dylib]</code>的动态库文件，这将有助于提升程序的可移植性，不用写死绝对路径和相对路径，导致程序和目录切换引起程序加载动态库失败。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>需要注意的是，在macos下，要想add_rpathdirs设置生效，需要对dylib做一些预处理，添加<code>@rpath/xxx</code>路径设置：<br><code>$install_name_tool -add_rpath @rpath/libxxx.dylib xxx/libxxx.dylib</code><br>我们也可以通过<code>otool -L libxxx.dylib</code>查看是否存在带@rpath的路径<br>&lt;/p&gt;

</p>
<h5 id="target-add_includedirs">target:add_includedirs</h5>
<h6 id="-">添加头文件搜索目录</h6>
<p>设置头文件的搜索目录，这个接口的使用方式如下：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_includedirs(&quot;$(buildir)/include&quot;)
</code></pre>
<p>当然也可以直接通过<a href="#targetadd_cxflags">add_cxflags</a>或者<a href="#targetadd_mxflags">add_mxflags</a>等接口来设置，也是可以的。</p>
<p>2.2.5之后，可通过额外的<code>{public|interface = true}</code>属性设置，将includedirs导出给依赖的子target，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;static&quot;)
    add_includedirs(&quot;src/include&quot;) -- 仅对当前target生效
    add_includedirs(&quot;$(buildir)/include&quot;, {public = true})，当前target和子target都会被设置

target(&quot;demo&quot;)
    set_kind(&quot;binary&quot;)
    add_deps(&quot;test&quot;)
</code></pre>
<p>更多关于这块的说明，见：<a href="#targetadd_deps">add_deps</a></p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>如果不想在工程中写死，可以通过：<code>xmake f --includedirs=xxx</code>或者<code>xmake f --cxflags=&quot;-I/xxx&quot;</code>的方式来设置，当然这种手动设置的目录搜索优先级更高。<br>&lt;/p&gt;

</p>
<h5 id="target-add_defines">target:add_defines</h5>
<h6 id="-">添加宏定义</h6>
<pre><code class="lang-lua">add_defines(&quot;DEBUG&quot;, &quot;TEST=0&quot;, &quot;TEST2=\&quot;hello\&quot;&quot;)
</code></pre>
<p>相当于设置了编译选项：</p>
<pre><code>-DDEBUG -DTEST=0 -DTEST2=\&quot;hello\&quot;
</code></pre><h5 id="target-add_undefines">target:add_undefines</h5>
<h6 id="-">取消宏定义</h6>
<pre><code class="lang-lua">add_undefines(&quot;DEBUG&quot;)
</code></pre>
<p>相当于设置了编译选项：<code>-UDEBUG</code></p>
<p>在代码中相当于：<code>#undef DEBUG</code></p>
<h5 id="target-add_defines_h">target:add_defines_h</h5>
<h6 id="-">添加宏定义到头文件</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>2.2.5版本之后，此接口已废弃，请使用<a href="#targetadd_configfiles">add_configfiles</a>。<br>&lt;/p&gt;

</p>
<p>添加宏定义到<code>config.h</code>配置文件，<code>config.h</code>的设置，可参考<a href="#targetset_config_h">set_config_h</a>接口。</p>
<h5 id="target-add_undefines_h">target:add_undefines_h</h5>
<h6 id="-">取消宏定义到头文件</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>2.2.5版本之后，此接口已废弃，请使用<a href="#targetadd_configfiles">add_configfiles</a>。<br>&lt;/p&gt;

</p>
<p>在<code>config.h</code>配置文件中通过<code>undef</code>禁用宏定义，<code>config.h</code>的设置，可参考<a href="#targetset_config_h">set_config_h</a>接口。</p>
<h5 id="target-add_cflags">target:add_cflags</h5>
<h6 id="-c-">添加c编译选项</h6>
<p>仅对c代码添加编译选项</p>
<pre><code class="lang-lua">add_cflags(&quot;-g&quot;, &quot;-O2&quot;, &quot;-DDEBUG&quot;)
</code></pre>
<p>&lt;p class=&quot;warn&quot;&gt;<br>所有选项值都基于gcc的定义为标准，如果其他编译器不兼容（例如：vc），xmake会自动内部将其转换成对应编译器支持的选项值。<br>用户无需操心其兼容性，如果其他编译器没有对应的匹配值，那么xmake会自动忽略器设置。<br>&lt;/p&gt;


</p>
<p>在2.1.9版本之后，可以通过force参数来强制禁用flags的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p>
<pre><code class="lang-lua">add_cflags(&quot;-g&quot;, &quot;-O2&quot;, {force = true})
</code></pre>
<h5 id="target-add_cxflags">target:add_cxflags</h5>
<h6 id="-c-c-">添加c/c++编译选项</h6>
<p>同时对c/c++代码添加编译选项</p>
<h5 id="target-add_cxxflags">target:add_cxxflags</h5>
<h6 id="-c-">添加c++编译选项</h6>
<p>仅对c++代码添加编译选项</p>
<h5 id="target-add_mflags">target:add_mflags</h5>
<h6 id="-objc-">添加objc编译选项</h6>
<p>仅对objc代码添加编译选项</p>
<pre><code class="lang-lua">add_mflags(&quot;-g&quot;, &quot;-O2&quot;, &quot;-DDEBUG&quot;)
</code></pre>
<p>在2.1.9版本之后，可以通过force参数来强制禁用flags的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p>
<pre><code class="lang-lua">add_mflags(&quot;-g&quot;, &quot;-O2&quot;, {force = true})
</code></pre>
<h5 id="target-add_mxflags">target:add_mxflags</h5>
<h6 id="-objc-objc-">添加objc/objc++编译选项</h6>
<p>同时对objc/objc++代码添加编译选项</p>
<pre><code class="lang-lua">add_mxflags(&quot;-framework CoreFoundation&quot;)
</code></pre>
<h5 id="target-add_mxxflags">target:add_mxxflags</h5>
<h6 id="-objc-">添加objc++编译选项</h6>
<p>仅对objc++代码添加编译选项</p>
<pre><code class="lang-lua">add_mxxflags(&quot;-framework CoreFoundation&quot;)
</code></pre>
<h5 id="target-add_scflags">target:add_scflags</h5>
<h6 id="-swift-">添加swift编译选项</h6>
<p>对swift代码添加编译选项</p>
<pre><code class="lang-lua">add_scflags(&quot;xxx&quot;)
</code></pre>
<h5 id="target-add_asflags">target:add_asflags</h5>
<h6 id="-">添加汇编编译选项</h6>
<p>对汇编代码添加编译选项</p>
<pre><code class="lang-lua">add_asflags(&quot;xxx&quot;)
</code></pre>
<h5 id="target-add_gcflags">target:add_gcflags</h5>
<h6 id="-go-">添加go编译选项</h6>
<p>对golang代码添加编译选项</p>
<pre><code class="lang-lua">add_gcflags(&quot;xxx&quot;)
</code></pre>
<h5 id="target-add_dcflags">target:add_dcflags</h5>
<h6 id="-dlang-">添加dlang编译选项</h6>
<p>对dlang代码添加编译选项</p>
<pre><code class="lang-lua">add_dcflags(&quot;xxx&quot;)
</code></pre>
<h5 id="target-add_rcflags">target:add_rcflags</h5>
<h6 id="-rust-">添加rust编译选项</h6>
<p>对rust代码添加编译选项</p>
<pre><code class="lang-lua">add_rcflags(&quot;xxx&quot;)
</code></pre>
<h5 id="target-add_cuflags">target:add_cuflags</h5>
<h6 id="-cuda-">添加cuda编译选项</h6>
<p>对cuda代码添加编译选项</p>
<pre><code class="lang-lua">add_cuflags(&quot;-gencode arch=compute_30,code=sm_30&quot;)
</code></pre>
<h5 id="target-add_culdflags">target:add_culdflags</h5>
<h6 id="-cuda-">添加cuda设备链接选项</h6>
<p>v2.2.7之后，cuda默认构建会使用device-link，这个阶段如果要设置一些链接flags，则可以通过这个接口来设置。<br>而最终的程序链接，会使用ldflags，不会调用nvcc，直接通过gcc/clang等c/c++链接器来链接。</p>
<p>关于device-link的说明，可以参考：<a href="https://devblogs.nvidia.com/separate-compilation-linking-cuda-device-code/">https://devblogs.nvidia.com/separate-compilation-linking-cuda-device-code/</a></p>
<pre><code class="lang-lua">add_culdflags(&quot;-gencode arch=compute_30,code=sm_30&quot;)
</code></pre>
<h5 id="target-add_ldflags">target:add_ldflags</h5>
<h6 id="-">添加链接选项</h6>
<p>添加静态链接选项</p>
<pre><code class="lang-lua">add_ldflags(&quot;-L/xxx&quot;, &quot;-lxxx&quot;)
</code></pre>
<h5 id="target-add_arflags">target:add_arflags</h5>
<h6 id="-">添加静态库归档选项</h6>
<p>影响对静态库的生成</p>
<pre><code class="lang-lua">add_arflags(&quot;xxx&quot;)
</code></pre>
<h5 id="target-add_shflags">target:add_shflags</h5>
<h6 id="-">添加动态库链接选项</h6>
<p>影响对动态库的生成</p>
<pre><code class="lang-lua">add_shflags(&quot;xxx&quot;)
</code></pre>
<h5 id="target-add_cfunc">target:add_cfunc</h5>
<h6 id="-c-">添加单个c库函数检测</h6>
<p>与<a href="#targetadd_cfuncs">add_cfuncs</a>类似，只是仅对单个函数接口进行设置，并且仅对<code>target</code>域生效，<code>option</code>中不存在此接口。</p>
<p>此接口的目的主要是为了在<code>config.h</code>中更加高度定制化的生成宏开关，例如：</p>
<pre><code class="lang-lua">target(&quot;demo&quot;)

    -- 设置和启用config.h
    set_config_header(&quot;$(buildir)/config.h&quot;, {prefix = &quot;TEST&quot;})

    -- 仅通过参数一设置模块名前缀
    add_cfunc(&quot;libc&quot;,       nil,        nil,        {&quot;sys/select.h&quot;},   &quot;select&quot;)

    -- 通过参数三，设置同时检测链接库：libpthread.a
    add_cfunc(&quot;pthread&quot;,    nil,        &quot;pthread&quot;,  &quot;pthread.h&quot;,        &quot;pthread_create&quot;)

    -- 通过参数二设置接口别名
    add_cfunc(nil,          &quot;PTHREAD&quot;,  nil,        &quot;pthread.h&quot;,        &quot;pthread_create&quot;)
</code></pre>
<p>生成的结果如下：</p>
<pre><code class="lang-c">#ifndef TEST_H
#define TEST_H

// 宏命名规则：$(prefix)前缀 _ 模块名（如果非nil）_ HAVE _ 接口名或者别名 （大写）
#define TEST_LIBC_HAVE_SELECT 1
#define TEST_PTHREAD_HAVE_PTHREAD_CREATE 1
#define TEST_HAVE_PTHREAD 1

#endif
</code></pre>
<p>如果要更加灵活的函数检测，可以通过<a href="#detect-has_cfuncs">lib.detect.has_cfuncs</a>在自定义脚本中实现。</p>
<h5 id="target-add_cxxfunc">target:add_cxxfunc</h5>
<h6 id="-c-">添加单个c++库函数检测</h6>
<p>与<a href="#targetadd_cfunc">add_cfunc</a>类似，只是检测的函数接口是c++函数。</p>
<h5 id="target-add_cfuncs">target:add_cfuncs</h5>
<h6 id="-c-">添加c库函数检测</h6>
<p>&lt;p class=&quot;warn&quot;&gt;<br>此接口是<code>target</code>和<code>option</code>共用的接口，但是接口行为稍有不同。<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口域</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>头文件、链接库和函数接口同时指定</td>
<td><code>add_cfuncs(&quot;libc&quot;, nil, {&quot;signal.h&quot;, &quot;setjmp.h&quot;}, &quot;signal&quot;, &quot;setjmp&quot;, &quot;sigsetjmp{sigjmp_buf buf; sigsetjmp(buf, 0);}&quot;, &quot;kill&quot;)</code></td>
</tr>
<tr>
<td>option</td>
<td>仅指定函数接口，头文件依赖<a href="#targetadd_cincludes">add_cincludes</a>等独立接口</td>
<td><code>add_cincludes(&quot;setjmp.h&quot;)</code> <code>add_cfuncs(&quot;sigsetjmp&quot;)</code></td>
</tr>
</tbody>
</table>
<p>对于<code>option</code>，这个接口的使用很简单，跟<a href="#targetadd_cincludes">add_cincludes</a>类似，例如：</p>
<pre><code class="lang-lua">option(&quot;setjmp&quot;)
    set_default(false)
    add_cincludes(&quot;setjmp.h&quot;)
    add_cfuncs(&quot;sigsetjmp&quot;, &quot;setjmp&quot;)
    add_defines(&quot;HAVE_SETJMP&quot;)

target(&quot;test&quot;)
    add_options(&quot;setjmp&quot;)
</code></pre>
<p>此选项检测是否存在<code>setjmp</code>的一些接口，如果检测通过那么<code>test</code>目标程序将会加上<code>HAVE_SETJMP</code>的宏定义。</p>
<p>&lt;p class=&quot;warn&quot;&gt;<br>需要注意的是，在<code>option</code>中使用此接口检测依赖函数，需要同时使用独立的<a href="#targetadd_cincludes">add_cincludes</a>增加头文件搜索路径，指定<a href="#targetadd_links">add_links</a>链接库（可选），否则检测不到指定函数。<br>&lt;br&gt;&lt;br&gt;<br>并且某些头文件接口是通过宏开关分别定义的，那么检测的时候最好通过<a href="#targetadd_defines">add_defines</a>带上依赖的宏开关。<br>&lt;/p&gt;

</p>
<p>对于<code>target</code>，此接口可以同时设置：依赖的头文件、依赖的链接模块、依赖的函数接口，保证检测环境的完整性，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 添加libc库接口相关检测
    -- 第一个参数：模块名，用于最后的宏定义前缀生成
    -- 第二个参数：链接库
    -- 第三个参数：头文件
    -- 之后的都是函数接口列表
    add_cfuncs(&quot;libc&quot;, nil,         {&quot;signal.h&quot;, &quot;setjmp.h&quot;},           &quot;signal&quot;, &quot;setjmp&quot;, &quot;sigsetjmp{sigjmp_buf buf; sigsetjmp(buf, 0);}&quot;, &quot;kill&quot;)

    -- 添加pthread库接口相关检测，同时指定需要检测`libpthread.a`链接库是否存在
    add_cfuncs(&quot;posix&quot;, &quot;pthread&quot;,  &quot;pthread.h&quot;,                        &quot;pthread_mutex_init&quot;,
                                                                        &quot;pthread_create&quot;, 
                                                                        &quot;pthread_setspecific&quot;, 
                                                                        &quot;pthread_getspecific&quot;,
                                                                        &quot;pthread_key_create&quot;,
                                                                        &quot;pthread_key_delete&quot;)
</code></pre>
<p>设置<code>test</code>目标，依赖这些接口，构建时会预先检测他们，并且如果通过<a href="#targetset_config_h">set_config_h</a>接口设置的自动生成头文件：<code>config.h</code></p>
<p>那么，检测结果会自动加到对应的<code>config.h</code>上去，这也是<code>option</code>没有的功能，例如：</p>
<pre><code class="lang-c">#define TB_CONFIG_LIBC_HAVE_SIGNAL 1
#define TB_CONFIG_LIBC_HAVE_SETJMP 1
#define TB_CONFIG_LIBC_HAVE_SIGSETJMP 1
#define TB_CONFIG_LIBC_HAVE_KILL 1

#define TB_CONFIG_POSIX_HAVE_PTHREAD_MUTEX_INIT 1
#define TB_CONFIG_POSIX_HAVE_PTHREAD_CREATE 1
#define TB_CONFIG_POSIX_HAVE_PTHREAD_SETSPECIFIC 1
#define TB_CONFIG_POSIX_HAVE_PTHREAD_GETSPECIFIC 1
#define TB_CONFIG_POSIX_HAVE_PTHREAD_KEY_CREATE 1
#define TB_CONFIG_POSIX_HAVE_PTHREAD_KEY_DELETE 1
</code></pre>
<p>由于，不同头文件中，函数的定义方式不完全相同，例如：宏函数、静态内联函数、extern函数等。</p>
<p>要想完全检测成功，检测语法上需要一定程度的灵活性，下面是一些语法规则：</p>
<table>
<thead>
<tr>
<th>检测语法</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>纯函数名</td>
<td><code>sigsetjmp</code></td>
</tr>
<tr>
<td>单行调用</td>
<td><code>sigsetjmp((void*)0, 0)</code></td>
</tr>
<tr>
<td>函数块调用</td>
<td><code>sigsetjmp{sigsetjmp((void*)0, 0);}</code></td>
</tr>
<tr>
<td>函数块 + 变量</td>
<td><code>sigsetjmp{int a = 0; sigsetjmp((void*)a, a);}</code></td>
</tr>
</tbody>
</table>
<h5 id="target-add_cxxfuncs">target:add_cxxfuncs</h5>
<h6 id="-c-">添加c++库函数检测</h6>
<p>与<a href="#targetadd_cfuncs">add_cfuncs</a>类似，只是检测的函数接口是c++函数。</p>
<h5 id="target-add_options">target:add_options</h5>
<h6 id="-">添加关联选项</h6>
<p>这个接口跟<a href="#targetset_options">set_options</a>类似，唯一的区别就是，此处是追加选项，而<a href="#targetset_options">set_options</a>每次设置会覆盖先前的设置。</p>
<h5 id="target-add_packages">target:add_packages</h5>
<h6 id="-">添加包依赖</h6>
<p>在target作用域中，添加集成包依赖，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_packages(&quot;zlib&quot;, &quot;polarssl&quot;, &quot;pcre&quot;, &quot;mysql&quot;)
</code></pre>
<p>这样，在编译test目标时，如果这个包存在的，将会自动追加包里面的宏定义、头文件搜索路径、链接库目录，也会自动链接包中所有库。</p>
<p>用户不再需要自己单独调用<a href="#targetadd_links">add_links</a>，<a href="#targetadd_includedirs">add_includedirs</a>, <a href="#targetadd_ldflags">add_ldflags</a>等接口，来配置依赖库链接了。</p>
<p>对于如何设置包搜索目录，可参考：<a href="#targetadd_packagedirs">add_packagedirs</a> 接口</p>
<p>而在v2.2.2版本之后，此接口也同时支持远程依赖包管理中<a href="#add_requires">add_requires</a>定义的包。</p>
<pre><code class="lang-lua">add_requires(&quot;zlib&quot;, &quot;polarssl&quot;)
target(&quot;test&quot;)
    add_packages(&quot;zlib&quot;, &quot;polarssl&quot;)
</code></pre>
<p>v2.2.3之后，还支持覆写内置的links，控制实际链接的库：</p>
<pre><code class="lang-lua">-- 默认会有 ncurses, panel, form等links
add_requires(&quot;ncurses&quot;) 

target(&quot;test&quot;)

    -- 显示指定，只使用ncurses一个链接库
    add_packages(&quot;ncurses&quot;, {links = &quot;ncurses&quot;})
</code></pre>
<p>或者干脆禁用links，只使用头文件：</p>
<pre><code class="lang-lua">add_requires(&quot;lua&quot;)
target(&quot;test&quot;)
    add_packages(&quot;lua&quot;, {links = {}})
</code></pre>
<h5 id="target-add_languages">target:add_languages</h5>
<h6 id="-">添加语言标准</h6>
<p>与<a href="#targetset_languages">set_languages</a>类似，唯一区别是这个接口不会覆盖掉之前的设置，而是追加设置。</p>
<h5 id="target-add_vectorexts">target:add_vectorexts</h5>
<h6 id="-">添加向量扩展指令</h6>
<p>添加扩展指令优化选项，目前支持以下几种扩展指令集：</p>
<pre><code class="lang-lua">add_vectorexts(&quot;mmx&quot;)
add_vectorexts(&quot;neon&quot;)
add_vectorexts(&quot;avx&quot;, &quot;avx2&quot;)
add_vectorexts(&quot;sse&quot;, &quot;sse2&quot;, &quot;sse3&quot;, &quot;ssse3&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>如果当前设置的指令集编译器不支持，xmake会自动忽略掉，所以不需要用户手动去判断维护，只需要将你需要的指令集全部设置上就行了。<br>&lt;/p&gt;

</p>
<h5 id="target-add_frameworks">target:add_frameworks</h5>
<h6 id="-">添加链接框架</h6>
<p>目前主要用于<code>ios</code>和<code>macosx</code>平台的<code>objc</code>和<code>swift</code>程序，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_frameworks(&quot;Foundation&quot;, &quot;CoreFoundation&quot;)
</code></pre>
<p>当然也可以使用<a href="#targetadd_mxflags">add_mxflags</a>和<a href="#targetadd_ldflags">add_ldflags</a>来设置，不过比较繁琐，不建议这样设置。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_mxflags(&quot;-framework Foundation&quot;, &quot;-framework CoreFoundation&quot;)
    add_ldflags(&quot;-framework Foundation&quot;, &quot;-framework CoreFoundation&quot;)
</code></pre>
<p>如果不是这两个平台，这些设置将会被忽略。</p>
<h5 id="target-add_frameworkdirs">target:add_frameworkdirs</h5>
<h6 id="-">添加链接框架搜索目录</h6>
<p>对于一些第三方framework，那么仅仅通过<a href="#targetadd_frameworks">add_frameworks</a>是没法找到的，还需要通过这个接口来添加搜索目录。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_frameworks(&quot;MyFramework&quot;)
    add_frameworkdirs(&quot;/tmp/frameworkdir&quot;, &quot;/tmp/frameworkdir2&quot;)
</code></pre>
<h5 id="target-set_tools">target:set_tools</h5>
<h6 id="-">设置编译链接工具链</h6>
<p>对于<code>add_files(&quot;*.c&quot;)</code>添加的源码文件，默认都是会调用系统最匹配的编译工具去编译，或者通过<code>xmake f --cc=clang</code>命令手动去修改，不过这些都是全局影响所有target目标的。</p>
<p>如果有些特殊需求，需要对当前工程下某个特定的target目标单独指定不同的编译器、链接器或者特定版本的编译器，这个时候此接口就可以排上用途了，例如：</p>
<pre><code class="lang-lua">target(&quot;test1&quot;)
    add_files(&quot;*.c&quot;)

target(&quot;test2&quot;)
    add_files(&quot;*.c&quot;)
    set_tools(&quot;cc&quot;, &quot;$(projectdir)/tools/bin/clang-5.0&quot;)
</code></pre>
<p>上述描述仅对test2目标的编译器进行特殊设置，使用特定的clang-5.0编译器来编译test2，而test1还是使用默认设置。</p>
<p>对于同时设置多个编译器类型，可以这么写：</p>
<pre><code class="lang-lua">set_tools {
    cc = path.join(os.projectdir(), &quot;tools/bin/clang-5.0&quot;),
    mm = path.join(os.projectdir(), &quot;tools/bin/clang-5.0&quot;),
}
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>每次设置都会覆盖当前target目标下之前的那次设置，不同target之间不会被覆盖，互相独立，如果在根域设置，会影响所有子target。<br>&lt;/p&gt;

</p>
<p>或者可以使用<a href="#targetadd_tools">add_tools</a>来设置：</p>
<pre><code class="lang-lua">add_tools(&quot;cc&quot;, &quot;$(projectdir)/tools/bin/clang-5.0&quot;)
add_tools(&quot;mm&quot;, &quot;$(projectdir)/tools/bin/clang-5.0&quot;)
</code></pre>
<p>前一个参数是key，用于指定工具类型，目前支持的有（编译器、链接器、归档器）：</p>
<table>
<thead>
<tr>
<th>工具类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cc</td>
<td>c编译器</td>
</tr>
<tr>
<td>cxx</td>
<td>c++编译器</td>
</tr>
<tr>
<td>mm</td>
<td>objc编译器</td>
</tr>
<tr>
<td>mxx</td>
<td>objc++编译器</td>
</tr>
<tr>
<td>gc</td>
<td>go编译器</td>
</tr>
<tr>
<td>as</td>
<td>汇编器</td>
</tr>
<tr>
<td>sc</td>
<td>swift编译器</td>
</tr>
<tr>
<td>rc</td>
<td>rust编译器</td>
</tr>
<tr>
<td>dc</td>
<td>dlang编译器</td>
</tr>
<tr>
<td>ld</td>
<td>c/c++/asm/objc等通用可执行程序链接器</td>
</tr>
<tr>
<td>sh</td>
<td>c/c++/asm/objc等通用动态库链接器</td>
</tr>
<tr>
<td>ar</td>
<td>c/c++/asm/objc等通用静态库归档器</td>
</tr>
<tr>
<td>dcld</td>
<td>dlang可执行链接器, rcld/gcld等类似</td>
</tr>
<tr>
<td>dcsh</td>
<td>dlang动态库链接器, rcsh/gcsh等类似</td>
</tr>
</tbody>
</table>
<p>对于一些编译器文件名不规则，导致xmake无法正常识别处理为已知的编译器名的情况下，我们也可以加一个工具名提示，例如：</p>
<pre><code class="lang-lua">add_tools(&quot;cc&quot;, &quot;gcc@$(projectdir)/tools/bin/mipscc.exe&quot;)
</code></pre>
<p>上述描述设置mipscc.exe作为c编译器，并且提示xmake作为gcc的传参处理方式进行编译。</p>
<h5 id="target-add_tools">target:add_tools</h5>
<h6 id="-">添加编译链接工具链</h6>
<p>类似<a href="#targetset_tools">set_tools</a>，区别就是此接口可以多次调用，去添加多个工具，而<a href="#targetset_tools">set_tools</a>每次设置都会覆盖之前的设置。</p>
<h5 id="target-set_values">target:set_values</h5>
<h6 id="-">设置一些扩展配置值</h6>
<p>给target设置一些扩展的配置值，这些配置没有像<code>set_ldflags</code>这种内置的api可用，通过第一个参数传入一个配置名，来扩展配置。<br>一般用于传入配置参数给自定义rule中的脚本使用，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        -- compile .markdown with flags
        local flags = target:values(&quot;markdown.flags&quot;)
        if flags then
            -- ..
        end
    end)

target(&quot;test&quot;)
    add_files(&quot;src/*.md&quot;, {rule = &quot;markdown&quot;})
    set_values(&quot;markdown.flags&quot;, &quot;xxx&quot;, &quot;xxx&quot;)
</code></pre>
<p>上述代码例子中，可以看出，在target应用markdown规则的时候，通过set_values去设置一些flags值，提供给markdown规则去处理。<br>在规则脚本中可以通过<code>target:values(&quot;markdown.flags&quot;)</code>获取到target中设置的扩展flags值。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>具体扩展配置名，根据不同的rule，会有所不同，目前有哪些，可以参考相关规则的描述：<a href="#内建规则">内建规则</a><br>&lt;/p&gt;

</p>
<h5 id="target-add_values">target:add_values</h5>
<h6 id="-">添加一些扩展配置值</h6>
<p>用法跟<a href="#targetset_tools">target:set_values</a>类似，区别就是这个接口是追加设置，而不会每次覆盖设置。</p>
<h5 id="target-set_rundir">target:set_rundir</h5>
<h6 id="-">设置运行目录</h6>
<p>此接口用于设置默认运行target程序的当前运行目录，如果不设置，默认情况下，target是在可执行文件所在目录加载运行。</p>
<p>如果用户想要修改加载目录，一种是通过<code>on_run()</code>的方式自定义运行逻辑，里面去做切换，但仅仅为了切个目录就这么做，太过繁琐。</p>
<p>因此可以通过这个接口快速的对默认执行的目录环境做设置切换。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    set_rundir(&quot;$(projectdir)/xxx&quot;)
</code></pre>
<h5 id="target-add_runenvs">target:add_runenvs</h5>
<h6 id="-">添加运行环境变量</h6>
<p>此接口用于添加设置默认运行target程序的环境变量。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_runenvs(&quot;PATH&quot;, &quot;/tmp/bin&quot;, &quot;xxx/bin&quot;)
    add_runenvs(&quot;NAME&quot;, &quot;value&quot;)
</code></pre>
<h5 id="target-set_installdir">target:set_installdir</h5>
<h6 id="-">设置安装目录</h6>
<p>2.2.5版本新增接口，用于针对每个target设置不同的默认安装目录，一般用于<code>xmake install/uninstall</code>命令。</p>
<p>默认情况下执行<code>xmake install</code>会安装到系统<code>/usr/local</code>目录，我们除了可以通过<code>xmake install -o /usr/local</code>指定其他安装目录外，<br>还可以在xmake.lua中针对target设置不同的安装目录来替代默认目录。</p>
<p>除了上述两种方式，我们也可以通过<code>INSTALLDIR</code>和<code>DESTDIR</code>环境变量设置默认的安装目录。</p>
<h5 id="target-add_installfiles">target:add_installfiles</h5>
<h6 id="-">添加安装文件</h6>
<p>2.2.5版本新增接口，用于针对每个target设置对应需要安装的文件，一般用于<code>xmake install/uninstall</code>命令。</p>
<p>比如我们可以指定安装各种类型的文件到安装目录：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_installfiles(&quot;src/*.h&quot;)
    add_installfiles(&quot;doc/*.md&quot;)
</code></pre>
<p>默认在linux等系统上，我们会安装到<code>/usr/local/*.h, /usr/local/*.md</code>，不过我们也可以指定安装到特定子目录：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_installfiles(&quot;src/*.h&quot;, {prefixdir = &quot;include&quot;})
    add_installfiles(&quot;doc/*.md&quot;, {prefixdir = &quot;share/doc&quot;})
</code></pre>
<p>上面的设置，我们会安装到<code>/usr/local/include/*.h, /usr/local/share/doc/*.md</code></p>
<p>我们也可以通过<code>()</code>去提取源文件中的子目录来安装，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_installfiles(&quot;src/(tbox/*.h)&quot;, {prefixdir = &quot;include&quot;})
    add_installfiles(&quot;doc/(tbox/*.md)&quot;, {prefixdir = &quot;share/doc&quot;})
</code></pre>
<p>我们把<code>src/tbox/*.h</code>中的文件，提取<code>tbox/*.h</code>子目录结构后，在进行安装：<code>/usr/local/include/tbox/*.h, /usr/local/share/doc/tbox/*.md</code></p>
<p>当然，用户也可以通过<a href="#targetset_installdir">set_installdir</a>接口，来配合使用。</p>
<p>关于此接口的详细说明，见：<a href="https://github.com/xmake-io/xmake/issues/318">https://github.com/xmake-io/xmake/issues/318</a></p>
<h5 id="target-add_headerfiles">target:add_headerfiles</h5>
<h6 id="-">添加安装头文件</h6>
<p>2.2.5版本新增接口，用于针对每个target设置对应需要安装的头文件，一般用于<code>xmake install/uninstall</code>命令。</p>
<p>此接口使用方式跟<a href="#targetadd_installfiles">add_installfiles</a>接口几乎完全一样，都可以用来天剑安装文件，不过此接口仅用于安装头文件。<br>因此，使用上比<code>add_installfiles</code>简化了不少，默认不设置prefixdir，也会自动将头文件安装到对应的<code>include</code>子目录中。</p>
<p>并且此接口对于<code>xmake project -k vs201x</code>等插件生成的IDE文件，也会添加对应的头文件进去。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>需要注意的是，之前的<a href="#targetadd_headers">add_headers</a>接口已经被废弃，新版本请用此接口替代，这个老接口在编译过程中也会自动复制头文件到build目录，这个逻辑设计的并不是很好。<br>&lt;/p&gt;

</p>
<h5 id="target-set_configdir">target:set_configdir</h5>
<h6 id="-">设置模板配置文件的输出目录</h6>
<p>2.2.5版本新增接口，主要用于<a href="#targetadd_configfiles">add_configfiles</a>接口设置的模板配置文件的输出目录。</p>
<h5 id="target-set_configvar">target:set_configvar</h5>
<h6 id="-">设置模板配置变量</h6>
<p>2.2.5版本新增接口，用于在编译前，添加一些需要预处理的模板配置变量，一般用于<a href="#targetadd_configfiles">add_configfiles</a>接口。</p>
<h5 id="target-add_configfiles">target:add_configfiles</h5>
<h6 id="-">添加模板配置文件</h6>
<p>2.2.5版本新增接口，用于在编译前，添加一些需要预处理的配置文件，用于替代<a href="#targetset_config_header">set_config_header</a>等老接口。</p>
<p>因为此接口更加的通用，不仅用于处理config.h的自动生成和预处理，还可以处理各种文件类型，而<code>set_config_header</code>仅用于处理头文件，并且不支持模板变量替换。</p>
<p>先来一个简单的例子：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    set_configdir(&quot;$(buildir)/config&quot;)
    add_configfiles(&quot;src/config.h.in&quot;)
</code></pre>
<p>上面的设置，会在编译前，自动的将<code>config.h.in</code>这个头文件配置模板，经过预处理后，生成输出到指定的<code>build/config/config.h</code>。</p>
<p>如果<code>set_configdir</code>不设置，那么默认输出到<code>build</code>目录下。</p>
<p>其中<code>.in</code>后缀会被自动识别处理掉，如果想要输出存储为其他文件名，可以通过：</p>
<pre><code class="lang-lua">add_configfiles(&quot;src/config.h&quot;, {filename = &quot;myconfig.h&quot;})
</code></pre>
<p>的方式，来重命名输出，同样，这个接口跟<a href="#targetadd_configfiles">add_installfiles</a>类似，也是支持prefixdir和子目录提取设置：</p>
<pre><code class="lang-lua">add_configfiles(&quot;src/*.h.in&quot;, {prefixdir = &quot;subdir&quot;})
add_configfiles(&quot;src/(tbox/config.h)&quot;) 
</code></pre>
<p>这个接口的一个最重要的特性就是，可以在预处理的时候，对里面的一些模板变量进行预处理替换，例如：</p>
<p>config.h.in</p>
<pre><code>#define VAR1 &quot;${VAR1}&quot;
#define VAR2 &quot;${VAR2}&quot;
#define HELLO &quot;${HELLO}&quot;
</code></pre><pre><code class="lang-lua">set_configvar(&quot;VAR1&quot;, &quot;1&quot;)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;main.c&quot;)

    set_configvar(&quot;VAR2&quot;, 2)
    add_configfiles(&quot;config.h.in&quot;, {variables = {hello = &quot;xmake&quot;}})
    add_configfiles(&quot;*.man&quot;, {copyonly = true})
</code></pre>
<p>通过<a href="#targetset_configvar">set_configvar</a>接口设置模板变量，裹着通过<code>{variables = {xxx = &quot;&quot;}}</code>中设置的变量进行替换处理。</p>
<p>预处理后的文件<code>config.h</code>内容为：</p>
<pre><code>#define VAR1 &quot;1&quot;
#define VAR2 &quot;2&quot;
#define HELLO &quot;xmake&quot;
</code></pre><p>而<code>{copyonly = true}</code>设置，会强制将<code>*.man</code>作为普通文件处理，仅在预处理阶段copy文件，不进行变量替换。</p>
<p>默认的模板变量匹配模式为<code>${var}</code>，当然我们也可以设置其他的匹配模式，例如，改为<code>@var@</code>匹配规则：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_configfiles(&quot;config.h.in&quot;, {pattern = &quot;@(.-)@&quot;})
</code></pre>
<p>我们也有提供了一些内置的变量，即使不通过此接口设置，也是可以进行默认变量替换的：</p>
<pre><code>${VERSION} -&gt; 1.6.3
${VERSION_MAJOR} -&gt; 1
${VERSION_MINOR} -&gt; 6
${VERSION_ALTER} -&gt; 3
${VERSION_BUILD} -&gt; set_version(&quot;1.6.3&quot;, {build = &quot;%Y%m%d%H%M&quot;}) -&gt; 201902031421
${PLAT} and ${plat} -&gt; MACOS and macosx
${ARCH} and ${arch} -&gt; ARM and arm
${MODE} and ${mode} -&gt; DEBUG/RELEASE and debug/release
${DEBUG} and ${debug} -&gt; 1 or 0
${OS} and ${os} -&gt; IOS or ios
</code></pre><p>例如：</p>
<p>config.h.in</p>
<pre><code class="lang-c">#define CONFIG_VERSION &quot;${VERSION}&quot;
#define CONFIG_VERSION_MAJOR ${VERSION_MAJOR}
#define CONFIG_VERSION_MINOR ${VERSION_MINOR}
#define CONFIG_VERSION_ALTER ${VERSION_ALTER}
#define CONFIG_VERSION_BUILD ${VERSION_BUILD}
</code></pre>
<p>config.h</p>
<pre><code class="lang-c">#define CONFIG_VERSION &quot;1.6.3&quot;
#define CONFIG_VERSION_MAJOR 1
#define CONFIG_VERSION_MINOR 6
#define CONFIG_VERSION_ALTER 3
#define CONFIG_VERSION_BUILD 201902031401
</code></pre>
<p>我们还可以对<code>#define</code>定义进行一些变量状态控制处理：</p>
<p>config.h.in </p>
<pre><code class="lang-c">${define FOO_ENABLE}
</code></pre>
<pre><code class="lang-lua">set_configvar(&quot;FOO_ENABLE&quot;, 1) -- or pass true
set_configvar(&quot;FOO_STRING&quot;, &quot;foo&quot;)
</code></pre>
<p>通过上面的变量设置后，<code>${define xxx}</code>就会替换成：</p>
<pre><code class="lang-c">#define FOO_ENABLE 1
#define FOO_STRING &quot;foo&quot;
</code></pre>
<p>或者（设置为0禁用的时候）</p>
<pre><code class="lang-c">/* #undef FOO_ENABLE */
/* #undef FOO_STRING */
</code></pre>
<p>这种方式，对于一些自动检测生成config.h非常有用，比如配合option来做自动检测：</p>
<pre><code class="lang-lua">option(&quot;foo&quot;)
    set_default(true)
    set_description(&quot;Enable Foo&quot;)
    set_configvar(&quot;FOO_ENABLE&quot;, 1) -- 或者传递true，启用FOO_ENABLE变量
    set_configvar(&quot;FOO_STRING&quot;, &quot;foo&quot;)

target(&quot;test&quot;)
    add_configfiles(&quot;config.h.in&quot;)

    -- 如果启用foo选项 -&gt; 天剑 FOO_ENABLE 和 FOO_STRING 定义
    add_options(&quot;foo&quot;) 
</code></pre>
<p>config.h.in</p>
<pre><code class="lang-c">${define FOO_ENABLE}
${define FOO_STRING}
</code></pre>
<p>config.h</p>
<pre><code class="lang-c">#define FOO_ENABLE 1
#define FOO_STRING &quot;foo&quot;
</code></pre>
<p>关于option选项检测，以及config.h的自动生成，有一些辅助函数，可以看下：<a href="https://github.com/xmake-io/xmake/issues/342">https://github.com/xmake-io/xmake/issues/342</a></p>
<p>除了<code>#define</code>，如果想要对其他非<code>#define xxx</code>也做状态切换处理，可以使用 <code>${default xxx 0}</code> 模式，设置默认值，例如：</p>
<pre><code>HAVE_SSE2 equ ${default VAR_HAVE_SSE2 0}
</code></pre><p>通过<code>set_configvar(&quot;HAVE_SSE2&quot;, 1)</code>启用变量后，变为<code>HAVE_SSE2 equ 1</code>，如果没有设置变量，则使用默认值：<code>HAVE_SSE2 equ 0</code></p>
<p>关于这个的详细说明，见：<a href="https://github.com/xmake-io/xmake/issues/320">https://github.com/xmake-io/xmake/issues/320</a></p>
<h4 id="-">选项定义</h4>
<p>定义和设置选项开关，每个<code>option</code>对应一个选项，可用于自定义编译配置选项、开关设置。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>除了<code>target</code>以外的所有域接口，例如<code>option</code>，<code>task</code>等的接口，默认不能放置在外面的全局作用域中的（除非部分跟target共用的接口除外）。<br>如果要设置值影响所有<code>option</code>，<code>task</code>等选项，可以通过匿名全局域来设置。<br>&lt;/p&gt;

</p>
<p>例如：</p>
<pre><code class="lang-lua">-- 进入option的匿名全局域，里面的设置会同时影响test和test2选项
option()
    add_defines(&quot;DEBUG&quot;)

option(&quot;test&quot;)
    -- ... 
    -- 尽量保持缩进，因为这个之后的所有设置，都是针对test选项的

option(&quot;test2&quot;)
    -- ... 
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br><code>option</code>域是可以重复进入来实现分离设置的，如果要显示离开当前选项的作用域设置，可以手动调用<a href="#option_end">option_end</a>接口。<br>&lt;/p&gt;


</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#option">option</a></td>
<td>定义选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#option_end">option_end</a></td>
<td>结束定义选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#optionadd_deps">add_deps</a></td>
<td>添加选项依赖</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#optionbefore_check">before_check</a></td>
<td>选项检测之前执行此脚本</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#optionon_check">on_check</a></td>
<td>自定义选项检测脚本</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#optionafter_check">after_check</a></td>
<td>选项检测之后执行此脚本</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#optionset_values">set_values</a></td>
<td>设置选项值列表</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#optionset_default">set_default</a></td>
<td>设置默认值</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#optionset_showmenu">set_showmenu</a></td>
<td>设置是否启用菜单显示</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionset_category">set_category</a></td>
<td>设置选项分类，仅用于菜单显示</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionset_description">set_description</a></td>
<td>设置菜单显示描述</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionadd_links">add_links</a></td>
<td>添加链接库检测</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionadd_linkdirs">add_linkdirs</a></td>
<td>添加链接库检测需要的搜索目录</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionadd_rpathdirs">add_rpathdirs</a></td>
<td>添加运行时候动态链接库搜索目录</td>
<td>&gt;= 2.1.3</td>
</tr>
<tr>
<td><a href="#optionadd_cincludes">add_cincludes</a></td>
<td>添加c头文件检测</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionadd_cxxincludes">add_cxxincludes</a></td>
<td>添加c++头文件检测</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionadd_ctypes">add_ctypes</a></td>
<td>添加c类型检测</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionadd_cxxtypes">add_cxxtypes</a></td>
<td>添加c++类型检测</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#optionadd_csnippet">add_csnippet</a></td>
<td>添加c代码片段检测</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#optionadd_cxxsnippet">add_cxxsnippet</a></td>
<td>添加c++代码片段检测</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#targetset_warnings">set_warnings</a></td>
<td>设置警告级别</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_optimize">set_optimize</a></td>
<td>设置优化级别</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetset_languages">set_languages</a></td>
<td>设置代码语言标准</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_includedirs">add_includedirs</a></td>
<td>添加头文件搜索目录</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_defines">add_defines</a></td>
<td>添加宏定义</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_undefines">add_undefines</a></td>
<td>取消宏定义</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_defines_h">add_defines_h</a></td>
<td>添加宏定义到头文件</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_undefines_h">add_undefines_h</a></td>
<td>取消宏定义到头文件</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cflags">add_cflags</a></td>
<td>添加c编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cxflags">add_cxflags</a></td>
<td>添加c/c++编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cxxflags">add_cxxflags</a></td>
<td>添加c++编译选项</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_mflags">add_mflags</a></td>
<td>添加objc编译选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_mxflags">add_mxflags</a></td>
<td>添加objc/objc++编译选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_mxxflags">add_mxxflags</a></td>
<td>添加objc++编译选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_scflags">add_scflags</a></td>
<td>添加swift编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_asflags">add_asflags</a></td>
<td>添加汇编编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_gcflags">add_gcflags</a></td>
<td>添加go编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_dcflags">add_dcflags</a></td>
<td>添加dlang编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_rcflags">add_rcflags</a></td>
<td>添加rust编译选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_cuflags">add_cuflags</a></td>
<td>添加cuda编译选项</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#targetadd_culdflags">add_culdflags</a></td>
<td>添加cuda设备链接选项</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#targetadd_ldflags">add_ldflags</a></td>
<td>添加链接选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_arflags">add_arflags</a></td>
<td>添加静态库归档选项</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_shflags">add_shflags</a></td>
<td>添加动态库链接选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cfuncs">add_cfuncs</a></td>
<td>添加c库函数检测</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_cxxfuncs">add_cxxfuncs</a></td>
<td>添加c++库函数接口</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_languages">add_languages</a></td>
<td>添加语言标准</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_vectorexts">add_vectorexts</a></td>
<td>添加向量扩展指令</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#targetadd_frameworks">add_frameworks</a></td>
<td>添加链接框架</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#targetadd_frameworkdirs">add_frameworkdirs</a></td>
<td>添加链接框架</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>废弃接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#optionadd_bindings">add_bindings</a></td>
<td>添加正向关联选项，同步启用和禁用</td>
<td>&gt;= 2.0.1 &lt; 2.1.5</td>
</tr>
<tr>
<td><a href="#optionadd_rbindings">add_rbindings</a></td>
<td>添加逆向关联选项，同步启用和禁用</td>
<td>&gt;= 2.0.1 &lt; 2.1.5</td>
</tr>
<tr>
<td><a href="#optionadd_defines_if_ok">add_defines_if_ok</a></td>
<td>如果检测选项通过，则添加宏定义</td>
<td>&gt;= 1.0.1 &lt; 2.1.5</td>
</tr>
<tr>
<td><a href="#optionadd_defines_h_if_ok">add_defines_h_if_ok</a></td>
<td>如果检测选项通过，则添加宏定义到配置头文件</td>
<td>&gt;= 1.0.1 &lt; 2.1.5</td>
</tr>
<tr>
<td><a href="#optionadd_undefines_if_ok">add_undefines_if_ok</a></td>
<td>如果检测选项通过，则取消宏定义</td>
<td>&gt;= 1.0.1 &lt; 2.1.5</td>
</tr>
<tr>
<td><a href="#optionadd_undefines_h_if_ok">add_undefines_h_if_ok</a></td>
<td>如果检测选项通过，则在配置头文件中取消宏定义</td>
<td>&gt;= 1.0.1 &lt; 2.1.5</td>
</tr>
</tbody>
</table>
<h5 id="option">option</h5>
<h6 id="-">定义选项</h6>
<p>定义和设置选项开关，可用于自定义编译配置选项、开关设置。</p>
<p>例如，定义一个是否启用test的选项：</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    set_default(false)
    set_showmenu(true)
    add_defines(&quot;TEST&quot;)
</code></pre>
<p>然后关联到指定的target中去：</p>
<pre><code class="lang-lua">target(&quot;demo&quot;)
    add_options(&quot;test&quot;)
</code></pre>
<p>这样，一个选项就算定义好了，如果这个选项被启用，那么编译这个target的时候，就会自动加上<code>-DTEST</code>的宏定义。</p>
<pre><code class="lang-lua"># 手动启用这个选项
$ xmake f --test=y
$ xmake
</code></pre>
<h5 id="option_end">option_end</h5>
<h6 id="-">结束定义选项</h6>
<p>这是一个可选api，显示离开选项作用域，用法和<a href="#target_end">target_end</a>类似。</p>
<h5 id="option-add_deps">option:add_deps</h5>
<h6 id="-">添加选项依赖</h6>
<p>通过设置依赖，可以调整选项的检测顺序，一般用于<a href="#optionon_check">on_check</a>等检测脚本的调用时机。</p>
<pre><code class="lang-lua">option(&quot;small&quot;)
    set_default(true)
    on_check(function (option)
        -- ...
    end)

option(&quot;test&quot;)
    add_deps(&quot;small&quot;)
    set_default(true)
    on_check(function (option)
        if option:dep(&quot;small&quot;):enabled() then
            option:enable(false)
        end
    end)
</code></pre>
<p>当依赖的small选项检测完成后，通过判断small选项的状态，来控制test的选项状态。</p>
<h5 id="option-before_check">option:before_check</h5>
<h6 id="-">选项检测之前执行此脚本</h6>
<p>例如：在检测之前，通过<a href="#detect-find_package">find_package</a>来查找包，将<code>links</code>, <code>includedirs</code>和<code>linkdirs</code>等信息添加到option中去，<br>然后开始选项检测，通过后就会自动链接到target上。</p>
<pre><code class="lang-lua">option(&quot;zlib&quot;)
    before_check(function (option)
        import(&quot;lib.detect.find_package&quot;)
        option:add(find_package(&quot;zlib&quot;))
    end)
</code></pre>
<h5 id="option-on_check">option:on_check</h5>
<h6 id="-">自定义选项检测脚本</h6>
<p>此脚本会覆盖内置的选项检测逻辑。</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    add_deps(&quot;small&quot;)
    set_default(true)
    on_check(function (option)
        if option:dep(&quot;small&quot;):enabled() then
            option:enable(false)
        end
    end)
</code></pre>
<p>如果test依赖的选项通过，则禁用test选项。</p>
<h5 id="option-after_check">option:after_check</h5>
<h6 id="-">选项检测之后执行此脚本</h6>
<p>在选项检测完成后，执行此脚本做一些后期处理，也可以在此时重新禁用选项：</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    add_deps(&quot;small&quot;)
    add_links(&quot;pthread&quot;)
    after_check(function (option)
        option:enable(false)
    end)
</code></pre>
<h5 id="option-set_values">option:set_values</h5>
<h6 id="-">设置选项值列表</h6>
<p>仅用于<code>xmake f --menu</code>的图形菜单配置时，提供选项值列表供用户快速选择使用，例如：</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    set_default(&quot;b&quot;)
    set_showmenu(true)
    set_values(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</code></pre>
<p>效果图如下：</p>
<p>&lt;img src=&quot;/assets/img/manual/option_set_values.png&quot; width=&quot;60%&quot; /&gt;</p>
<h5 id="option-set_default">option:set_default</h5>
<h6 id="-">设置选项默认值</h6>
<p>在没有通过<code>xmake f --option=[y|n}</code>等命令修改选项值的时候，这个选项本身也是有个默认值的，可以通过这个接口来设置：</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    -- 默认禁用这个选项
    set_default(false)
</code></pre>
<p>选项的值不仅支持boolean类型，也可以是字符串类型，例如：</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    set_default(&quot;value&quot;)
</code></pre>
<table>
<thead>
<tr>
<th>值类型</th>
<th>描述</th>
<th>配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>一般用作参数开关，值范围：<code>true/false</code></td>
<td><code>xmake f --optionname=[y/n/yes/no/true/false]</code></td>
</tr>
<tr>
<td>string</td>
<td>可以是任意字符串，一般用于模式判断</td>
<td><code>xmake f --optionname=value</code></td>
</tr>
</tbody>
</table>
<p>如果是<code>boolean</code>值的选项，可以通过<a href="#is_option">is_option</a>来进行判断，选项是否被启用。</p>
<p>如果是<code>string</code>类型的选项，可以在内建变量中直接使用，例如：</p>
<pre><code class="lang-lua">-- 定义一个路径配置选项，默认使用临时目录
option(&quot;rootdir&quot;)
    set_default(&quot;$(tmpdir)&quot;)
    set_showmenu(true)

target(&quot;test&quot;)
    -- 添加指定选项目录中的源文件
    add_files(&quot;$(rootdir)/*.c&quot;)
</code></pre>
<p>其中，<code>$(rootdir)</code> 就是自定义的选项内建变量，通过手动配置，可以动态修改它的值：</p>
<pre><code class="lang-bash">$ xmake f --rootdir=~/projectdir/src
$ xmake
</code></pre>
<p>给这个<code>rootdir</code>选项指定一个其他的源码目录路径，然后编译。</p>
<p>选项的检测行为：</p>
<table>
<thead>
<tr>
<th>default值</th>
<th>检测行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有设置</td>
<td>优先手动配置修改，默认禁用，否则自动检测，可根据手动传入的值类型，自动切换boolean和string类型</td>
</tr>
<tr>
<td>false</td>
<td>开关选项，不自动检测，默认禁用，可手动配置修改</td>
</tr>
<tr>
<td>true</td>
<td>开关选项，不自动检测，默认启用，可手动配置修改</td>
</tr>
<tr>
<td>string类型</td>
<td>无开关状态，不自动检测，可手动配置修改，一般用于配置变量传递</td>
</tr>
</tbody>
</table>
<h5 id="option-set_showmenu">option:set_showmenu</h5>
<h6 id="-">设置是否启用菜单显示</h6>
<p>如果设置为<code>true</code>，那么在<code>xmake f --help</code>里面就会出现这个选项，也就能通过<code>xmake f --optionname=xxx</code>进行配置，否则只能在<code>xmake.lua</code>内部使用，无法手动配置修改。</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    set_showmenu(true)
</code></pre>
<p>设置为启用菜单后，执行<code>xmake f --help</code>可以看到，帮助菜单里面多了一项：</p>
<pre><code>Options:
    ...

    --test=TEST
</code></pre><h5 id="option-set_category">option:set_category</h5>
<h6 id="-">设置选项分类，仅用于菜单显示</h6>
<p>这个是个可选配置，仅用于在帮助菜单中，进行分类显示选项，同一类别的选项，会在同一个分组里面显示，这样菜单看起来更加的美观。</p>
<p>例如：</p>
<pre><code class="lang-lua">option(&quot;test1&quot;)
    set_showmenu(true)
    set_category(&quot;test&quot;)

option(&quot;test2&quot;)
    set_showmenu(true)
    set_category(&quot;test&quot;)

option(&quot;demo1&quot;)
    set_showmenu(true)
    set_category(&quot;demo&quot;)

option(&quot;demo2&quot;)
    set_showmenu(true)
    set_category(&quot;demo&quot;)
</code></pre>
<p>这里四个选项分别归类于两个分组：<code>test</code>和<code>demo</code>，那么显示的布局类似这样：</p>
<pre><code class="lang-bash">Options:
    ...

    --test1=TEST1
    --test2=TEST2

    --demo1=DEMO1
    --demo2=DEMO2
</code></pre>
<p>这个接口，仅仅是为了调整显示布局，更加美观而已，没其他用途。</p>
<p>在2.1.9版本中，可以通过category设置分级路径名<code>set_category(&quot;root/submenu/submenu2&quot;)</code>，来配置<code>xmake f --menu</code>的图形菜单界面，例如：</p>
<pre><code class="lang-lua">-- &#39;boolean&#39; option
option(&quot;test1&quot;)
    set_default(true)
    set_showmenu(true)
    set_category(&quot;root menu/test1&quot;)

-- &#39;choice&#39; option with values: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
option(&quot;test2&quot;)
    set_default(&quot;a&quot;)
    set_values(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
    set_showmenu(true)
    set_category(&quot;root menu/test2&quot;)

-- &#39;string&#39; option
option(&quot;test3&quot;)
    set_default(&quot;xx&quot;)
    set_showmenu(true)
    set_category(&quot;root menu/test3/test3&quot;)

-- &#39;number&#39; option
option(&quot;test4&quot;)
    set_default(6)
    set_showmenu(true)
    set_category(&quot;root menu/test4&quot;)
</code></pre>
<p>上述配置最后显示的菜单界面路径结构：</p>
<ul>
<li>root menu<ul>
<li>test1</li>
<li>test2</li>
<li>test3<ul>
<li>test3</li>
</ul>
</li>
<li>test4</li>
</ul>
</li>
</ul>
<p>效果图如下：</p>
<p>&lt;img src=&quot;/assets/img/manual/option_set_category.gif&quot; width=&quot;60%&quot; /&gt;</p>
<h5 id="option-set_description">option:set_description</h5>
<h6 id="-">设置菜单显示描述</h6>
<p>设置选项菜单显示时，右边的描述信息，用于帮助用户更加清楚的知道这个选项的用途，例如：</p>
<pre><code class="lang-lua">option(&quot;test&quot;)
    set_default(false)
    set_showmenu(true)
    set_description(&quot;Enable or disable test&quot;)
</code></pre>
<p>生成的菜单内容如下：</p>
<pre><code>Options:
    ...

    --test=TEST                       Enable or disable test (default: false)
</code></pre><p>这个接口也支持多行显示，输出更加详细的描述信息，例如：</p>
<pre><code class="lang-lua">option(&quot;mode&quot;)
    set_default(&quot;debug&quot;)
    set_showmenu(true)
    set_description(&quot;Set build mode&quot;,
                    &quot;    - debug&quot;,
                    &quot;    - release&quot;,
                    &quot;    - profile&quot;)
</code></pre>
<p>生成的菜单内容如下：</p>
<pre><code>Options:
    ...

    --mode=MODE                       Set build mode (default: debug)
                                          - debug
                                          - release
                                          - profile
</code></pre><p>看到这个菜单，用户就能清楚地知道，定义的这个<code>mode</code>选项的具体用处，以及如何使用了：</p>
<pre><code class="lang-bash">$ xmake f --mode=release
</code></pre>
<h5 id="option-add_bindings">option:add_bindings</h5>
<h6 id="-">添加正向关联选项，同步启用和禁用</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之后已废弃，请用<a href="#optionadd_deps">add_deps</a>, <a href="#optionon_check">on_check</a>, <a href="#optionafter_check">after_check</a>等接口代替。<br>&lt;/p&gt;

</p>
<p>绑定关联选项，例如我想在命令行中配置一个<code>smallest</code>的参数：<code>xmake f --smallest=y</code></p>
<p>这个时候，需要同时禁用多个其他的选项开关，来禁止编译多个模块，就是这个需求，相当于一个选项 与其他 多个选项之间 是有联动效应的。</p>
<p>而这个接口就是用来设置需要正向绑定的一些关联选项，例如：</p>
<pre><code class="lang-lua">-- 定义选项开关: --smallest=y|n
option(&quot;smallest&quot;)

    -- 添加正向绑定，如果smallest被启用，下面的所有选项开关也会同步被启用
    add_bindings(&quot;nozip&quot;, &quot;noxml&quot;, &quot;nojson&quot;)
</code></pre>
<h5 id="option-add_rbindings">option:add_rbindings</h5>
<h6 id="-">添加逆向关联选项，同步启用和禁用</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之后已废弃，请用<a href="#optionadd_deps">add_deps</a>, <a href="#optionon_check">on_check</a>, <a href="#optionafter_check">after_check</a>等接口代替。<br>&lt;/p&gt;

</p>
<p>逆向绑定关联选项，被关联选项的开关状态是相反的。</p>
<pre><code class="lang-lua">-- 定义选项开关: --smallest=y|n
option(&quot;smallest&quot;)

    -- 添加反向绑定，如果smallest被启用，下面的所有模块全部禁用
    add_rbindings(&quot;xml&quot;, &quot;zip&quot;, &quot;asio&quot;, &quot;regex&quot;, &quot;object&quot;, &quot;thread&quot;, &quot;network&quot;, &quot;charset&quot;, &quot;database&quot;)
    add_rbindings(&quot;zlib&quot;, &quot;mysql&quot;, &quot;sqlite3&quot;, &quot;openssl&quot;, &quot;polarssl&quot;, &quot;pcre2&quot;, &quot;pcre&quot;, &quot;base&quot;)
</code></pre>
<p>&lt;p class=&quot;warn&quot;&gt;<br>需要注意的是，命令行配置是有顺序的，你可以先通过启用smallest禁用所有模块，然后添加其他选项，逐一启用。<br>&lt;/p&gt;

</p>
<p>例如：</p>
<pre><code class="lang-bash">-- 禁用所有模块，然后仅仅启用xml和zip模块
$ xmake f --smallest=y --xml=y --zip=y
</code></pre>
<h5 id="option-add_links">option:add_links</h5>
<h6 id="-">添加链接库检测</h6>
<p>如果指定的链接库检测通过，此选项将被启用，并且对应关联的target会自动加上此链接，例如：</p>
<pre><code class="lang-lua">option(&quot;pthread&quot;)
    set_default(false)
    add_links(&quot;pthread&quot;)
    add_linkdirs(&quot;/usr/local/lib&quot;)

target(&quot;test&quot;)
    add_options(&quot;pthread&quot;)
</code></pre>
<p>如果检测通过，<code>test</code>目标编译的时候就会自动加上：<code>-L/usr/local/lib -lpthread</code> 编译选项</p>
<h5 id="option-add_linkdirs">option:add_linkdirs</h5>
<h6 id="-">添加链接库检测时候需要的搜索目录</h6>
<p>这个是可选的，一般系统库不需要加这个，也能检测通过，如果确实没找到，可以自己追加搜索目录，提高检测通过率。具体使用见：<a href="#optionadd_links">add_links</a></p>
<h5 id="option-add_rpathdirs">option:add_rpathdirs</h5>
<h6 id="-">添加程序运行时动态库的加载搜索目录</h6>
<p>在选项通过检测后，会自动添加到对应的target上去，具体使用见：<a href="#targetadd_rpathdirs">target.add_rpathdirs</a>。</p>
<h5 id="option-add_cincludes">option:add_cincludes</h5>
<h6 id="-c-">添加c头文件检测</h6>
<p>如果c头文件检测通过，此选项将被启用，例如：</p>
<pre><code class="lang-lua">option(&quot;pthread&quot;)
    set_default(false)
    add_cincludes(&quot;pthread.h&quot;)
    add_defines(&quot;ENABLE_PTHREAD&quot;)

target(&quot;test&quot;)
    add_options(&quot;pthread&quot;)
</code></pre>
<p>此选项检测是否存在<code>pthread.h</code>的头文件，如果检测通过那么<code>test</code>目标程序将会加上<code>ENABLE_PTHREAD</code>的宏定义。</p>
<p>如果想要更加灵活的检测，可以通过<a href="#detect-has_cincludes">lib.detect.has_cincludes</a>在<a href="#optionon_check">option.on_check</a>中去实现。</p>
<h5 id="option-add_cxxincludes">option:add_cxxincludes</h5>
<h6 id="-c-">添加c++头文件检测</h6>
<p>与<a href="#optionadd_cincludes">add_cincludes</a>类似，只是检测的头文件类型是c++头文件。</p>
<h5 id="option-add_ctypes">option:add_ctypes</h5>
<h6 id="-c-">添加c类型检测</h6>
<p>如果c类型检测通过，此选项将被启用，例如：</p>
<pre><code class="lang-lua">option(&quot;wchar&quot;)
    set_default(false)
    add_cincludes(&quot;wchar_t&quot;)
    add_defines(&quot;HAVE_WCHAR&quot;)

target(&quot;test&quot;)
    add_options(&quot;wchar&quot;)
</code></pre>
<p>此选项检测是否存在<code>wchar_t</code>的类型，如果检测通过那么<code>test</code>目标程序将会加上<code>HAVE_WCHAR</code>的宏定义。</p>
<p>如果想要更加灵活的检测，可以通过<a href="#detect-has_ctypes">lib.detect.has_ctypes</a>在<a href="#optionon_check">option.on_check</a>中去实现。</p>
<h5 id="option-add_cxxtypes">option:add_cxxtypes</h5>
<h6 id="-c-">添加c++类型检测</h6>
<p>与<a href="#optionadd_ctypes">add_ctypes</a>类似，只是检测的类型是c++类型。</p>
<h5 id="option-add_csnippet">option:add_csnippet</h5>
<h6 id="-c-">添加c代码片段检测</h6>
<p>如果现有的<a href="#optionadd_ctypes">add_ctypes</a>, <a href="#optionadd_cfuncs">add_cfuncs</a>等不能满足当前的检测需求，<br>可以用这个接口实现更加定制化检测一些编译器特性检测，具体见: <a href="#optionadd_cxxsnippet">add_cxxsnippet</a>。</p>
<h5 id="option-add_cxxsnippet">option:add_cxxsnippet</h5>
<h6 id="-c-">添加c++代码片段检测</h6>
<p>可以用这个接口实现更加定制化检测一些编译器特性检测，尤其是c++的各种特性的检测支持，例如：</p>
<pre><code class="lang-lua">option(&quot;constexpr&quot;)
    add_cxxsnippet(&quot;constexpr&quot;, &quot;constexpr int f(int x) { int sum=0; for (int i=0; i&lt;=x; ++i) sum += i; return sum; } constexpr int x = f(5);  static_assert(x == 15);&quot;)
</code></pre>
<p>第一个参数设置代码片段的名字作为标示，检测输出信息时候会有显示。</p>
<p>上述代码，实现对c++的constexpr特性的检测，如果检测通过，则启用constexpr选项，当然这里只是个例子。</p>
<p>对于编译器特性的检测，有更加方便高效的检测模块，提供更强大的检测支持，具体见：<a href="#compiler-has_features">compiler.has_features</a>和<a href="#detect-check_cxsnippets">detect.check_cxsnippets</a></p>
<p>如果想要更加灵活的检测，可以通过<a href="#detect-check_cxsnippets">lib.detect.check_cxsnippets</a>在<a href="#optionon_check">option.on_check</a>中去实现。</p>
<h5 id="option-add_defines_if_ok">option:add_defines_if_ok</h5>
<h6 id="-">如果检测选项通过，则添加宏定义</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之后已废弃，请用<a href="#targetadd_defines">add_defines</a>接口代替。<br>&lt;/p&gt;

</p>
<p>检测选项通过后才会被设置，具体使用见<a href="#optionadd_cincludes">add_cincludes</a>中的例子。</p>
<h5 id="option-add_defines_h_if_ok">option:add_defines_h_if_ok</h5>
<h6 id="-">如果检测选项通过，则添加宏定义到配置头文件</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之后已废弃，请用<a href="#targetadd_defines_h">add_defines_h</a>接口代替。<br>&lt;/p&gt;

</p>
<p>跟<a href="#optionadd_defines_if_ok">add_defines_if_ok</a>类似，只是检测通过后，会在<code>config.h</code>头文件中自动加上被设置的宏定义。</p>
<p>例如：</p>
<pre><code class="lang-lua">option(&quot;pthread&quot;)
    set_default(false)
    add_cincludes(&quot;pthread.h&quot;)
    add_defines_h_if_ok(&quot;ENABLE_PTHREAD&quot;)

target(&quot;test&quot;)
    add_options(&quot;pthread&quot;)
</code></pre>
<p>通过后，会在<code>config.h</code>中加上：</p>
<pre><code class="lang-c">#define ENABLE_PTHREAD 1
</code></pre>
<p>具体<code>config.h</code>如何设置，见：<a href="#targetset_config_h">set_config_h</a></p>
<h5 id="option-add_undefines_if_ok">option:add_undefines_if_ok</h5>
<h6 id="-">如果检测选项通过，则取消宏定义</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之后已废弃，请用<a href="#targetadd_undefines">add_undefines</a>接口代替。<br>&lt;/p&gt;

</p>
<p>跟<a href="#optionadd_defines_if_ok">add_defines_if_ok</a>类似，只是检测通过后，取消被设置的宏定义。</p>
<h5 id="option-add_undefines_h_if_ok">option:add_undefines_h_if_ok</h5>
<h6 id="-">如果检测选项通过，则在配置头文件中取消宏定义</h6>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之后已废弃，请用<a href="#targetadd_undefines_h">add_undefines_h</a>接口代替。<br>&lt;/p&gt;

</p>
<p>跟<a href="#optionadd_defines_h_if_ok">add_defines_h_if_ok</a>类似，只是检测通过后，会在<code>config.h</code>中取消被设置的宏定义。</p>
<pre><code class="lang-c">#undef DEFINED_MACRO
</code></pre>
<p>具体<code>config.h</code>如何设置，见：<a href="#targetset_config_h">set_config_h</a></p>
<h4 id="-">插件任务</h4>
<p>xmake可以实现自定义任务或者插件，其两者的核心就是<code>task</code>任务，其两者实际上是一样的，xmake的插件都是用<code>task</code>实现的。</p>
<p>本质上都是任务，只是<a href="#taskset_category">set_category</a>分类不同而已。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#task">task</a></td>
<td>定义插件或者任务</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#task_end">task_end</a></td>
<td>结束定义插件或任务</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#taskset_menu">set_menu</a></td>
<td>设置任务菜单</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#taskset_category">set_category</a></td>
<td>设置任务类别</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#taskon_run">on_run</a></td>
<td>设置任务运行脚本</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h5 id="task">task</h5>
<h6 id="-">定义插件或者任务</h6>
<p><code>task</code>域用于描述一个自定义的任务实现，与<a href="#target">target</a>和<a href="#option">option</a>同级。</p>
<p>例如，这里定义一个最简单的任务：</p>
<pre><code class="lang-lua">task(&quot;hello&quot;)

    -- 设置运行脚本
    on_run(function ()
        print(&quot;hello xmake!&quot;)
    end)
</code></pre>
<p>这个任务只需要打印<code>hello xmake!</code>，那如何来运行呢？</p>
<p>由于这里没有使用<a href="#taskset_menu">set_menu</a>设置菜单，因此这个任务只能再<code>xmake.lua</code>的自定义脚本或者其他任务内部调用，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    after_build(function (target)

        -- 导入task模块
        import(&quot;core.project.task&quot;)

        -- 运行hello任务
        task.run(&quot;hello&quot;)
    end)
</code></pre>
<p>在构建完<code>test</code>目标后运行<code>hello</code>任务。</p>
<h5 id="task_end">task_end</h5>
<h6 id="-">结束定义插件或任务</h6>
<p>这是一个可选api，显示离开选项作用域，用法和<a href="#target_end">target_end</a>类似。</p>
<h5 id="task-set_menu">task:set_menu</h5>
<h6 id="-">设置任务菜单</h6>
<p>通过设置一个菜单，这个任务就可以开放给用户自己通过命令行手动调用，菜单的设置如下：</p>
<pre><code class="lang-lua">task(&quot;echo&quot;)

    -- 设置运行脚本
    on_run(function ()

        -- 导入参数选项模块
        import(&quot;core.base.option&quot;)

        -- 初始化颜色模式
        local modes = &quot;&quot;
        for _, mode in ipairs({&quot;bright&quot;, &quot;dim&quot;, &quot;blink&quot;, &quot;reverse&quot;}) do
            if option.get(mode) then
                modes = modes .. &quot; &quot; .. mode 
            end
        end

        -- 获取参数内容并且显示信息
        cprint(&quot;${%s%s}%s&quot;, option.get(&quot;color&quot;), modes, table.concat(option.get(&quot;contents&quot;) or {}, &quot; &quot;))
    end)

    -- 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述
    set_menu {
                -- 设置菜单用法
                usage = &quot;xmake echo [options]&quot;

                -- 设置菜单描述
            ,   description = &quot;Echo the given info!&quot;

                -- 设置菜单选项，如果没有选项，可以设置为{}
            ,   options = 
                {
                    -- 设置k模式作为key-only型bool参数
                    {&#39;b&#39;, &quot;bright&quot;,     &quot;k&quot;,  nil,       &quot;Enable bright.&quot;               }      
                ,   {&#39;d&#39;, &quot;dim&quot;,        &quot;k&quot;,  nil,       &quot;Enable dim.&quot;                  }      
                ,   {&#39;-&#39;, &quot;blink&quot;,      &quot;k&quot;,  nil,       &quot;Enable blink.&quot;                }      
                ,   {&#39;r&#39;, &quot;reverse&quot;,    &quot;k&quot;,  nil,       &quot;Reverse color.&quot;               }      

                    -- 菜单显示时，空白一行
                ,   {}

                    -- 设置kv作为key-value型参数，并且设置默认值：black
                ,   {&#39;c&#39;, &quot;color&quot;,      &quot;kv&quot;, &quot;black&quot;,   &quot;Set the output color.&quot;
                                                     ,   &quot;    - red&quot;   
                                                     ,   &quot;    - blue&quot;
                                                     ,   &quot;    - yellow&quot;
                                                     ,   &quot;    - green&quot;
                                                     ,   &quot;    - magenta&quot;
                                                     ,   &quot;    - cyan&quot; 
                                                     ,   &quot;    - white&quot;                  }

                    -- 设置`vs`作为values多值型参数，还有`v`单值类型
                    -- 一般放置在最后，用于获取可变参数列表
                ,   {}
                ,   {nil, &quot;contents&quot;,   &quot;vs&quot;, nil,       &quot;The info contents.&quot;           }
                }
            } 
</code></pre>
<p>定义完这个任务后，执行<code>xmake --help</code>，就会多出一个任务项来：</p>
<pre><code>Tasks:

    ...

    echo                    Echo the given info!
</code></pre><p>如果通过<a href="#taskset_category">set_category</a>设置分类为<code>plugin</code>，那么这个任务就是一个插件了：</p>
<pre><code>Plugins:

    ...

    echo                    Echo the given info!
</code></pre><p>想要手动运行这个任务，可以执行：</p>
<pre><code class="lang-bash">$ xmake echo hello xmake!
</code></pre>
<p>就行了，如果要看这个任务定义的菜单，只需要执行：<code>xmake echo [-h|--help]</code>，显示结果如下：</p>
<pre><code class="lang-bash">Usage: $xmake echo [options]

Echo the given info!

Options: 
    -v, --verbose                          Print lots of verbose information.
        --backtrace                        Print backtrace information for debugging.
        --profile                          Print performance data for debugging.
        --version                          Print the version number and exit.
    -h, --help                             Print this help message and exit.

    -F FILE, --file=FILE                   Read a given xmake.lua file.
    -P PROJECT, --project=PROJECT          Change to the given project directory.
                                           Search priority:
                                               1. The Given Command Argument
                                               2. The Envirnoment Variable: XMAKE_PROJECT_DIR
                                               3. The Current Directory

    -b, --bright                           Enable bright.
    -d, --dim                              Enable dim.
    --, --blink                            Enable blink.
    -r, --reverse                          Reverse color.

    -c COLOR, --color=COLOR                Set the output color. (default: black)
                                               - red
                                               - blue
                                               - yellow
                                               - green
                                               - magenta
                                               - cyan
                                               - white

    contents ...                           The info contents.
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>其中菜单最开头的部分选项，是xmake内置的常用选项，基本上每个任务都会用到，不需要自己额外定义，简化菜单定义。<br>&lt;/p&gt;

</p>
<p>下面，我们来实际运行下这个任务，例如我要显示红色的<code>hello xmake!</code>，只需要：</p>
<pre><code class="lang-bash">$ xmake echo -c red hello xmake!
</code></pre>
<p>也可以使用选项全名，并且加上高亮：</p>
<pre><code class="lang-bash">$ xmake echo --color=red --bright hello xmake!
</code></pre>
<p>最后面的可变参数列表，在<code>run</code>脚本中通过<code>option.get(&quot;contents&quot;)</code>获取，返回的是一个<code>table</code>类型的数组。</p>
<h5 id="task-set_category">task:set_category</h5>
<h6 id="-">设置任务类别</h6>
<p>仅仅用于菜单的分组显示，当然插件默认会用<code>plugin</code>，内置任务默认会用：<code>action</code>，但也仅仅只是个约定。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>你可以使用任何自己定义的名字，相同名字会分组归类到一起显示，如果设置为<code>plugin</code>，就会显示到xmake的Plugins分组中去。<br>&lt;/p&gt;

</p>
<p>例如：</p>
<pre><code class="lang-lua">Plugins: 
    l, lua               Run the lua script.
    m, macro             Run the given macro.
       doxygen           Generate the doxygen document.
       project           Generate the project file.
       hello             Hello xmake!
       app2ipa           Generate .ipa file from the given .app
       echo              Echo the given info!
</code></pre>
<p>如果没有调用这个接口设置分类，默认使用<code>Tasks</code>分组显示，代表普通任务。</p>
<h5 id="task-on_run">task:on_run</h5>
<h6 id="-">设置任务运行脚本</h6>
<p>可以有两种设置方式，最简单的就是设置内嵌函数：</p>
<pre><code class="lang-lua">task(&quot;hello&quot;)

    on_run(function ()
        print(&quot;hello xmake!&quot;)
    end)
</code></pre>
<p>这种对于小任务很方便，也很简洁，但是对于大型任务就不太适用了，例如插件等，需要复杂的脚本支持。</p>
<p>这个时候就需要独立的模块文件来设置运行脚本，例如：</p>
<pre><code class="lang-lua">task(&quot;hello&quot;)
    on_run(&quot;main&quot;)
</code></pre>
<p>这里的<code>main</code>设置为脚本运行主入口模块，文件名为<code>main.lua</code>，放在定义<code>task</code>的<code>xmake.lua</code>的同目录下，当然你可以起其他文件名。</p>
<p>目录结构如下：</p>
<pre><code>projectdir
    - xmake.lua
    - main.lua
</code></pre><p><code>main.lua</code>里面内容如下：</p>
<pre><code class="lang-lua">function main(...)
    print(&quot;hello xmake!&quot;)
end
</code></pre>
<p>就是一个简单的带<code>main</code>主函数的脚本文件，你可以通过<a href="#import">import</a>导入各种扩展模块，实现复杂功能，例如：</p>
<pre><code class="lang-lua">-- 导入参数选项模块
import(&quot;core.base.option&quot;)

-- 入口函数
function main(...)

    -- 获取参数内容
    print(&quot;color: %s&quot;, option.get(&quot;color&quot;))
end
</code></pre>
<p>你也可以在当前目录下，创建多个自定义的模块文件，通过<a href="#import">import</a>导入后使用，例如：</p>
<pre><code>projectdir
    - xmake.lua
    - main.lua
    - module.lua
</code></pre><p><code>module.lua</code>的内容如下：</p>
<pre><code class="lang-lua">-- 定义一个导出接口
function hello()
    print(&quot;hello xmake!&quot;)
end
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>私有接口，通过<code>_hello</code>带下滑线前缀命名，这样导入的模块就不会包含此接口，只在模块自身内部使用。<br>&lt;/p&gt;

</p>
<p>然后在<code>main.lua</code>进行调用：</p>
<pre><code class="lang-lua">import(&quot;module&quot;)

function main(...)
    module.hello()
end
</code></pre>
<p>更多模块介绍见：<a href="#内置模块">内置模块</a>和<a href="扩展模块">扩展模块</a></p>
<p>其中，<code>main(...)</code>中参数，是通过<code>task.run</code>指定的，例如：</p>
<pre><code class="lang-lua">task.run(&quot;hello&quot;, {color=&quot;red&quot;}, arg1, arg2, arg3)
</code></pre>
<p>里面的<code>arg1, arg2</code>这些就是传入<code>hello</code>任务<code>main(...)</code>入口的参数列表，而<code>{color=&quot;red&quot;}</code>用来指定任务菜单中的参数选项。</p>
<p>更加详细的<code>task.run</code>描述，见：<a href="#task-run">task.run</a></p>
<h4 id="-">构建规则</h4>
<p>在2.2.1版本之后，xmake不仅原生内置支持多种语言文件的构建，而且还可以通过自定义构建规则，让用户自己来实现复杂的未知文件构建。</p>
<p>我们可以通过预先设置规则支持的文件后缀，来扩展其他文件的构建支持：</p>
<pre><code class="lang-lua">-- 定义一个markdown文件的构建规则
rule(&quot;markdown&quot;)
    set_extensions(&quot;.md&quot;, &quot;.markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. &quot;.html&quot;))
    end)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)

    -- 使test目标支持markdown文件的构建规则
    add_rules(&quot;markdown&quot;)

    -- 添加markdown文件的构建
    add_files(&quot;src/*.md&quot;)
    add_files(&quot;src/*.markdown&quot;)
</code></pre>
<p>我们也可以指定某些零散的其他文件作为markdown规则来处理：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    -- ...
    add_files(&quot;src/test/*.md.in&quot;, {rule = &quot;markdown&quot;})
</code></pre>
<p>一个target可以叠加应用多个rules去更加定制化实现自己的构建行为，甚至支持不同的构建环境。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>通过<code>add_files(&quot;*.md&quot;, {rule = &quot;markdown&quot;})</code>方式指定的规则，优先级高于<code>add_rules(&quot;markdown&quot;)</code>设置的规则。<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#rule">rule</a></td>
<td>定义规则</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleadd_imports">add_imports</a></td>
<td>为所有自定义脚本预先导入扩展模块</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleset_extensions">set_extensions</a></td>
<td>设置规则支持的文件扩展类型</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_load">on_load</a></td>
<td>自定义加载脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleon_link">on_link</a></td>
<td>自定义链接脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#ruleon_build">on_build</a></td>
<td>自定义编译脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_clean">on_clean</a></td>
<td>自定义清理脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_package">on_package</a></td>
<td>自定义打包脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_install">on_install</a></td>
<td>自定义安装脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_uninstall">on_uninstall</a></td>
<td>自定义卸载脚本</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#ruleon_build_file">on_build_file</a></td>
<td>自定义编译脚本, 实现单文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleon_build_files">on_build_files</a></td>
<td>自定义编译脚本, 实现多文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_load">before_load</a></td>
<td>自定义加载前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_link">before_link</a></td>
<td>自定义链接前的脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#rulebefore_build">before_build</a></td>
<td>自定义编译前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_clean">before_clean</a></td>
<td>自定义清理前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_package">before_package</a></td>
<td>自定义打包前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_install">before_install</a></td>
<td>自定义安装前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_uninstall">before_uninstall</a></td>
<td>自定义卸载前的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_build_file">before_build_file</a></td>
<td>自定义编译前的脚本, 实现单文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rulebefore_build_files">before_build_files</a></td>
<td>自定义编译前的脚本, 实现多文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_load">after_load</a></td>
<td>自定义加载后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_link">after_link</a></td>
<td>自定义链接后的脚本</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#ruleafter_build">after_build</a></td>
<td>自定义编译后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_clean">after_clean</a></td>
<td>自定义清理后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_package">after_package</a></td>
<td>自定义打包后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_install">after_install</a></td>
<td>自定义安装后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_uninstall">after_uninstall</a></td>
<td>自定义卸载后的脚本</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_build_file">after_build_file</a></td>
<td>自定义编译后的脚本, 实现单文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#ruleafter_build_files">after_build_files</a></td>
<td>自定义编译后的脚本, 实现多文件构建</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#rule_end">rule_end</a></td>
<td>结束定义规则</td>
<td>&gt;= 2.1.9</td>
</tr>
</tbody>
</table>
<h5 id="-">内建规则</h5>
<p>自从2.2.1版本后，xmake提供了一些内置规则去简化日常xmake.lua描述，以及一些常用构建环境的支持。</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#mode-debug">mode.debug</a></td>
<td>调试模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-release">mode.release</a></td>
<td>发布模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-check">mode.check</a></td>
<td>检测模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-profile">mode.profile</a></td>
<td>性能分析模式编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#mode-coverage">mode.coverage</a></td>
<td>覆盖分析编译模式规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#qt-static">qt.static</a></td>
<td>Qt静态库编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#qt-shared">qt.shared</a></td>
<td>Qt动态库编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#qt-console">qt.console</a></td>
<td>Qt控制台编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#qt-application">qt.application</a></td>
<td>Qt应用程序编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-umdf-driver">wdk.umdf.driver</a></td>
<td>WDK环境umdf驱动编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-umdf-binary">wdk.umdf.binary</a></td>
<td>WDK环境umdf驱动应用编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-kmdf-driver">wdk.kmdf.driver</a></td>
<td>WDK环境kmdf驱动编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-kmdf-binary">wdk.kmdf.binary</a></td>
<td>WDK环境kmdf驱动应用编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-wdm-driver">wdk.wdm.driver</a></td>
<td>WDK环境wdm驱动编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
<tr>
<td><a href="#wdk-wdm-binary">wdk.wdm.binary</a></td>
<td>WDK环境wdm驱动应用编译规则</td>
<td>&gt;= 2.2.1</td>
</tr>
</tbody>
</table>
<h6 id="mode-debug">mode.debug</h6>
<p>为当前工程xmake.lua添加debug编译模式的配置规则，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.debug&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">-- the debug mode
if is_mode(&quot;debug&quot;) then

    -- enable the debug symbols
    set_symbols(&quot;debug&quot;)

    -- disable optimization
    set_optimize(&quot;none&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m debug</code>来切换到此编译模式。</p>
<h6 id="mode-release">mode.release</h6>
<p>为当前工程xmake.lua添加release编译模式的配置规则，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.release&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">-- the release mode
if is_mode(&quot;release&quot;) then

    -- set the symbols visibility: hidden
    set_symbols(&quot;hidden&quot;)

    -- enable fastest optimization
    set_optimize(&quot;fastest&quot;)

    -- strip all symbols
    set_strip(&quot;all&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m release</code>来切换到此编译模式。</p>
<h6 id="mode-check">mode.check</h6>
<p>为当前工程xmake.lua添加check编译模式的配置规则，一般用于内存检测，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.check&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">-- the check mode
if is_mode(&quot;check&quot;) then

    -- enable the debug symbols
    set_symbols(&quot;debug&quot;)

    -- disable optimization
    set_optimize(&quot;none&quot;)

    -- attempt to enable some checkers for pc
    add_cxflags(&quot;-fsanitize=address&quot;, &quot;-ftrapv&quot;)
    add_mxflags(&quot;-fsanitize=address&quot;, &quot;-ftrapv&quot;)
    add_ldflags(&quot;-fsanitize=address&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m check</code>来切换到此编译模式。</p>
<h6 id="mode-profile">mode.profile</h6>
<p>为当前工程xmake.lua添加profile编译模式的配置规则，一般用于性能分析，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.profile&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">-- the profile mode
if is_mode(&quot;profile&quot;) then

    -- enable the debug symbols
    set_symbols(&quot;debug&quot;)

    -- enable gprof
    add_cxflags(&quot;-pg&quot;)
    add_ldflags(&quot;-pg&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m profile</code>来切换到此编译模式。</p>
<h6 id="mode-coverage">mode.coverage</h6>
<p>为当前工程xmake.lua添加coverage编译模式的配置规则，一般用于覆盖分析，例如：</p>
<pre><code class="lang-lua">add_rules(&quot;mode.coverage&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="lang-lua">-- the coverage mode
if is_mode(&quot;coverage&quot;) then
    add_cxflags(&quot;--coverage&quot;)
    add_mxflags(&quot;--coverage&quot;)
    add_ldflags(&quot;--coverage&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m coverage</code>来切换到此编译模式。</p>
<h6 id="qt-static">qt.static</h6>
<p>用于编译生成Qt环境的静态库程序：</p>
<pre><code class="lang-lua">target(&quot;qt_static_library&quot;)
    add_rules(&quot;qt.static&quot;)
    add_files(&quot;src/*.cpp&quot;)
    add_frameworks(&quot;QtNetwork&quot;, &quot;QtGui&quot;)
</code></pre>
<h6 id="qt-shared">qt.shared</h6>
<p>用于编译生成Qt环境的动态库程序：</p>
<pre><code class="lang-lua">target(&quot;qt_shared_library&quot;)
    add_rules(&quot;qt.shared&quot;)
    add_files(&quot;src/*.cpp&quot;)
    add_frameworks(&quot;QtNetwork&quot;, &quot;QtGui&quot;)
</code></pre>
<h6 id="qt-console">qt.console</h6>
<p>用于编译生成Qt环境的控制台程序：</p>
<pre><code class="lang-lua">target(&quot;qt_console&quot;)
    add_rules(&quot;qt.console&quot;)
    add_files(&quot;src/*.cpp&quot;)
</code></pre>
<h6 id="qt-application">qt.application</h6>
<p>用于编译生成Qt环境的ui应用程序。</p>
<p>Quick(qml)应用程序：</p>
<pre><code class="lang-lua">target(&quot;qt_quickapp&quot;)
    add_rules(&quot;qt.application&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/qml.qrc&quot;)
    add_frameworks(&quot;QtQuick&quot;)
</code></pre>
<p>Qt Widgets(ui/moc)应用程序:</p>
<pre><code class="lang-lua">-- add target
target(&quot;qt_widgetapp&quot;)
    add_rules(&quot;qt.application&quot;)
    add_files(&quot;src/*.cpp&quot;) 
    add_files(&quot;src/mainwindow.ui&quot;)
    add_files(&quot;src/mainwindow.h&quot;)  -- 添加带有 Q_OBJECT 的meta头文件
    add_frameworks(&quot;QtWidgets&quot;)
</code></pre>
<p>更多Qt相关描述见：<a href="https://github.com/xmake-io/xmake/issues/160">#160</a></p>
<h6 id="wdk-env-kmdf">wdk.env.kmdf</h6>
<p>应用WDK下kmdf的编译环境设置，需要配合：<code>wdk.[driver|binary|static|shared]</code>等规则来使用。</p>
<h6 id="wdk-env-umdf">wdk.env.umdf</h6>
<p>应用WDK下umdf的编译环境设置，需要配合：<code>wdk.[driver|binary|static|shared]</code>等规则来使用。</p>
<h6 id="wdk-env-wdm">wdk.env.wdm</h6>
<p>应用WDK下wdm的编译环境设置，需要配合：<code>wdk.[driver|binary|static|shared]</code>等规则来使用。</p>
<h6 id="wdk-driver">wdk.driver</h6>
<p>编译生成windows下基于WDK环境的驱动程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">-- add target
target(&quot;echo&quot;)

    -- add rules
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.kmdf&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;) 
    add_files(&quot;driver/*.inx&quot;)

    -- add includedirs
    add_includedirs(&quot;exe&quot;)
</code></pre>
<h6 id="wdk-binary">wdk.binary</h6>
<p>编译生成windows下基于WDK环境的可执行程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">-- add target
target(&quot;app&quot;)

    -- add rules
    add_rules(&quot;wdk.binary&quot;, &quot;wdk.env.umdf&quot;)

    -- add files
    add_files(&quot;exe/*.cpp&quot;) 
</code></pre>
<h6 id="wdk-static">wdk.static</h6>
<p>编译生成windows下基于WDK环境的静态库程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">target(&quot;nonpnp&quot;)

    -- add rules
    add_rules(&quot;wdk.static&quot;, &quot;wdk.env.kmdf&quot;)

    -- add flags for rule: wdk.tracewpp
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TraceEvents(LEVEL,FLAGS,MSG,...)&quot;, &quot;-func:Hexdump((LEVEL,FLAGS,MSG,...))&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
</code></pre>
<h6 id="wdk-shared">wdk.shared</h6>
<p>编译生成windows下基于WDK环境的动态库程序，目前仅支持WDK10环境。</p>
<p>注：需要配合：<code>wdk.env.[umdf|kmdf|wdm]</code>等环境规则使用。</p>
<pre><code class="lang-lua">target(&quot;nonpnp&quot;)

    -- add rules
    add_rules(&quot;wdk.shared&quot;, &quot;wdk.env.wdm&quot;)

    -- add flags for rule: wdk.tracewpp
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TraceEvents(LEVEL,FLAGS,MSG,...)&quot;, &quot;-func:Hexdump((LEVEL,FLAGS,MSG,...))&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
</code></pre>
<h6 id="wdk-tracewpp">wdk.tracewpp</h6>
<p>用于启用tracewpp预处理源文件：</p>
<pre><code class="lang-lua">target(&quot;nonpnp&quot;)

    -- add rules
    add_rules(&quot;wdk.driver&quot;, &quot;wdk.env.kmdf&quot;)

    -- add flags for rule: wdk.tracewpp
    add_values(&quot;wdk.tracewpp.flags&quot;, &quot;-func:TraceEvents(LEVEL,FLAGS,MSG,...)&quot;, &quot;-func:Hexdump((LEVEL,FLAGS,MSG,...))&quot;)

    -- add files
    add_files(&quot;driver/*.c&quot;, {rule = &quot;wdk.tracewpp&quot;}) 
    add_files(&quot;driver/*.rc&quot;)
</code></pre>
<p>更多WDK规则描述见：<a href="https://github.com/xmake-io/xmake/issues/159">#159</a></p>
<h6 id="win-sdk-application">win.sdk.application</h6>
<p>编译生成winsdk应用程序。</p>
<pre><code class="lang-lua">-- add rules
add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)

-- define target
target(&quot;usbview&quot;)

    -- windows application
    add_rules(&quot;win.sdk.application&quot;)

    -- add files
    add_files(&quot;*.c&quot;, &quot;*.rc&quot;)
    add_files(&quot;xmlhelper.cpp&quot;, {rule = &quot;win.sdk.dotnet&quot;})
</code></pre>
<h6 id="wdk-sdk-dotnet">wdk.sdk.dotnet</h6>
<p>用于指定某些c++源文件作为c++.net来编译。</p>
<pre><code class="lang-lua">add_files(&quot;xmlhelper.cpp&quot;, {rule = &quot;win.sdk.dotnet&quot;})
</code></pre>
<h5 id="rule">rule</h5>
<h6 id="-">定义规则</h6>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    set_extensions(&quot;.md&quot;, &quot;.markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. &quot;.html&quot;))
    end)
</code></pre>
<h5 id="rule-add_imports">rule:add_imports</h5>
<h6 id="-">为所有自定义脚本预先导入扩展模块</h6>
<p>使用方式和说明请见：<a href="#targetadd_imports">target:add_imports</a>，用法相同。</p>
<h5 id="rule-set_extensions">rule:set_extensions</h5>
<h6 id="-">设置规则支持的文件扩展类型</h6>
<p>通过设置支持的扩展文件类型，将规则应用于带这些后缀的文件上，例如：</p>
<pre><code class="lang-lua">-- 定义一个markdown文件的构建规则
rule(&quot;markdown&quot;)
    set_extensions(&quot;.md&quot;, &quot;.markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. &quot;.html&quot;))
    end)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)

    -- 使test目标支持markdown文件的构建规则
    add_rules(&quot;markdown&quot;)

    -- 添加markdown文件的构建
    add_files(&quot;src/*.md&quot;)
    add_files(&quot;src/*.markdown&quot;)
</code></pre>
<h5 id="rule-on_load">rule:on_load</h5>
<h6 id="-">自定义加载脚本</h6>
<p>用于实现自定规则的加载脚本，当加载target的时候，会被执行，可在里面自定义设置一些target配置，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    on_load(function (target)
        target:add(&quot;defines&quot;, &quot;-DTEST&quot;)
    end)
</code></pre>
<h5 id="rule-on_link">rule:on_link</h5>
<h6 id="-">自定义链接脚本</h6>
<p>用于实现自定规则的链接脚本，会覆盖被应用的target的默认链接行为，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    on_link(function (target)
    end)
</code></pre>
<h5 id="rule-on_build">rule:on_build</h5>
<h6 id="-">自定义编译脚本</h6>
<p>用于实现自定规则的构建脚本，会覆盖被应用的target的默认构建行为，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_build(function (target)
    end)
</code></pre>
<h5 id="rule-on_clean">rule:on_clean</h5>
<h6 id="-">自定义清理脚本</h6>
<p>用于实现自定规则的清理脚本会，覆盖被应用的target的默认清理行为，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_clean(function (target)
        -- remove sourcefile.html
    end)
</code></pre>
<h5 id="rule-on_package">rule:on_package</h5>
<h6 id="-">自定义打包脚本</h6>
<p>用于实现自定规则的打包脚本，覆盖被应用的target的默认打包行为, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_package(function (target)
        -- package sourcefile.html
    end)
</code></pre>
<h5 id="rule-on_install">rule:on_install</h5>
<h6 id="-">自定义安装脚本</h6>
<p>用于实现自定规则的安装脚本，覆盖被应用的target的默认安装行为, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_install(function (target)
    end)
</code></pre>
<h5 id="rule-on_uninstall">rule:on_uninstall</h5>
<h6 id="-">自定义卸载脚本</h6>
<p>用于实现自定规则的卸载脚本，覆盖被应用的target的默认卸载行为, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_uninstall(function (target)
    end)
</code></pre>
<h5 id="rule-on_build_file">rule:on_build_file</h5>
<h6 id="-">自定义编译脚本，一次处理一个源文件</h6>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_build_file(function (target, sourcefile, opt)
        print(&quot;%%%d: %s&quot;, opt.progress, sourcefile)
    end)
</code></pre>
<p>其中第三个参数opt是可选参数，用于获取一些编译过程中的信息状态，例如：opt.progress 为当期的编译进度。</p>
<h5 id="rule-on_build_files">rule:on_build_files</h5>
<h6 id="-">自定义编译脚本，一次处理多个源文件</h6>
<p>大部分的自定义构建规则，每次都是处理单独一个文件，输出一个目标文件，例如：a.c =&gt; a.o</p>
<p>但是，有些情况下，我们需要同时输入多个源文件一起构建生成一个目标文件，例如：a.c b.c d.c =&gt; x.o</p>
<p>对于这种情况，我们可以通过自定义这个脚本来实现：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    on_build_files(function (target, sourcebatch, opt)
        -- build some source files
        for _, sourcefile in ipairs(sourcebatch.sourcefiles) do
            -- ...
        end
    end)
</code></pre>
<h5 id="rule-before_load">rule:before_load</h5>
<h6 id="-">自定义加载前脚本</h6>
<p>用于实现自定义target加载前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    before_load(function (target)
        target:add(&quot;defines&quot;, &quot;-DTEST&quot;)
    end)
</code></pre>
<h5 id="rule-before_link">rule:before_link</h5>
<h6 id="-">自定义链接前脚本</h6>
<p>用于实现自定义target链接前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    before_link(function (target)
    end)
</code></pre>
<h5 id="rule-before_build">rule:before_build</h5>
<h6 id="-">自定义编译前脚本</h6>
<p>用于实现自定义target构建前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_build(function (target)
    end)
</code></pre>
<h5 id="rule-before_clean">rule:before_clean</h5>
<h6 id="-">自定义清理前脚本</h6>
<p>用于实现自定义target清理前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_clean(function (target)
    end)
</code></pre>
<h5 id="rule-before_package">rule:before_package</h5>
<h6 id="-">自定义打包前脚本</h6>
<p>用于实现自定义target打包前的执行脚本, 例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_package(function (target)
    end)
</code></pre>
<h5 id="rule-before_install">rule:before_install</h5>
<h6 id="-">自定义安装前脚本</h6>
<p>用于实现自定义target安装前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_install(function (target)
    end)
</code></pre>
<h5 id="rule-before_uninstall">rule:before_uninstall</h5>
<h6 id="-">自定义卸载前脚本</h6>
<p>用于实现自定义target卸载前的执行脚本，例如：</p>
<pre><code class="lang-lua">rule(&quot;markdown&quot;)
    before_uninstall(function (target)
    end)
</code></pre>
<h5 id="rule-before_build_file">rule:before_build_file</h5>
<h6 id="-">自定义编译前脚本，一次处理一个源文件</h6>
<p>跟<a href="#ruleon_build_file">rule:on_build_file</a>用法类似，不过这个接口被调用的时机是在编译某个源文件之前，<br>一般用于对某些源文件进行编译前的预处理。</p>
<h5 id="rule-before_build_files">rule:before_build_files</h5>
<h6 id="-">自定义编译前脚本，一次处理多个源文件</h6>
<p>跟<a href="#ruleon_build_files">rule:on_build_files</a>用法类似，不过这个接口被调用的时机是在编译某些源文件之前，<br>一般用于对某些源文件进行编译前的预处理。</p>
<h5 id="rule-after_load">rule:after_load</h5>
<h6 id="-">自定义加载后脚本</h6>
<p>用于实现自定义target加载后的执行脚本，用法跟<a href="#rulebefore_load">rule:before_load</a>类似。</p>
<h5 id="rule-after_link">rule:after_link</h5>
<h6 id="-">自定义链接后脚本</h6>
<p>用于实现自定义target链接后的执行脚本，用法跟<a href="#rulebefore_link">rule:before_link</a>类似。</p>
<h5 id="rule-after_build">rule:after_build</h5>
<h6 id="-">自定义编译后脚本</h6>
<p>用于实现自定义target构建后的执行脚本，用法跟<a href="#rulebefore_build">rule:before_build</a>类似。</p>
<h5 id="rule-after_clean">rule:after_clean</h5>
<h6 id="-">自定义清理后脚本</h6>
<p>用于实现自定义target清理后的执行脚本，用法跟<a href="#rulebefore_clean">rule:before_clean</a>类似。</p>
<h5 id="rule-after_package">rule:after_package</h5>
<h6 id="-">自定义打包后脚本</h6>
<p>用于实现自定义target打包后的执行脚本, 用法跟<a href="#rulebefore_package">rule:before_package</a>类似。</p>
<h5 id="rule-after_install">rule:after_install</h5>
<h6 id="-">自定义安装后脚本</h6>
<p>用于实现自定义target安装后的执行脚本，用法跟<a href="#rulebefore_install">rule:before_install</a>类似。</p>
<h5 id="rule-after_uninstall">rule:after_uninstall</h5>
<h6 id="-">自定义卸载后脚本</h6>
<p>用于实现自定义target卸载后的执行脚本，用法跟<a href="#rulebefore_uninstall">rule:before_uninstall</a>类似。</p>
<h5 id="rule-after_build_file">rule:after_build_file</h5>
<h6 id="-">自定义编译后脚本，一次处理一个源文件</h6>
<p>跟<a href="#ruleon_build_file">rule:on_build_file</a>用法类似，不过这个接口被调用的时机是在编译某个源文件之后，<br>一般用于对某些编译后对象文件进行后期处理。</p>
<h5 id="rule-after_build_files">rule:after_build_files</h5>
<h6 id="-">自定义编译后脚本，一次处理多个源文件</h6>
<p>跟<a href="#ruleon_build_files">rule:on_build_files</a>用法类似，不过这个接口被调用的时机是在编译某些源文件之后，<br>一般用于对某些编译后对象文件进行后期处理。</p>
<h5 id="rule_end">rule_end</h5>
<h6 id="-">结束定义规则</h6>
<p>这个是可选的，如果想要手动结束rule的定义，可以调用它：</p>
<pre><code class="lang-lua">rule(&quot;test&quot;)
    -- ..
rule_end()
</code></pre>
<h4 id="-">库包依赖</h4>
<p>仓库依赖包定义描述，<code>package()</code>相关接口定义，等有时间会详细说明，敬请期待。。</p>
<p>可先参考官方仓库中现有包描述：<a href="https://github.com/xmake-io/xmake-repo">xmake-repo</a></p>
<p>这里给个比较具有代表性的实例供参考：</p>
<pre><code class="lang-lua">package(&quot;libxml2&quot;)

    set_homepage(&quot;http://xmlsoft.org/&quot;)
    set_description(&quot;The XML C parser and toolkit of Gnome.&quot;)

    set_urls(&quot;https://github.com/GNOME/libxml2/archive/$(version).zip&quot;, {excludes = {&quot;*/result/*&quot;, &quot;*/test/*&quot;}})

    add_versions(&quot;v2.9.8&quot;, &quot;c87793e45e66a7aa19200f861873f75195065de786a21c1b469bdb7bfc1230fb&quot;)
    add_versions(&quot;v2.9.7&quot;, &quot;31dd4c0e10fa625b47e27fd6a5295d246c883f214da947b9a4a9e13733905ed9&quot;)

    if is_plat(&quot;macosx&quot;, &quot;linux&quot;) then
        add_deps(&quot;autoconf&quot;, &quot;automake&quot;, &quot;libtool&quot;, &quot;pkg-config&quot;)
    end

    on_load(function (package)
        package:addvar(&quot;includedirs&quot;, &quot;include/libxml2&quot;)
        package:addvar(&quot;links&quot;, &quot;xml2&quot;)
    end)

    if is_plat(&quot;windows&quot;) and winos.version():gt(&quot;winxp&quot;) then
        on_install(&quot;windows&quot;, function (package)
            os.cd(&quot;win32&quot;)
            os.vrun(&quot;cscript configure.js iso8859x=yes iconv=no compiler=msvc cruntime=/MT debug=%s prefix=\&quot;%s\&quot;&quot;, package:debug() and &quot;yes&quot; or &quot;no&quot;, package:installdir())
            os.vrun(&quot;nmake /f Makefile.msvc&quot;)
            os.vrun(&quot;nmake /f Makefile.msvc install&quot;)
        end)
    end

    on_install(&quot;macosx&quot;, &quot;linux&quot;, function (package)
        import(&quot;package.tools.autoconf&quot;).install(package, {&quot;--disable-dependency-tracking&quot;, &quot;--without-python&quot;, &quot;--without-lzma&quot;})
    end)
</code></pre>
<h4 id="-">内置变量</h4>
<p>xmake提供了 <code>$(varname)</code> 的语法，来支持内置变量的获取，例如：</p>
<pre><code class="lang-lua">add_cxflags(&quot;-I$(buildir)&quot;)
</code></pre>
<p>它将会在在实际编译的时候，将内置的 <code>buildir</code> 变量转换为实际的构建输出目录：<code>-I./build</code></p>
<p>一般内置变量可用于在传参时快速获取和拼接变量字符串，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)

    -- 添加工程源码目录下的源文件
    add_files(&quot;$(projectdir)/src/*.c&quot;)

    -- 添加构建目录下的头文件搜索路径
    add_includedirs(&quot;$(buildir)/inc&quot;)
</code></pre>
<p>也可以在自定义脚本的模块接口中使用，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_run(function (target)
        -- 复制当前脚本目录下的头文件到输出目录
        os.cp(&quot;$(scriptdir)/xxx.h&quot;, &quot;$(buildir)/inc&quot;)
    end)
</code></pre>
<p>所有的内置变量，也可以通过<a href="#val">val</a>接口，来获取他们的值。</p>
<p>这种使用内置变量的方式，使得描述编写更加的简洁易读，下面是一些xmake内置的变量，可以直接获取：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#var-os">$(os)</a></td>
<td>获取当前编译平台的操作系统</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-host">$(host)</a></td>
<td>获取本机操作系统</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-tmpdir">$(tmpdir)</a></td>
<td>获取临时目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-curdir">$(curdir)</a></td>
<td>获取当前目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-buildir">$(buildir)</a></td>
<td>获取构建输出目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-scriptdir">$(scriptdir)</a></td>
<td>获取工程描述脚本目录</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#var-globaldir">$(globaldir)</a></td>
<td>获取全局配置目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-configdir">$(configdir)</a></td>
<td>获取本地工程配置目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-programdir">$(programdir)</a></td>
<td>xmake安装脚本目录</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#var-projectdir">$(projectdir)</a></td>
<td>获取工程根目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-shell">$(shell)</a></td>
<td>执行外部shell命令</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#var-env">$(env)</a></td>
<td>获取外部环境变量</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#var-reg">$(reg)</a></td>
<td>获取windows注册表配置项的值</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<p>当然这种变量模式，也是可以扩展的，默认通过<code>xmake f --var=val</code>命令，配置的参数都是可以直接获取，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_defines(&quot;-DTEST=$(var)&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>所有<code>xmake f --xxx=...</code>配置的参数值，都是可以通过内置变量获取到，例如：<code>xmake f --arch=x86</code>对应<code>$(arch)</code>，其他的还有<code>$(plat)</code>, <code>$(mode)</code>等等。<br>具体有哪些参数，可以通过：<code>xmake f -h</code>才查看。<br>&lt;/p&gt;

</p>
<p>既然支持直接从配置选项中获取，那么当然也就能很方便的扩展自定义的选项，来获取自定义的变量了，具体如何自定义选项见：<a href="#option">option</a></p>
<h5 id="var-os-">var.$(os)</h5>
<h6 id="-">获取当前编译平台的操作系统</h6>
<p>如果当前编译的是iphoneos，那么这个值就是：<code>ios</code>，以此类推。</p>
<h5 id="var-host-">var.$(host)</h5>
<h6 id="-">获取本机操作系统</h6>
<p>指的是当前本机环境的主机系统，如果你是在macOS上编译，那么系统就是：<code>macosx</code></p>
<h5 id="var-tmpdir-">var.$(tmpdir)</h5>
<h6 id="-">获取临时目录</h6>
<p>一般用于临时存放一些非永久性文件。</p>
<h5 id="var-curdir-">var.$(curdir)</h5>
<h6 id="-">获取当前目录</h6>
<p>一般默认是执行<code>xmake</code>命令时的工程根目录，当然如果通过<a href="#os-cd">os.cd</a>改变了目录的话，这个值也会一起改变。</p>
<h5 id="var-buildir-">var.$(buildir)</h5>
<h6 id="-">获取当前的构建输出目录</h6>
<p>默认一般为当前工程根目录下的：<code>./build</code>目录，也可以通过执行：<code>xmake f -o /tmp/build</code>命令来修改默认的输出目录。</p>
<h5 id="var-scriptdir-">var.$(scriptdir)</h5>
<h6 id="-">获取当前工程描述脚本的目录</h6>
<p>也就是对应<code>xmake.lua</code>所在的目录路径。</p>
<h5 id="var-globaldir-">var.$(globaldir)</h5>
<h6 id="-">全局配置目录</h6>
<p>xmake的<code>xmake g|global</code>全局配置命令，数据存储的目录路径，在里面可以放置一些自己的插件、平台脚本。</p>
<p>默认为：<code>~/.config</code></p>
<h5 id="var-configdir-">var.$(configdir)</h5>
<h6 id="-">当前工程配置目录</h6>
<p>当前工程的配置存储目录，也就是<code>xmake f|config</code>配置命令的存储目录，默认为：<code>projectdir/.config</code></p>
<h5 id="var-programdir-">var.$(programdir)</h5>
<h6 id="xmake-">xmake安装脚本目录</h6>
<p>也就是<code>XMAKE_PROGRAM_DIR</code>环境变量所在目录，我们也可以通过设置这个环境量，来修改xmake的加载脚本，实现版本切换。</p>
<h5 id="var-projectdir-">var.$(projectdir)</h5>
<h6 id="-">工程根目录</h6>
<p>也就是<code>xmake -P xxx</code>命令中指定的目录路径，默认不指定就是<code>xmake</code>命令执行时的当前目录，一般用于定位工程文件。</p>
<h5 id="var-shell-">var.$(shell)</h5>
<h6 id="-shell-">执行外部shell命令</h6>
<p>除了内置的变量处理，xmake还支持原生shell的运行，来处理一些xmake内置不支持的功能</p>
<p>例如，现在有个需求，我想用在编译linux程序时，调用<code>pkg-config</code>获取到实际的第三方链接库名，可以这么做：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    if is_plat(&quot;linux&quot;) then
        add_ldflags(&quot;$(shell pkg-config --libs sqlite3)&quot;)
    end
</code></pre>
<p>当然，xmake有自己的自动化第三库检测机制，一般情况下不需要这么麻烦，而且lua自身的脚本化已经很不错了。。</p>
<p>但是这个例子可以说明，xmake是完全可以通过原生shell，来与一些第三方的工具进行配合使用。。</p>
<h5 id="var-env-">var.$(env)</h5>
<h6 id="-">获取外部环境变量</h6>
<p>例如，可以通过获取环境变量中的路径：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    add_includedirs(&quot;$(env PROGRAMFILES)/OpenSSL/inc&quot;)
</code></pre>
<h5 id="var-reg-">var.$(reg)</h5>
<h6 id="-windows-">获取windows注册表配置项的值</h6>
<p>通过 <code>regpath; name</code> 的方式获取注册表中某个项的值：</p>
<pre><code class="lang-lua">print(&quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name)&quot;)
</code></pre>
<h4 id="-">内置模块</h4>
<p>在自定义脚本、插件脚本、任务脚本、平台扩展、模板扩展等脚本代码中使用，也就是在类似下面的代码块中，可以使用这些模块接口：</p>
<pre><code class="lang-lua">on_run(function (target)
    print(&quot;hello xmake!&quot;)
end)
</code></pre>
<p>&lt;p class=&quot;warn&quot;&gt;<br>为了保证外层的描述域尽可能简洁、安全，一般不建议在这个域使用接口和模块操作api，因此大部分模块接口只能脚本域使用，来实现复杂功能。&lt;/br&gt;<br>当然少部分只读的内置接口还是可以在描述域使用的，具体见下表：<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>可使用域</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#val">val</a></td>
<td>获取内置变量的值</td>
<td>脚本域</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#import">import</a></td>
<td>导入扩展摸块</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#inherit">inherit</a></td>
<td>导入并继承基类模块</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#ifelse">ifelse</a></td>
<td>类似三元条件判断</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#try-catch-finally">try-catch-finally</a></td>
<td>异常捕获</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#pairs">pairs</a></td>
<td>用于遍历字典</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#ipairs">ipairs</a></td>
<td>用于遍历数组</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#print">print</a></td>
<td>换行打印终端日志</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#printf">printf</a></td>
<td>无换行打印终端日志</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#cprint">cprint</a></td>
<td>换行彩色打印终端日志</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#cprintf">cprintf</a></td>
<td>无换行彩色打印终端日志</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#format">format</a></td>
<td>格式化字符串</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#vformat">vformat</a></td>
<td>格式化字符串，支持内置变量转义</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#raise">raise</a></td>
<td>抛出异常中断程序</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os">os</a></td>
<td>系统操作模块</td>
<td>部分只读操作描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io">io</a></td>
<td>文件操作模块</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path">path</a></td>
<td>路径操作模块</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#table">table</a></td>
<td>数组和字典操作模块</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#string">string</a></td>
<td>字符串操作模块</td>
<td>描述域、脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#process">process</a></td>
<td>进程操作模块</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#coroutine">coroutine</a></td>
<td>协程操作模块</td>
<td>脚本域</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#find_packages">find_packages</a></td>
<td>查找依赖包</td>
<td>脚本域</td>
<td>&gt;= 2.2.5</td>
</tr>
</tbody>
</table>
<p>在描述域使用接口调用的实例如下，一般仅用于条件控制：</p>
<pre><code class="lang-lua">-- 扫描当前xmake.lua目录下的所有子目录，以每个目录的名字定义一个task任务
for _, taskname in ipairs(os.dirs(&quot;*&quot;), path.basename) do
    task(taskname)
        on_run(function ()
        end)
end
</code></pre>
<p>上面所说的脚本域、描述域主要是指：</p>
<pre><code class="lang-lua">-- 描述域
target(&quot;test&quot;)

    -- 描述域
    set_kind(&quot;static&quot;)
    add_files(&quot;src/*.c&quot;)

    on_run(function (target)
        -- 脚本域
    end)

-- 描述域
</code></pre>
<h5 id="val">val</h5>
<h6 id="-">获取内置变量的值</h6>
<p><a href="#内置变量">内置变量</a>可以通过此接口直接获取，而不需要再加<code>$()</code>的包裹，使用更加简单，例如：</p>
<pre><code class="lang-lua">print(val(&quot;host&quot;))
print(val(&quot;env PATH&quot;))
local s = val(&quot;shell echo hello&quot;)
</code></pre>
<p>而用<a href="#vformat">vformat</a>就比较繁琐了：</p>
<pre><code class="lang-lua">local s = vformat(&quot;$(shell echo hello)&quot;)
</code></pre>
<p>不过<code>vformat</code>支持字符串参数格式化，更加强大， 所以应用场景不同。</p>
<h5 id="import">import</h5>
<h6 id="-">导入扩展摸块</h6>
<p>import的主要用于导入xmake的扩展类库以及一些自定义的类库模块，一般用于：</p>
<ul>
<li>自定义脚本(<a href="#targeton_build">on_build</a>, <a href="#targeton_run">on_run</a> ..)</li>
<li>插件开发</li>
<li>模板开发</li>
<li>平台扩展</li>
<li>自定义任务task</li>
</ul>
<p>导入机制如下：</p>
<ol>
<li>优先从当前脚本目录下导入</li>
<li>再从扩展类库中导入</li>
</ol>
<p>导入的语法规则：</p>
<p>基于<code>.</code>的类库路径规则，例如：</p>
<p>导入core核心扩展模块</p>
<pre><code class="lang-lua">import(&quot;core.base.option&quot;)
import(&quot;core.project&quot;)
import(&quot;core.base.task&quot;) -- 2.1.5 以前是 core.project.task
import(&quot;core&quot;)

function main()

    -- 获取参数选项
    print(option.get(&quot;version&quot;))

    -- 运行任务和插件
    task.run(&quot;hello&quot;)
    project.task.run(&quot;hello&quot;)
    core.base.task.run(&quot;hello&quot;)
end
</code></pre>
<p>导入当前目录下的自定义模块：</p>
<p>目录结构：</p>
<pre><code>plugin
  - xmake.lua
  - main.lua
  - modules
    - hello1.lua
    - hello2.lua
</code></pre><p>在main.lua中导入modules</p>
<pre><code class="lang-lua">import(&quot;modules.hello1&quot;)
import(&quot;modules.hello2&quot;)
</code></pre>
<p>导入后就可以直接使用里面的所有公有接口，私有接口用<code>_</code>前缀标示，表明不会被导出，不会被外部调用到。。</p>
<p>除了当前目录，我们还可以导入其他指定目录里面的类库，例如：</p>
<pre><code class="lang-lua">import(&quot;hello3&quot;, {rootdir = &quot;/home/xxx/modules&quot;})
</code></pre>
<p>为了防止命名冲突，导入后还可以指定的别名：</p>
<pre><code class="lang-lua">import(&quot;core.platform.platform&quot;, {alias = &quot;p&quot;})

function main()

    -- 这样我们就可以使用p来调用platform模块的plats接口，获取所有xmake支持的平台列表了
    utils.dump(p.plats())
end
</code></pre>
<p>import不仅可以导入类库，还支持导入的同时作为继承导入，实现模块间的继承关系</p>
<pre><code class="lang-lua">import(&quot;xxx.xxx&quot;, {inherit = true})
</code></pre>
<p>这样导入的不是这个模块的引用，而是导入的这个模块的所有公有接口本身，这样就会跟当前模块的接口进行合并，实现模块间的继承。</p>
<p>2.1.5版本新增两个新属性：<code>import(&quot;xxx.xxx&quot;, {try = true, anonymous = true})</code></p>
<p>try为true，则导入的模块不存在的话，仅仅返回nil，并不会抛异常后中断xmake.<br>anonymous为true，则导入的模块不会引入当前作用域，仅仅在import接口返回导入的对象引用。</p>
<h5 id="inherit">inherit</h5>
<h6 id="-">导入并继承基类模块</h6>
<p>这个等价于<a href="#import">import</a>接口的<code>inherit</code>模式，也就是：</p>
<pre><code class="lang-lua">import(&quot;xxx.xxx&quot;, {inherit = true})
</code></pre>
<p>用<code>inherit</code>接口的话，会更简洁些：</p>
<pre><code class="lang-lu">inherit(&quot;xxx.xxx&quot;)
</code></pre>
<p>使用实例，可以参看xmake的tools目录下的脚本：<a href="#https://github.com/xmake-io/xmake/blob/master/xmake/tools/clang.lua">clang.lua</a></p>
<p>这个就是clang工具模块继承了gcc的部分实现。</p>
<h5 id="ifelse">ifelse</h5>
<h6 id="-">类似三元条件判断</h6>
<p>由于lua没有内置的三元运算符，通过封装<code>ifelse</code>接口，实现更加简洁的条件选择：</p>
<pre><code class="lang-lua">local ok = ifelse(a == 0, &quot;ok&quot;, &quot;no&quot;)
</code></pre>
<h5 id="try-catch-finally">try-catch-finally</h5>
<h6 id="-">异常捕获</h6>
<p>lua原生并没有提供try-catch的语法来捕获异常处理，但是提供了<code>pcall/xpcall</code>等接口，可在保护模式下执行lua函数。</p>
<p>因此，可以通过封装这两个接口，来实现try-catch块的捕获机制。</p>
<p>我们可以先来看下，封装后的try-catch使用方式：</p>
<pre><code class="lang-lua">try
{
    -- try 代码块
    function ()
        error(&quot;error message&quot;)
    end,

    -- catch 代码块
    catch 
    {
        -- 发生异常后，被执行
        function (errors)
            print(errors)
        end
    }
}
</code></pre>
<p>上面的代码中，在try块内部认为引发了一个异常，并且抛出错误消息，在catch中进行了捕获，并且将错误消息进行输出显示。</p>
<p>而finally的处理，这个的作用是对于<code>try{}</code>代码块，不管是否执行成功，都会执行到finally块中</p>
<p>也就说，其实上面的实现，完整的支持语法是：<code>try-catch-finally</code>模式，其中catch和finally都是可选的，根据自己的实际需求提供</p>
<p>例如：</p>
<pre><code class="lang-lua">try
{
    -- try 代码块
    function ()
        error(&quot;error message&quot;)
    end,

    -- catch 代码块
    catch 
    {
        -- 发生异常后，被执行
        function (errors)
            print(errors)
        end
    },

    -- finally 代码块
    finally 
    {
        -- 最后都会执行到这里
        function (ok, errors)
            -- 如果try{}中存在异常，ok为true，errors为错误信息，否则为false，errors为try中的返回值
        end
    }
}

</code></pre>
<p>或者只有finally块：</p>
<pre><code class="lang-lua">try
{
    -- try 代码块
    function ()
        return &quot;info&quot;
    end,

    -- finally 代码块
    finally 
    {
        -- 由于此try代码没发生异常，因此ok为true，errors为返回值: &quot;info&quot;
        function (ok, errors)
        end
    }
}
</code></pre>
<p>处理可以在finally中获取try里面的正常返回值，其实在仅有try的情况下，也是可以获取返回值的：</p>
<pre><code class="lang-lua">-- 如果没发生异常，result 为返回值：&quot;xxxx&quot;，否则为nil
local result = try
{
    function ()
        return &quot;xxxx&quot;
    end
}
</code></pre>
<p>在xmake的自定义脚本、插件开发中，也是完全基于此异常捕获机制</p>
<p>这样使得扩展脚本的开发非常的精简可读，省去了繁琐的<code>if err ~= nil then</code>返回值判断，在发生错误时，xmake会直接抛出异常进行中断，然后高亮提示详细的错误信息。</p>
<p>例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)

    -- 在编译完ios程序后，对目标程序进行ldid签名
    after_build(function (target))
        os.run(&quot;ldid -S %s&quot;, target:targetfile())
    end
</code></pre>
<p>只需要一行<code>os.run</code>就行了，也不需要返回值判断是否运行成功，因为运行失败后，xmake会自动抛异常，中断程序并且提示错误</p>
<p>如果你想在运行失败后，不直接中断xmake，继续往下运行，可以自己加个try快就行了：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)

    after_build(function (target))
        try
        {
            function ()
                os.run(&quot;ldid -S %s&quot;, target:targetfile())
            end
        }
    end
</code></pre>
<p>如果还想捕获出错信息，可以再加个catch:</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)

    after_build(function (target))
        try
        {
            function ()
                os.run(&quot;ldid -S %s&quot;, target:targetfile())
            end,
            catch 
            {
                function (errors)
                    print(errors)
                end
            }
        }
    end
</code></pre>
<p>不过一般情况下，在xmake中写自定义脚本，是不需要手动加try-catch的，直接调用各种api，出错后让xmake默认的处理程序接管，直接中断就行了。。</p>
<h5 id="pairs">pairs</h5>
<h6 id="-">用于遍历字典</h6>
<p>这个是lua原生的内置api，在xmake中，在原有的行为上对其进行了一些扩展，来简化一些日常的lua遍历代码。</p>
<p>先看下默认的原生写法：</p>
<pre><code class="lang-lua">local t = {a = &quot;a&quot;, b = &quot;b&quot;, c = &quot;c&quot;, d = &quot;d&quot;, e = &quot;e&quot;, f = &quot;f&quot;}

for key, val in pairs(t) do
    print(&quot;%s: %s&quot;, key, val)
end
</code></pre>
<p>这对于通常的遍历操作就足够了，但是如果我们相对其中每个遍历出来的元素，获取其大写，我们可以这么写：</p>
<pre><code class="lang-lua">for key, val in pairs(t, function (v) return v:upper() end) do
     print(&quot;%s: %s&quot;, key, val)
end
</code></pre>
<p>甚至传入一些参数到第二个<code>function</code>中，例如：</p>
<pre><code class="lang-lua">for key, val in pairs(t, function (v, a, b) return v:upper() .. a .. b end, &quot;a&quot;, &quot;b&quot;) do
     print(&quot;%s: %s&quot;, key, val)
end
</code></pre>
<h5 id="ipairs">ipairs</h5>
<h6 id="-">用于遍历数组</h6>
<p>这个是lua原生的内置api，在xmake中，在原有的行为上对其进行了一些扩展，来简化一些日常的lua遍历代码。</p>
<p>先看下默认的原生写法：</p>
<pre><code class="lang-lua">for idx, val in ipairs({&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}) do
     print(&quot;%d %s&quot;, idx, val)
end
</code></pre>
<p>扩展写法类似<a href="#pairs">pairs</a>接口，例如：</p>
<pre><code class="lang-lua">for idx, val in ipairs({&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}, function (v) return v:upper() end) do
     print(&quot;%d %s&quot;, idx, val)
end

for idx, val in ipairs({&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}, function (v, a, b) return v:upper() .. a .. b end, &quot;a&quot;, &quot;b&quot;) do
     print(&quot;%d %s&quot;, idx, val)
end
</code></pre>
<p>这样可以简化<code>for</code>块代码的逻辑，例如我要遍历指定目录，获取其中的文件名，但不包括路径，就可以通过这种扩展方式，简化写法：</p>
<pre><code class="lang-lua">for _, filename in ipairs(os.dirs(&quot;*&quot;), path.filename) do
    -- ...
end
</code></pre>
<h5 id="print">print</h5>
<h6 id="-">换行打印终端日志</h6>
<p>此接口也是lua的原生接口，xmake在原有行为不变的基础上也进行了扩展，同时支持：格式化输出、多变量输出。</p>
<p>先看下原生支持的方式：</p>
<pre><code class="lang-lua">print(&quot;hello xmake!&quot;)
print(&quot;hello&quot;, &quot;xmake!&quot;, 123)
</code></pre>
<p>并且同时还支持扩展的格式化写法：</p>
<pre><code class="lang-lua">print(&quot;hello %s!&quot;, &quot;xmake&quot;)
print(&quot;hello xmake! %d&quot;, 123)
</code></pre>
<p>xmake会同时支持这两种写法，内部会去自动智能检测，选择输出行为。</p>
<h5 id="printf">printf</h5>
<h6 id="-">无换行打印终端日志</h6>
<p>类似<a href="#print">print</a>接口，唯一的区别就是不换行。</p>
<h5 id="cprint">cprint</h5>
<h6 id="-">换行彩色打印终端日志</h6>
<p>行为类似<a href="#print">print</a>，区别就是此接口还支持彩色终端输出，并且支持<code>emoji</code>字符输出。</p>
<p>例如：</p>
<pre><code class="lang-lua">    cprint(&#39;${bright}hello xmake&#39;)
    cprint(&#39;${red}hello xmake&#39;)
    cprint(&#39;${bright green}hello ${clear}xmake&#39;)
    cprint(&#39;${blue onyellow underline}hello xmake${clear}&#39;)
    cprint(&#39;${red}hello ${magenta}xmake&#39;)
    cprint(&#39;${cyan}hello ${dim yellow}xmake&#39;)
</code></pre>
<p>显示结果如下：</p>
<p><img src="https://tboox.org/static/img/xmake/cprint_colors.png" alt="cprint_colors"></p>
<p>跟颜色相关的描述，都放置在 <code>${  }</code> 里面，可以同时设置多个不同的属性，例如：</p>
<pre><code>    ${bright red underline onyellow}
</code></pre><p>表示：高亮红色，背景黄色，并且带下滑线</p>
<p>所有这些描述，都会影响后面一整行字符，如果只想显示部分颜色的文字，可以在结束位置，插入<code>${clear}</code>清楚前面颜色描述</p>
<p>例如：</p>
<pre><code>    ${red}hello ${clear}xmake
</code></pre><p>这样的话，仅仅hello是显示红色，其他还是正常默认黑色显示。</p>
<p>其他颜色属于，我这里就不一一介绍，直接贴上xmake代码里面的属性列表吧：</p>
<pre><code class="lang-lua">    colors.keys = 
    {
        -- 属性
        reset       = 0 -- 重置属性
    ,   clear       = 0 -- 清楚属性
    ,   default     = 0 -- 默认属性
    ,   bright      = 1 -- 高亮
    ,   dim         = 2 -- 暗色
    ,   underline   = 4 -- 下划线
    ,   blink       = 5 -- 闪烁
    ,   reverse     = 7 -- 反转颜色
    ,   hidden      = 8 -- 隐藏文字

        -- 前景色 
    ,   black       = 30
    ,   red         = 31
    ,   green       = 32
    ,   yellow      = 33
    ,   blue        = 34
    ,   magenta     = 35 
    ,   cyan        = 36
    ,   white       = 37

        -- 背景色 
    ,   onblack     = 40
    ,   onred       = 41
    ,   ongreen     = 42
    ,   onyellow    = 43
    ,   onblue      = 44
    ,   onmagenta   = 45
    ,   oncyan      = 46
    ,   onwhite     = 47
</code></pre>
<p>除了可以色彩高亮显示外，如果你的终端是在macosx下，lion以上的系统，xmake还可以支持emoji表情的显示哦，对于不支持系统，会<br>忽略显示，例如：</p>
<pre><code class="lang-lua">    cprint(&quot;hello xmake${beer}&quot;)
    cprint(&quot;hello${ok_hand} xmake&quot;)
</code></pre>
<p>上面两行代码，我打印了一个homebrew里面经典的啤酒符号，下面那行打印了一个ok的手势符号，是不是很炫哈。。</p>
<p><img src="https://tboox.org/static/img/xmake/cprint_emoji.png" alt="cprint_emoji"></p>
<p>所有的emoji表情，以及xmake里面对应的key，都可以通过<a href="http://www.emoji-cheat-sheet.com/">emoji符号</a>里面找到。。</p>
<p>2.1.7版本支持24位真彩色输出，如果终端支持的话：</p>
<pre><code class="lang-lua">import(&quot;core.base.colors&quot;)
if colors.truecolor() then
    cprint(&quot;${255;0;0}hello&quot;)
    cprint(&quot;${on;255;0;0}hello${clear} xmake&quot;)
    cprint(&quot;${bright 255;0;0 underline}hello&quot;)
    cprint(&quot;${bright on;255;0;0 0;255;0}hello${clear} xmake&quot;)
end
</code></pre>
<p>xmake对于truecolor的检测支持，是通过<code>$COLORTERM</code>环境变量来实现的，如果你的终端支持truecolor，可以手动设置此环境变量，来告诉xmake启用truecolor支持。</p>
<p>可以通过下面的命令来启用和测试：</p>
<pre><code class="lang-bash">$ export COLORTERM=truecolor
$ xmake --version
</code></pre>
<p>2.1.7版本可通过<code>COLORTERM=nocolor</code>来禁用色彩输出。</p>
<h5 id="cprintf">cprintf</h5>
<h6 id="-">无换行彩色打印终端日志</h6>
<p>此接口类似<a href="#cprint">cprint</a>，区别就是不换行输出。</p>
<h5 id="format">format</h5>
<h6 id="-">格式化字符串</h6>
<p>如果只是想格式化字符串，不进行输出，可以使用这个接口，此接口跟<a href="#string-format">string.format</a>接口等价，只是个接口名简化版。</p>
<pre><code class="lang-lua">local s = format(&quot;hello %s&quot;, xmake)
</code></pre>
<h5 id="vformat">vformat</h5>
<h6 id="-">格式化字符串，支持内置变量转义</h6>
<p>此接口跟<a href="#format">format</a>接口类似，只是增加对内置变量的获取和转义支持。</p>
<pre><code class="lang-lua">local s = vformat(&quot;hello %s $(mode) $(arch) $(env PATH)&quot;, xmake)
</code></pre>
<h5 id="raise">raise</h5>
<h6 id="-">抛出异常中断程序</h6>
<p>如果想在自定义脚本、插件任务中中断xmake运行，可以使用这个接口抛出异常，如果上层没有显示调用<a href="#try-catch-finally">try-catch</a>捕获的话，xmake就会中断执行，并且显示出错信息。</p>
<pre><code class="lang-lua">if (errors) raise(errors)
</code></pre>
<p>如果在try块中抛出异常，就会在catch和finally中进行errors信息捕获，具体见：<a href="#try-catch-finally">try-catch</a></p>
<h5 id="find_packages">find_packages</h5>
<h6 id="-">查找依赖包</h6>
<p>此接口是对<a href="#detect-find_package">lib.detect.find_package</a>接口的封装，提供多个依赖包的查找支持，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_load(function (target)
        target:add(find_packages(&quot;openssl&quot;, &quot;zlib&quot;))
    end)
</code></pre>
<h5 id="os">os</h5>
<p>系统操作模块，属于内置模块，无需使用<a href="#import">import</a>导入，可直接脚本域调用其接口。</p>
<p>此模块也是lua的原生模块，xmake在其基础上进行了扩展，提供更多实用的接口。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>os模块里面只有部分readonly接口（例如：<code>os.getenv</code>, <code>os.arch</code>）是可以在描述域中使用，其他接口只能在脚本域中使用，例如：<code>os.cp</code>, <code>os.rm</code>等<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#os-cp">os.cp</a></td>
<td>复制文件或目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-mv">os.mv</a></td>
<td>移动重命名文件或目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-rm">os.rm</a></td>
<td>删除文件或目录树</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-trycp">os.trycp</a></td>
<td>尝试复制文件或目录</td>
<td>&gt;= 2.1.6</td>
</tr>
<tr>
<td><a href="#os-trymv">os.trymv</a></td>
<td>尝试移动重命名文件或目录</td>
<td>&gt;= 2.1.6</td>
</tr>
<tr>
<td><a href="#os-tryrm">os.tryrm</a></td>
<td>尝试删除文件或目录树</td>
<td>&gt;= 2.1.6</td>
</tr>
<tr>
<td><a href="#os-cd">os.cd</a></td>
<td>进入指定目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-rmdir">os.rmdir</a></td>
<td>删除目录树</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-mkdir">os.mkdir</a></td>
<td>创建指定目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-isdir">os.isdir</a></td>
<td>判断目录是否存在</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-isfile">os.isfile</a></td>
<td>判断文件是否存在</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-exists">os.exists</a></td>
<td>判断文件或目录是否存在</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-dirs">os.dirs</a></td>
<td>遍历获取指定目录下的所有目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-files">os.files</a></td>
<td>遍历获取指定目录下的所有文件</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-filedirs">os.filedirs</a></td>
<td>遍历获取指定目录下的所有文件或目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-run">os.run</a></td>
<td>安静运行程序</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-runv">os.runv</a></td>
<td>安静运行程序，带参数列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#os-exec">os.exec</a></td>
<td>回显运行程序</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-execv">os.execv</a></td>
<td>回显运行程序，带参数列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#os-iorun">os.iorun</a></td>
<td>运行并获取程序输出内容</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-iorunv">os.iorunv</a></td>
<td>运行并获取程序输出内容，带参数列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#os-getenv">os.getenv</a></td>
<td>获取环境变量</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-setenv">os.setenv</a></td>
<td>设置环境变量</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-tmpdir">os.tmpdir</a></td>
<td>获取临时目录路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-tmpfile">os.tmpfile</a></td>
<td>获取临时文件路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-curdir">os.curdir</a></td>
<td>获取当前目录路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-filesize">os.filesize</a></td>
<td>获取文件大小</td>
<td>&gt;= 2.1.9</td>
</tr>
<tr>
<td><a href="#os-scriptdir">os.scriptdir</a></td>
<td>获取脚本目录路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-programdir">os.programdir</a></td>
<td>获取xmake安装主程序脚本目录</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#os-projectdir">os.projectdir</a></td>
<td>获取工程主目录</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#os-arch">os.arch</a></td>
<td>获取当前系统架构</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#os-host">os.host</a></td>
<td>获取当前主机系统</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="os-cp">os.cp</h6>
<ul>
<li>复制文件或目录</li>
</ul>
<p>行为和shell中的<code>cp</code>命令类似，支持路径通配符匹配（使用的是lua模式匹配），支持多文件复制，以及内置变量支持。</p>
<p>例如：</p>
<pre><code class="lang-lua">os.cp(&quot;$(scriptdir)/*.h&quot;, &quot;$(projectdir)/src/test/**.h&quot;, &quot;$(buildir)/inc&quot;)
</code></pre>
<p>上面的代码将：当前<code>xmake.lua</code>目录下的所有头文件、工程源码test目录下的头文件全部复制到<code>$(buildir)</code>输出目录中。</p>
<p>其中<code>$(scriptdir)</code>, <code>$(projectdir)</code> 这些变量是xmake的内置变量，具体详情见：<a href="#内置变量">内置变量</a>的相关文档。</p>
<p>而<code>*.h</code>和<code>**.h</code>中的匹配模式，跟<a href="#targetadd_files">add_files</a>中的类似，前者是单级目录匹配，后者是递归多级目录匹配。</p>
<p>此接口同时支持目录的<code>递归复制</code>，例如：</p>
<pre><code class="lang-lua">-- 递归复制当前目录到临时目录
os.cp(&quot;$(curdir)/test/&quot;, &quot;$(tmpdir)/test&quot;)
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>尽量使用<code>os.cp</code>接口，而不是<code>os.run(&quot;cp ..&quot;)</code>，这样更能保证平台一致性，实现跨平台构建描述。<br>&lt;/p&gt;

</p>
<h6 id="os-mv">os.mv</h6>
<ul>
<li>移动重命名文件或目录</li>
</ul>
<p>跟<a href="#os-cp">os.cp</a>的使用类似，同样支持多文件移动操作和模式匹配，例如：</p>
<pre><code class="lang-lua">-- 移动多个文件到临时目录
os.mv(&quot;$(buildir)/test1&quot;, &quot;$(buildir)/test2&quot;, &quot;$(tmpdir)&quot;)

-- 文件移动不支持批量操作，也就是文件重命名
os.mv(&quot;$(buildir)/libtest.a&quot;, &quot;$(buildir)/libdemo.a&quot;)
</code></pre>
<h6 id="os-rm">os.rm</h6>
<ul>
<li>删除文件或目录树</li>
</ul>
<p>支持递归删除目录，批量删除操作，以及模式匹配和内置变量，例如：</p>
<pre><code class="lang-lua">os.rm(&quot;$(buildir)/inc/**.h&quot;, &quot;$(buildir)/lib/&quot;)
</code></pre>
<h6 id="os-trycp">os.trycp</h6>
<ul>
<li>尝试复制文件或目录</li>
</ul>
<p>跟<a href="#os-cp">os.cp</a>类似，唯一的区别就是，此接口操作失败不会抛出异常中断xmake，而是通过返回值标示是否执行成功。</p>
<pre><code class="lang-lua">if os.trycp(&quot;file&quot;, &quot;dest/file&quot;) then
end
</code></pre>
<h6 id="os-trymv">os.trymv</h6>
<ul>
<li>尝试移动文件或目录</li>
</ul>
<p>跟<a href="#os-mv">os.mv</a>类似，唯一的区别就是，此接口操作失败不会抛出异常中断xmake，而是通过返回值标示是否执行成功。</p>
<pre><code class="lang-lua">if os.trymv(&quot;file&quot;, &quot;dest/file&quot;) then
end
</code></pre>
<h6 id="os-tryrm">os.tryrm</h6>
<ul>
<li>尝试删除文件或目录</li>
</ul>
<p>跟<a href="#os-rm">os.rm</a>类似，唯一的区别就是，此接口操作失败不会抛出异常中断xmake，而是通过返回值标示是否执行成功。</p>
<pre><code class="lang-lua">if os.tryrm(&quot;file&quot;) then
end
</code></pre>
<h6 id="os-cd">os.cd</h6>
<ul>
<li>进入指定目录</li>
</ul>
<p>这个操作用于目录切换，同样也支持内置变量，但是不支持模式匹配和多目录处理，例如：</p>
<pre><code class="lang-lua">-- 进入临时目录
os.cd(&quot;$(tmpdir)&quot;)
</code></pre>
<p>如果要离开进入之前的目录，有多种方式：</p>
<pre><code class="lang-lua">-- 进入上级目录
os.cd(&quot;..&quot;)

-- 进入先前的目录，相当于：cd -
os.cd(&quot;-&quot;)

-- 进入目录前保存之前的目录，用于之后跨级直接切回
local oldir = os.cd(&quot;./src&quot;)
...
os.cd(oldir)
</code></pre>
<h6 id="os-rmdir">os.rmdir</h6>
<ul>
<li>仅删除目录</li>
</ul>
<p>如果不是目录就无法删除。</p>
<h6 id="os-mkdir">os.mkdir</h6>
<ul>
<li>创建目录</li>
</ul>
<p>支持批量创建和内置变量，例如：</p>
<pre><code class="lang-lua">os.mkdir(&quot;$(tmpdir)/test&quot;, &quot;$(buildir)/inc&quot;)
</code></pre>
<h6 id="os-isdir">os.isdir</h6>
<ul>
<li>判断是否为目录</li>
</ul>
<p>如果目录不存在，则返回false</p>
<pre><code class="lang-lua">if os.isdir(&quot;src&quot;) then
    -- ...
end
</code></pre>
<h6 id="os-isfile">os.isfile</h6>
<ul>
<li>判断是否为文件</li>
</ul>
<p>如果文件不存在，则返回false</p>
<pre><code class="lang-lua">if os.isfile(&quot;$(buildir)/libxxx.a&quot;) then
    -- ...
end
</code></pre>
<h6 id="os-exists">os.exists</h6>
<ul>
<li>判断文件或目录是否存在</li>
</ul>
<p>如果文件或目录不存在，则返回false</p>
<pre><code class="lang-lua">-- 判断目录存在
if os.exists(&quot;$(buildir)&quot;) then
    -- ...
end

-- 判断文件存在
if os.exists(&quot;$(buildir)/libxxx.a&quot;) then
    -- ...
end
</code></pre>
<h6 id="os-dirs">os.dirs</h6>
<ul>
<li>遍历获取指定目录下的所有目录</li>
</ul>
<p>支持<a href="#targetadd_files">add_files</a>中的模式匹配，支持递归和非递归模式遍历，返回的结果是一个table数组，如果获取不到，返回空数组，例如：</p>
<pre><code class="lang-lua">-- 递归遍历获取所有子目录
for _, dir in ipairs(os.dirs(&quot;$(buildir)/inc/**&quot;)) do
    print(dir)
end
</code></pre>
<h6 id="os-files">os.files</h6>
<ul>
<li>遍历获取指定目录下的所有文件</li>
</ul>
<p>支持<a href="#targetadd_files">add_files</a>中的模式匹配，支持递归和非递归模式遍历，返回的结果是一个table数组，如果获取不到，返回空数组，例如：</p>
<pre><code class="lang-lua">-- 非递归遍历获取所有子文件
for _, filepath in ipairs(os.files(&quot;$(buildir)/inc/*.h&quot;)) do
    print(filepath)
end
</code></pre>
<h6 id="os-filedirs">os.filedirs</h6>
<ul>
<li>遍历获取指定目录下的所有文件和目录</li>
</ul>
<p>支持<a href="#targetadd_files">add_files</a>中的模式匹配，支持递归和非递归模式遍历，返回的结果是一个table数组，如果获取不到，返回空数组，例如：</p>
<pre><code class="lang-lua">-- 递归遍历获取所有子文件和目录
for _, filedir in ipairs(os.filedirs(&quot;$(buildir)/**&quot;)) do
    print(filedir)
end
</code></pre>
<h6 id="os-run">os.run</h6>
<ul>
<li>安静运行原生shell命令</li>
</ul>
<p>用于执行第三方的shell命令，但不会回显输出，仅仅在出错后，高亮输出错误信息。</p>
<p>此接口支持参数格式化、内置变量，例如：</p>
<pre><code class="lang-lua">-- 格式化参数传入
os.run(&quot;echo hello %s!&quot;, &quot;xmake&quot;)

-- 列举构建目录文件
os.run(&quot;ls -l $(buildir)&quot;)
</code></pre>
<p>&lt;p class=&quot;warn&quot;&gt;<br>使用此接口执行shell命令，容易使构建跨平台性降低，对于<code>os.run(&quot;cp ..&quot;)</code>这种尽量使用<code>os.cp</code>代替。&lt;br&gt;<br>如果必须使用此接口运行shell程序，请自行使用<a href="#config-plat">config.plat</a>接口判断平台支持。<br>&lt;/p&gt;

</p>
<p>更加高级的进程运行和控制，见<a href="#process">process</a>模块接口。</p>
<h6 id="os-runv">os.runv</h6>
<ul>
<li>安静运行原生shell命令，带参数列表</li>
</ul>
<p>跟<a href="#os-run">os.run</a>类似，只是传递参数的方式是通过参数列表传递，而不是字符串命令，例如：</p>
<pre><code class="lang-lua">os.runv(&quot;echo&quot;, {&quot;hello&quot;, &quot;xmake!&quot;})
</code></pre>
<h6 id="os-exec">os.exec</h6>
<ul>
<li>回显运行原生shell命令</li>
</ul>
<p>与<a href="#os-run">os.run</a>接口类似，唯一的不同是，此接口执行shell程序时，是带回显输出的，一般调试的时候用的比较多</p>
<h6 id="os-execv">os.execv</h6>
<ul>
<li>回显运行原生shell命令，带参数列表</li>
</ul>
<p>跟<a href="#os-execv">os.execv</a>类似，只是传递参数的方式是通过参数列表传递，而不是字符串命令，例如：</p>
<pre><code class="lang-lua">os.execv(&quot;echo&quot;, {&quot;hello&quot;, &quot;xmake!&quot;})
</code></pre>
<h6 id="os-iorun">os.iorun</h6>
<ul>
<li>安静运行原生shell命令并获取输出内容</li>
</ul>
<p>与<a href="#os-run">os.run</a>接口类似，唯一的不同是，此接口执行shell程序后，会获取shell程序的执行结果，相当于重定向输出。</p>
<p>可同时获取<code>stdout</code>, <code>stderr</code>中的内容，例如：</p>
<pre><code class="lang-lua">local outdata, errdata = os.iorun(&quot;echo hello xmake!&quot;)
</code></pre>
<h6 id="os-iorunv">os.iorunv</h6>
<ul>
<li>安静运行原生shell命令并获取输出内容，带参数列表</li>
</ul>
<p>跟<a href="#os-iorunv">os.iorunv</a>类似，只是传递参数的方式是通过参数列表传递，而不是字符串命令，例如：</p>
<pre><code class="lang-lua">local result, errors = os.iorunv(&quot;echo&quot;, {&quot;hello&quot;, &quot;xmake!&quot;})
</code></pre>
<h6 id="os-getenv">os.getenv</h6>
<ul>
<li>获取系统环境变量</li>
</ul>
<pre><code class="lang-lua">print(os.getenv(&quot;PATH&quot;))
</code></pre>
<h6 id="os-setenv">os.setenv</h6>
<ul>
<li>设置系统环境变量</li>
</ul>
<pre><code class="lang-lua">os.setenv(&quot;HOME&quot;, &quot;/tmp/&quot;)
</code></pre>
<h6 id="os-tmpdir">os.tmpdir</h6>
<ul>
<li>获取临时目录</li>
</ul>
<p>跟<a href="#var-tmpdir">$(tmpdir)</a>结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。</p>
<pre><code class="lang-lua">print(path.join(os.tmpdir(), &quot;file.txt&quot;))
</code></pre>
<p>等价于：</p>
<pre><code class="lang-lua">print(&quot;$(tmpdir)/file.txt&quot;))
</code></pre>
<h6 id="os-tmpfile">os.tmpfile</h6>
<ul>
<li>获取临时文件路径</li>
</ul>
<p>用于获取生成一个临时文件路径，仅仅是个路径，文件需要自己创建。</p>
<h6 id="os-curdir">os.curdir</h6>
<ul>
<li>获取当前目录路径</li>
</ul>
<p>跟<a href="#var-curdir">$(curdir)</a>结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。</p>
<p>用法参考：<a href="#os-tmpdir">os.tmpdir</a>。</p>
<h6 id="os-filesize">os.filesize</h6>
<ul>
<li>获取文件大小</li>
</ul>
<pre><code class="lang-lua">print(os.filesize(&quot;/tmp/a&quot;))
</code></pre>
<h6 id="os-scriptdir">os.scriptdir</h6>
<ul>
<li>获取当前描述脚本的路径</li>
</ul>
<p>跟<a href="#var-scriptdir">$(scriptdir)</a>结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。</p>
<p>用法参考：<a href="#os-tmpdir">os.tmpdir</a>。</p>
<h6 id="os-programdir">os.programdir</h6>
<ul>
<li>获取xmake安装主程序脚本目录</li>
</ul>
<p>跟<a href="#var-programdir">$(programdir)</a>结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。</p>
<h6 id="os-projectdir">os.projectdir</h6>
<ul>
<li>获取工程主目录</li>
</ul>
<p>跟<a href="#var-projectdir">$(projectdir)</a>结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。</p>
<h6 id="os-arch">os.arch</h6>
<ul>
<li>获取当前系统架构</li>
</ul>
<p>也就是当前主机系统的默认架构，例如我在<code>linux x86_64</code>上执行xmake进行构建，那么返回值是：<code>x86_64</code></p>
<h6 id="os-host">os.host</h6>
<ul>
<li>获取当前主机的操作系统</li>
</ul>
<p>跟<a href="#var-host">$(host)</a>结果一致，例如我在<code>linux x86_64</code>上执行xmake进行构建，那么返回值是：<code>linux</code></p>
<h5 id="io">io</h5>
<p>io操作模块，扩展了lua内置的io模块，提供更多易用的接口。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#io-open">io.open</a></td>
<td>打开文件用于读写</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io-load">io.load</a></td>
<td>从指定路径文件反序列化加载所有table内容</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io-save">io.save</a></td>
<td>序列化保存所有table内容到指定路径文件</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io.readfile">io.readfile</a></td>
<td>从指定路径文件读取所有内容</td>
<td>&gt;= 2.1.3</td>
</tr>
<tr>
<td><a href="#io.writefile">io.writefile</a></td>
<td>写入所有内容到指定路径文件</td>
<td>&gt;= 2.1.3</td>
</tr>
<tr>
<td><a href="#io-gsub">io.gsub</a></td>
<td>全文替换指定路径文件的内容</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io-tail">io.tail</a></td>
<td>读取和显示文件的尾部内容</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io-cat">io.cat</a></td>
<td>读取和显示文件的所有内容</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io-print">io.print</a></td>
<td>带换行格式化输出内容到文件</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#io-printf">io.printf</a></td>
<td>无换行格式化输出内容到文件</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="io-open">io.open</h6>
<ul>
<li>打开文件用于读写</li>
</ul>
<p>这个是属于lua的原生接口，详细使用可以参看lua的官方文档：<a href="https://www.lua.org/pil/21.2.html">The Complete I/O Model</a></p>
<p>如果要读取文件所有内容，可以这么写：</p>
<pre><code class="lang-lua">local file = io.open(&quot;$(tmpdir)/file.txt&quot;, &quot;r&quot;)
if file then
    local data = file:read(&quot;*all&quot;)
    file:close()
end
</code></pre>
<p>或者可以使用<a href="#io.readfile">io.readfile</a>更加快速地读取。</p>
<p>如果要写文件，可以这么操作：</p>
<pre><code class="lang-lua">-- 打开文件：w 为写模式, a 为追加写模式
local file = io.open(&quot;xxx.txt&quot;, &quot;w&quot;)
if file then

    -- 用原生的lua接口写入数据到文件，不支持格式化，无换行，不支持内置变量
    file:write(&quot;hello xmake\n&quot;)

    -- 用xmake扩展的接口写入数据到文件，支持格式化，无换行，不支持内置变量
    file:writef(&quot;hello %s\n&quot;, &quot;xmake&quot;)

    -- 使用xmake扩展的格式化传参写入一行，带换行符，并且支持内置变量
    file:print(&quot;hello %s and $(buildir)&quot;, &quot;xmake&quot;)

    -- 使用xmake扩展的格式化传参写入一行，无换行符，并且支持内置变量
    file:printf(&quot;hello %s and $(buildir) \n&quot;, &quot;xmake&quot;)

    -- 关闭文件
    file:close()
end
</code></pre>
<h6 id="io-load">io.load</h6>
<ul>
<li>从指定路径文件反序列化加载所有table内容</li>
</ul>
<p>可以从文件中加载序列化好的table内容，一般与<a href="#io-save">io.save</a>配合使用，例如：</p>
<pre><code class="lang-lua">-- 加载序列化文件的内容到table
local data = io.load(&quot;xxx.txt&quot;)
if data then

    -- 在终端中dump打印整个table中内容，格式化输出
    utils.dump(data)
end
</code></pre>
<h6 id="io-save">io.save</h6>
<ul>
<li>序列化保存所有table内容到指定路径文件 </li>
</ul>
<p>可以序列化存储table内容到指定文件，一般与<a href="#io-load">io.load</a>配合使用，例如：</p>
<pre><code class="lang-lua">io.save(&quot;xxx.txt&quot;, {a = &quot;a&quot;, b = &quot;b&quot;, c = &quot;c&quot;})
</code></pre>
<p>存储结果为：</p>
<pre><code>{
    [&quot;b&quot;] = &quot;b&quot;
,   [&quot;a&quot;] = &quot;a&quot;
,   [&quot;c&quot;] = &quot;c&quot;
}
</code></pre><h6 id="io-readfile">io.readfile</h6>
<ul>
<li>从指定路径文件读取所有内容</li>
</ul>
<p>可在不打开文件的情况下，直接读取整个文件的内容，更加的方便，例如：</p>
<pre><code class="lang-lua">local data = io.readfile(&quot;xxx.txt&quot;)
</code></pre>
<h6 id="io-writefile">io.writefile</h6>
<ul>
<li>写入所有内容到指定路径文件</li>
</ul>
<p>可在不打开文件的情况下，直接写入整个文件的内容，更加的方便，例如：</p>
<pre><code class="lang-lua">io.writefile(&quot;xxx.txt&quot;, &quot;all data&quot;)
</code></pre>
<h6 id="io-gsub">io.gsub</h6>
<ul>
<li>全文替换指定路径文件的内容</li>
</ul>
<p>类似<a href="#string-gsub">string.gsub</a>接口，全文模式匹配替换内容，不过这里是直接操作文件，例如：</p>
<pre><code class="lang-lua">-- 移除文件所有的空白字符
io.gsub(&quot;xxx.txt&quot;, &quot;%s+&quot;, &quot;&quot;)
</code></pre>
<h6 id="io-tail">io.tail</h6>
<ul>
<li>读取和显示文件的尾部内容</li>
</ul>
<p>读取文件尾部指定行数的数据，并显示，类似<code>cat xxx.txt | tail -n 10</code>命令，例如：</p>
<pre><code class="lang-lua">-- 显示文件最后10行内容
io.tail(&quot;xxx.txt&quot;, 10)
</code></pre>
<h6 id="io-cat">io.cat</h6>
<ul>
<li>读取和显示文件的所有内容</li>
</ul>
<p>读取文件的所有内容并显示，类似<code>cat xxx.txt</code>命令，例如：</p>
<pre><code class="lang-lua">io.cat(&quot;xxx.txt&quot;)
</code></pre>
<h6 id="io-print">io.print</h6>
<ul>
<li>带换行格式化输出内容到文件</li>
</ul>
<p>直接格式化传参输出一行字符串到文件，并且带换行，例如：</p>
<pre><code class="lang-lua">io.print(&quot;xxx.txt&quot;, &quot;hello %s!&quot;, &quot;xmake&quot;)
</code></pre>
<h6 id="io-printf">io.printf</h6>
<ul>
<li>无换行格式化输出内容到文件</li>
</ul>
<p>直接格式化传参输出一行字符串到文件，不带换行，例如：</p>
<pre><code class="lang-lua">io.printf(&quot;xxx.txt&quot;, &quot;hello %s!\n&quot;, &quot;xmake&quot;)
</code></pre>
<h5 id="path">path</h5>
<p>路径操作模块，实现跨平台的路径操作，这是xmake的一个自定义的模块。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#path-join">path.join</a></td>
<td>拼接路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-translate">path.translate</a></td>
<td>转换路径到当前平台的路径风格</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-basename">path.basename</a></td>
<td>获取路径最后不带后缀的文件名</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-filename">path.filename</a></td>
<td>获取路径最后带后缀的文件名</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-extension">path.extension</a></td>
<td>获取路径的后缀名</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-directory">path.directory</a></td>
<td>获取路径最后的目录名</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-relative">path.relative</a></td>
<td>转换成相对路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-absolute">path.absolute</a></td>
<td>转换成绝对路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-is_absolute">path.is_absolute</a></td>
<td>判断是否为绝对路径</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#path-splitenv">path.splitenv</a></td>
<td>分割环境变量中的路径</td>
<td>&gt;= 2.2.7</td>
</tr>
</tbody>
</table>
<h6 id="path-join">path.join</h6>
<ul>
<li>拼接路径</li>
</ul>
<p>将多个路径项进行追加拼接，由于<code>windows/unix</code>风格的路径差异，使用api来追加路径更加跨平台，例如：</p>
<pre><code class="lang-lua">print(path.join(&quot;$(tmpdir)&quot;, &quot;dir1&quot;, &quot;dir2&quot;, &quot;file.txt&quot;))
</code></pre>
<p>上述拼接在unix上相当于：<code>$(tmpdir)/dir1/dir2/file.txt</code>，而在windows上相当于：<code>$(tmpdir)\\dir1\\dir2\\file.txt</code></p>
<p>如果觉得这样很繁琐，不够清晰简洁，可以使用：<a href="path-translate">path.translate</a>方式，格式化转换路径字符串到当前平台支持的格式。</p>
<h6 id="path-translate">path.translate</h6>
<ul>
<li>转换路径到当前平台的路径风格</li>
</ul>
<p>格式化转化指定路径字符串到当前平台支持的路径风格，同时支持<code>windows/unix</code>格式的路径字符串参数传入，甚至混合传入，例如：</p>
<pre><code class="lang-lua">print(path.translate(&quot;$(tmpdir)/dir/file.txt&quot;))
print(path.translate(&quot;$(tmpdir)\\dir\\file.txt&quot;))
print(path.translate(&quot;$(tmpdir)\\dir/dir2//file.txt&quot;))
</code></pre>
<p>上面这三种不同格式的路径字符串，经过<code>translate</code>规范化后，就会变成当前平台支持的格式，并且会去掉冗余的路径分隔符。</p>
<h6 id="path-basename">path.basename</h6>
<ul>
<li>获取路径最后不带后缀的文件名</li>
</ul>
<pre><code class="lang-lua">print(path.basename(&quot;$(tmpdir)/dir/file.txt&quot;))
</code></pre>
<p>显示结果为：<code>file</code></p>
<h6 id="path-filename">path.filename</h6>
<ul>
<li>获取路径最后带后缀的文件名</li>
</ul>
<pre><code class="lang-lua">print(path.filename(&quot;$(tmpdir)/dir/file.txt&quot;))
</code></pre>
<p>显示结果为：<code>file.txt</code></p>
<h6 id="path-extension">path.extension</h6>
<ul>
<li>获取路径的后缀名</li>
</ul>
<pre><code class="lang-lua">print(path.extensione(&quot;$(tmpdir)/dir/file.txt&quot;))
</code></pre>
<p>显示结果为：<code>.txt</code></p>
<h6 id="path-directory">path.directory</h6>
<ul>
<li>获取路径最后的目录名</li>
</ul>
<pre><code class="lang-lua">print(path.directory(&quot;$(tmpdir)/dir/file.txt&quot;))
</code></pre>
<p>显示结果为：<code>dir</code></p>
<h6 id="path-relative">path.relative</h6>
<ul>
<li>转换成相对路径</li>
</ul>
<pre><code class="lang-lua">print(path.relative(&quot;$(tmpdir)/dir/file.txt&quot;, &quot;$(tmpdir)&quot;))
</code></pre>
<p>显示结果为：<code>dir/file.txt</code></p>
<p>第二个参数是指定相对的根目录，如果不指定，则默认相对当前目录：</p>
<pre><code class="lang-lua">os.cd(&quot;$(tmpdir)&quot;)
print(path.relative(&quot;$(tmpdir)/dir/file.txt&quot;))
</code></pre>
<p>这样结果是一样的。</p>
<h6 id="path-absolute">path.absolute</h6>
<ul>
<li>转换成绝对路径</li>
</ul>
<pre><code class="lang-lua">print(path.absolute(&quot;dir/file.txt&quot;, &quot;$(tmpdir)&quot;))
</code></pre>
<p>显示结果为：<code>$(tmpdir)/dir/file.txt</code></p>
<p>第二个参数是指定相对的根目录，如果不指定，则默认相对当前目录：</p>
<pre><code class="lang-lua">os.cd(&quot;$(tmpdir)&quot;)
print(path.absolute(&quot;dir/file.txt&quot;))
</code></pre>
<p>这样结果是一样的。</p>
<h6 id="path-is_absolute">path.is_absolute</h6>
<ul>
<li>判断是否为绝对路径</li>
</ul>
<pre><code class="lang-lua">if path.is_absolute(&quot;/tmp/file.txt&quot;) then
    -- 如果是绝对路径
end
</code></pre>
<h6 id="path-splitenv">path.splitenv</h6>
<ul>
<li>分割环境变量中的路径</li>
</ul>
<pre><code class="lang-lua">local pathes = path.splitenv(vformat(&quot;$(env PATH)&quot;))

-- for windows 
local pathes = path.splitenv(&quot;C:\\Windows;C:\\Windows\\System32&quot;)
-- got { &quot;C:\\Windows&quot;, &quot;C:\\Windows\\System32&quot; }

-- for *nix 
local pathes = path.splitenv(&quot;/usr/bin:/usr/local/bin&quot;)
-- got { &quot;/usr/bin&quot;, &quot;/usr/local/bin&quot; }
</code></pre>
<p>结果为一个包含了输入字符串中路径的数组。</p>
<h5 id="table">table</h5>
<p>table属于lua原生提供的模块，对于原生接口使用可以参考：<a href="https://www.lua.org/manual/5.1/manual.html#5.5">lua官方文档</a></p>
<p>xmake中对其进行了扩展，增加了一些扩展接口：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#table-join">table.join</a></td>
<td>合并多个table并返回</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#table-join2">table.join2</a></td>
<td>合并多个table到第一个table</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#table-unique">table.unique</a></td>
<td>对table中的内容进行去重</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#table-slice">table.slice</a></td>
<td>获取table的切片</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="table-join">table.join</h6>
<ul>
<li>合并多个table并返回</li>
</ul>
<p>可以将多个table里面的元素进行合并后，返回到一个新的table中，例如：</p>
<pre><code class="lang-lua">local newtable = table.join({1, 2, 3}, {4, 5, 6}, {7, 8, 9})
</code></pre>
<p>结果为：<code>{1, 2, 3, 4, 5, 6, 7, 8, 9}</code></p>
<p>并且它也支持字典的合并：</p>
<pre><code class="lang-lua">local newtable = table.join({a = &quot;a&quot;, b = &quot;b&quot;}, {c = &quot;c&quot;}, {d = &quot;d&quot;})
</code></pre>
<p>结果为：<code>{a = &quot;a&quot;, b = &quot;b&quot;, c = &quot;c&quot;, d = &quot;d&quot;}</code></p>
<h6 id="table-join2">table.join2</h6>
<ul>
<li>合并多个table到第一个table</li>
</ul>
<p>类似<a href="#table.join">table.join</a>，唯一的区别是，合并的结果放置在第一个参数中，例如：</p>
<pre><code class="lang-lua">local t = {0, 9}
table.join2(t, {1, 2, 3})
</code></pre>
<p>结果为：<code>t = {0, 9, 1, 2, 3}</code></p>
<h6 id="table-unique">table.unique</h6>
<ul>
<li>对table中的内容进行去重</li>
</ul>
<p>去重table的元素，一般用于数组table，例如：</p>
<pre><code class="lang-lua">local newtable = table.unique({1, 1, 2, 3, 4, 4, 5})
</code></pre>
<p>结果为：<code>{1, 2, 3, 4, 5}</code></p>
<h6 id="table-slice">table.slice</h6>
<ul>
<li>获取table的切片</li>
</ul>
<p>用于提取数组table的部分元素，例如：</p>
<pre><code class="lang-lua">-- 提取第4个元素后面的所有元素，结果：{4, 5, 6, 7, 8, 9}
table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4)

-- 提取第4-8个元素，结果：{4, 5, 6, 7, 8}
table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4, 8)

-- 提取第4-8个元素，间隔步长为2，结果：{4, 6, 8}
table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4, 8, 2)
</code></pre>
<h5 id="string">string</h5>
<p>字符串模块为lua原生自带的模块，具体使用见：<a href="https://www.lua.org/manual/5.1/manual.html#5.4">lua官方手册</a></p>
<p>xmake中对其进行了扩展，增加了一些扩展接口：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#string-startswith">string.startswith</a></td>
<td>判断字符串开头是否匹配</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#string-endswith">string.endswith</a></td>
<td>判断字符串结尾是否匹配</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#string-split">string.split</a></td>
<td>分割字符串</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#string-trim">string.trim</a></td>
<td>去掉字符串左右空白字符</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#string-ltrim">string.ltrim</a></td>
<td>去掉字符串左边空白字符</td>
<td>&gt;= 1.0.1</td>
</tr>
<tr>
<td><a href="#string-rtrim">string.rtrim</a></td>
<td>去掉字符串右边空白字符</td>
<td>&gt;= 1.0.1</td>
</tr>
</tbody>
</table>
<h6 id="string-startswith">string.startswith</h6>
<ul>
<li>判断字符串开头是否匹配</li>
</ul>
<pre><code class="lang-lua">local s = &quot;hello xmake&quot;
if s:startswith(&quot;hello&quot;) then
    print(&quot;match&quot;)
end
</code></pre>
<h6 id="string-endswith">string.endswith</h6>
<ul>
<li>判断字符串结尾是否匹配</li>
</ul>
<pre><code class="lang-lua">local s = &quot;hello xmake&quot;
if s:endswith(&quot;xmake&quot;) then
    print(&quot;match&quot;)
end
</code></pre>
<h6 id="string-split">string.split</h6>
<ul>
<li>分割字符串</li>
</ul>
<p>v2.2.7版本对这个接口做了改进，以下是对2.2.7之后版本的使用说明。</p>
<p>按模式匹配分割字符串，忽略空串，例如：</p>
<pre><code class="lang-lua">(&quot;1\n\n2\n3&quot;):split(&#39;\n&#39;) =&gt; 1, 2, 3
(&quot;abc123123xyz123abc&quot;):split(&#39;123&#39;) =&gt; abc, xyz, abc
(&quot;abc123123xyz123abc&quot;):split(&#39;[123]+&#39;) =&gt; abc, xyz, abc
</code></pre>
<p>按纯文本匹配分割字符串，忽略空串（省去了模式匹配，会提升稍许性能），例如：</p>
<pre><code class="lang-lua">(&quot;1\n\n2\n3&quot;):split(&#39;\n&#39;, {plain = true}) =&gt; 1, 2, 3
(&quot;abc123123xyz123abc&quot;):split(&#39;123&#39;, {plain = true}) =&gt; abc, xyz, abc
</code></pre>
<p>按模式匹配分割字符串，严格匹配，不忽略空串，例如：</p>
<pre><code class="lang-lua">(&quot;1\n\n2\n3&quot;):split(&#39;\n&#39;, {strict = true}) =&gt; 1, , 2, 3
(&quot;abc123123xyz123abc&quot;):split(&#39;123&#39;, {strict = true}) =&gt; abc, , xyz, abc
(&quot;abc123123xyz123abc&quot;):split(&#39;[123]+&#39;, {strict = true}) =&gt; abc, xyz, abc
</code></pre>
<p>按纯文本匹配分割字符串，严格匹配，不忽略空串（省去了模式匹配，会提升稍许性能），例如：</p>
<pre><code class="lang-lua">(&quot;1\n\n2\n3&quot;):split(&#39;\n&#39;, {plain = true, strict = true}) =&gt; 1, , 2, 3
(&quot;abc123123xyz123abc&quot;):split(&#39;123&#39;, {plain = true, strict = true}) =&gt; abc, , xyz, abc
</code></pre>
<p>限制分割块数</p>
<pre><code class="lang-lua">(&quot;1\n\n2\n3&quot;):split(&#39;\n&#39;, {limit = 2}) =&gt; 1, 2\n3
(&quot;1.2.3.4.5&quot;):split(&#39;%.&#39;, {limit = 3}) =&gt; 1, 2, 3.4.5
</code></pre>
<h6 id="string-trim">string.trim</h6>
<ul>
<li>去掉字符串左右空白字符</li>
</ul>
<pre><code class="lang-lua">string.trim(&quot;    hello xmake!    &quot;)
</code></pre>
<p>结果为：&quot;hello xmake!&quot;</p>
<h6 id="string-ltrim">string.ltrim</h6>
<ul>
<li>去掉字符串左边空白字符</li>
</ul>
<pre><code class="lang-lua">string.ltrim(&quot;    hello xmake!    &quot;)
</code></pre>
<p>结果为：&quot;hello xmake!    &quot;</p>
<h6 id="string-rtrim">string.rtrim</h6>
<ul>
<li>去掉字符串右边空白字符</li>
</ul>
<pre><code class="lang-lua">string.rtrim(&quot;    hello xmake!    &quot;)
</code></pre>
<p>结果为：&quot;    hello xmake!&quot;</p>
<h5 id="process">process</h5>
<p>这个是xmake扩展的进程控制模块，用于更加灵活的控制进程，比起：<a href="#os-run">os.run</a>系列灵活性更高，也更底层。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#process-open">process.open</a></td>
<td>打开进程</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#process-wait">process.wait</a></td>
<td>等待进程结束</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#process-close">process.close</a></td>
<td>关闭进程对象</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#process-waitlist">process.waitlist</a></td>
<td>同时等待多个进程</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="process-open">process.open</h6>
<ul>
<li>打开进程</li>
</ul>
<p>通过路径创建运行一个指定程序，并且返回对应的进程对象：</p>
<pre><code class="lang-lua">-- 打开进程，后面两个参数指定需要捕获的stdout, stderr文件路径
local proc = process.open(&quot;echo hello xmake!&quot;, outfile, errfile)
if proc then

    -- 等待进程执行完成
    --
    -- 参数二为等待超时，-1为永久等待，0为尝试获取进程状态
    -- 返回值waitok为等待状态：1为等待进程正常结束，0为进程还在运行中，-1位等待失败
    -- 返回值status为，等待进程结束后，进程返回的状态码
    local waitok, status = process.wait(proc, -1)

    -- 释放进程对象
    process.close(proc)
end
</code></pre>
<h6 id="process-wait">process.wait</h6>
<ul>
<li>等待进程结束</li>
</ul>
<p>具体使用见：<a href="#process-open">process.open</a></p>
<h6 id="process-close">process.close</h6>
<ul>
<li>关闭进程对象</li>
</ul>
<p>具体使用见：<a href="#process-open">process.open</a></p>
<h6 id="process-waitlist">process.waitlist</h6>
<ul>
<li>同时等待多个进程</li>
</ul>
<pre><code class="lang-lua">-- 第二个参数是等待超时，返回进程状态列表
for _, procinfo in ipairs(process.waitlist(procs, -1)) do

    -- 每个进程的：进程对象、进程pid、进程结束状态码
    local proc      = procinfo[1]
    local procid    = procinfo[2]
    local status    = procinfo[3]

end
</code></pre>
<h5 id="utils">utils</h5>
<h6 id="utils-dump">utils.dump</h6>
<ul>
<li>输出所有内容 </li>
</ul>
<p>递归格式化打印输入参数中的所有内容，一般用于调试，例如：</p>
<pre><code class="lang-lua">utils.dump({1, 2, 3})
</code></pre>
<p>结果为：<code>{1, 2, 3}</code></p>
<h5 id="coroutine">coroutine</h5>
<p>协程模块是lua原生自带的模块，具使用见：<a href="https://www.lua.org/manual/5.1/manual.html#5.2">lua官方手册</a></p>
<h4 id="-">扩展模块</h4>
<p>所有扩展模块的使用，都需要通过<a href="#import">import</a>接口，进行导入后才能使用。</p>
<h5 id="core-base-option">core.base.option</h5>
<p>一般用于获取xmake命令参数选项的值，常用于插件开发。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#option-get">option.get</a></td>
<td>获取参数选项值</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="option-get">option.get</h6>
<ul>
<li>获取参数选项值</li>
</ul>
<p>在插件开发中用于获取参数选项值，例如：</p>
<pre><code class="lang-lua">-- 导入选项模块
import(&quot;core.base.option&quot;)

-- 插件入口函数
function main(...)
    print(option.get(&quot;info&quot;))
end
</code></pre>
<p>上面的代码获取hello插件，执行：<code>xmake hello --info=xxxx</code> 命令时候传入的<code>--info=</code>选项的值，并显示：<code>xxxx</code></p>
<p>对于非main入口的task任务或插件，可以这么使用：</p>
<pre><code class="lang-lua">task(&quot;hello&quot;)
    on_run(function ())
        import(&quot;core.base.option&quot;)
        print(option.get(&quot;info&quot;))
    end)
</code></pre>
<h5 id="core-base-global">core.base.global</h5>
<p>用于获取xmake全局的配置信息，也就是<code>xmake g|global --xxx=val</code> 传入的参数选项值。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#global-get">global.get</a></td>
<td>获取指定配置值</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#global-load">global.load</a></td>
<td>加载配置</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#global-directory">global.directory</a></td>
<td>获取全局配置信息目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#global-dump">global.dump</a></td>
<td>打印输出所有全局配置信息</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之前为<code>core.project.global</code>。<br>&lt;/p&gt;

</p>
<h6 id="global-get">global.get</h6>
<ul>
<li>获取指定配置值</li>
</ul>
<p>类似<a href="#config-get">config.get</a>，唯一的区别就是这个是从全局配置中获取。</p>
<h6 id="global-load">global.load</h6>
<ul>
<li>加载配置</li>
</ul>
<p>类似<a href="#global-get">global.get</a>，唯一的区别就是这个是从全局配置中加载。</p>
<h6 id="global-directory">global.directory</h6>
<ul>
<li>获取全局配置信息目录</li>
</ul>
<p>默认为<code>~/.config</code>目录。</p>
<h6 id="global-dump">global.dump</h6>
<ul>
<li>打印输出所有全局配置信息</li>
</ul>
<p>输出结果如下：</p>
<pre><code class="lang-lua">{
    clean = true
,   ccache = &quot;ccache&quot;
,   xcode_dir = &quot;/Applications/Xcode.app&quot;
}
</code></pre>
<h5 id="core-base-task">core.base.task</h5>
<p>用于任务操作，一般用于在自定义脚本中、插件任务中，调用运行其他task任务。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#task-run">task.run</a></td>
<td>运行指定任务</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本之前为<code>core.project.task</code>。<br>&lt;/p&gt;

</p>
<h6 id="task-run">task.run</h6>
<ul>
<li>运行指定任务</li>
</ul>
<p>用于在自定义脚本、插件任务中运行<a href="#task">task</a>定义的任务或插件，例如：</p>
<pre><code class="lang-lua">task(&quot;hello&quot;)
    on_run(function ()
        print(&quot;hello xmake!&quot;)
    end)

target(&quot;demo&quot;)
    on_clean(function(target)

        -- 导入task模块
        import(&quot;core.base.task&quot;)

        -- 运行这个hello task
        task.run(&quot;hello&quot;)
    end)
</code></pre>
<p>我们还可以在运行任务时，增加参数传递，例如：</p>
<pre><code class="lang-lua">task(&quot;hello&quot;)
    on_run(function (arg1, arg2)
        print(&quot;hello xmake: %s %s!&quot;, arg1, arg2)
    end)

target(&quot;demo&quot;)
    on_clean(function(target)

        -- 导入task
        import(&quot;core.base.task&quot;)

        -- {} 这个是给第一种选项传参使用，这里置空，这里在最后面传入了两个参数：arg1, arg2
        task.run(&quot;hello&quot;, {}, &quot;arg1&quot;, &quot;arg2&quot;)
    end)
</code></pre>
<p>对于<code>task.run</code>的第二个参数，用于传递命令行菜单中的选项，而不是直接传入<code>function (arg, ...)</code>函数入口中，例如：</p>
<pre><code class="lang-lua">-- 导入task
import(&quot;core.base.task&quot;)

-- 插件入口
function main(...)

    -- 运行内置的xmake配置任务，相当于：xmake f|config --plat=iphoneos --arch=armv7
    task.run(&quot;config&quot;, {plat=&quot;iphoneos&quot;, arch=&quot;armv7&quot;})
emd
</code></pre>
<h5 id="core-tool-linker">core.tool.linker</h5>
<p>链接器相关操作，常用于插件开发。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#linker-link">linker.link</a></td>
<td>执行链接</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#linker-linkcmd">linker.linkcmd</a></td>
<td>获取链接命令行</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#linker-linkargv">linker.linkargv</a></td>
<td>获取链接命令行列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#linker-linkflags">linker.linkflags</a></td>
<td>获取链接选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#linker-has_flags">linker.has_flags</a></td>
<td>判断指定链接选项是否支持</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<h6 id="linker-link">linker.link</h6>
<ul>
<li>执行链接</li>
</ul>
<p>针对target，链接指定对象文件列表，生成对应的目标文件，例如：</p>
<pre><code class="lang-lua">linker.link(&quot;binary&quot;, &quot;cc&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {target = target})
</code></pre>
<p>其中<a href="#target">target</a>，为工程目标，这里传入，主要用于获取target特定的链接选项，具体如果获取工程目标对象，见：<a href="#core-project-project">core.project.project</a></p>
<p>当然也可以不指定target，例如：</p>
<pre><code class="lang-lua">linker.link(&quot;binary&quot;, &quot;cc&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, &quot;/tmp/targetfile&quot;)
</code></pre>
<p>第一个参数指定链接类型，目前支持：binary, static, shared<br>第二个参数告诉链接器，应该作为那种源文件对象进行链接，这些对象源文件使用什么编译器编译的，例如：</p>
<table>
<thead>
<tr>
<th>第二个参数值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cc</td>
<td>c编译器</td>
</tr>
<tr>
<td>cxx</td>
<td>c++编译器</td>
</tr>
<tr>
<td>mm</td>
<td>objc编译器</td>
</tr>
<tr>
<td>mxx</td>
<td>objc++编译器</td>
</tr>
<tr>
<td>gc</td>
<td>go编译器</td>
</tr>
<tr>
<td>as</td>
<td>汇编器</td>
</tr>
<tr>
<td>sc</td>
<td>swift编译器</td>
</tr>
<tr>
<td>rc</td>
<td>rust编译器</td>
</tr>
<tr>
<td>dc</td>
<td>dlang编译器</td>
</tr>
</tbody>
</table>
<p>指定不同的编译器类型，链接器会适配最合适的链接器来处理链接，并且如果几种支持混合编译的语言，那么可以同时传入多个编译器类型，指定链接器选择支持这些混合编译语言的链接器进行链接处理：</p>
<pre><code class="lang-lua">linker.link(&quot;binary&quot;, {&quot;cc&quot;, &quot;mxx&quot;, &quot;sc&quot;}, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, &quot;/tmp/targetfile&quot;)
</code></pre>
<p>上述代码告诉链接器，a, b, c三个对象文件有可能分别是c, objc++, swift代码编译出来的，链接器会从当前系统和工具链中选择最合适的链接器去处理这个链接过程。</p>
<h6 id="linker-linkcmd">linker.linkcmd</h6>
<ul>
<li>获取链接命令行字符串</li>
</ul>
<p>直接获取<a href="#linker-link">linker.link</a>中执行的命令行字符串，相当于：</p>
<pre><code class="lang-lua">local cmdstr = linker.linkcmd(&quot;static&quot;, &quot;cxx&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {target = target})
</code></pre>
<p>注：后面<code>{target = target}</code>扩展参数部分是可选的，如果传递了target对象，那么生成的链接命令，会加上这个target配置对应的链接选项。</p>
<p>并且还可以自己传递各种配置，例如：</p>
<pre><code class="lang-lua">local cmdstr = linker.linkcmd(&quot;static&quot;, &quot;cxx&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {config = {linkdirs = &quot;/usr/lib&quot;}})
</code></pre>
<h6 id="linker-linkargv">linker.linkargv</h6>
<ul>
<li>获取链接命令行参数列表</li>
</ul>
<p>跟<a href="#linker-linkcmd">linker.linkcmd</a>稍微有点区别的是，此接口返回的是参数列表，table表示，更加方便操作：</p>
<pre><code class="lang-lua">local program, argv = linker.linkargv(&quot;static&quot;, &quot;cxx&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {target = target})
</code></pre>
<p>其中返回的第一个值是主程序名，后面是参数列表，而<code>os.args(table.join(program, argv))</code>等价于<code>linker.linkcmd</code>。</p>
<p>我们也可以通过传入返回值给<a href="#os-runv">os.runv</a>来直接运行它：<code>os.runv(linker.linkargv(..))</code></p>
<h6 id="linker-linkflags">linker.linkflags</h6>
<ul>
<li>获取链接选项</li>
</ul>
<p>获取<a href="#linker-linkcmd">linker.linkcmd</a>中的链接选项字符串部分，不带shellname和对象文件列表，并且是按数组返回，例如：</p>
<pre><code class="lang-lua">local flags = linker.linkflags(&quot;shared&quot;, &quot;cc&quot;, {target = target})
for _, flag in ipairs(flags) do
    print(flag)
end
</code></pre>
<p>返回的是flags的列表数组。</p>
<h6 id="linker-has_flags">linker.has_flags</h6>
<ul>
<li>判断指定链接选项是否支持</li>
</ul>
<p>虽然通过<a href="detect-has_flags">lib.detect.has_flags</a>也能判断，但是那个接口更加底层，需要指定链接器名称<br>而此接口只需要指定target的目标类型，源文件类型，它会自动切换选择当前支持的链接器。</p>
<pre><code class="lang-lua">if linker.has_flags(target:targetkind(), target:sourcekinds(), &quot;-L/usr/lib -lpthread&quot;) then
    -- ok
end
</code></pre>
<h5 id="core-tool-compiler">core.tool.compiler</h5>
<p>编译器相关操作，常用于插件开发。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#compiler-compile">compiler.compile</a></td>
<td>执行编译</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#compiler-compcmd">compiler.compcmd</a></td>
<td>获取编译命令行</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#compiler-compargv">compiler.compargv</a></td>
<td>获取编译命令行列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#compiler-compflags">compiler.compflags</a></td>
<td>获取编译选项</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#compiler-has_flags">compiler.has_flags</a></td>
<td>判断指定编译选项是否支持</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#compiler-features">compiler.features</a></td>
<td>获取所有编译器特性</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#compiler-has_features">compiler.has_features</a></td>
<td>判断指定编译特性是否支持</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<h6 id="compiler-compile">compiler.compile</h6>
<ul>
<li>执行编译</li>
</ul>
<p>针对target，链接指定对象文件列表，生成对应的目标文件，例如：</p>
<pre><code class="lang-lua">compiler.compile(&quot;xxx.c&quot;, &quot;xxx.o&quot;, &quot;xxx.h.d&quot;, {target = target})
</code></pre>
<p>其中<a href="#target">target</a>，为工程目标，这里传入主要用于获取taeget的特定编译选项，具体如果获取工程目标对象，见：<a href="#core-project-project">core.project.project</a></p>
<p>而<code>xxx.h.d</code>文件用于存储为此源文件的头文件依赖文件列表，最后这两个参数都是可选的，编译的时候可以不传他们：</p>
<pre><code class="lang-lua">compiler.compile(&quot;xxx.c&quot;, &quot;xxx.o&quot;)
</code></pre>
<p>来单纯编译一个源文件。</p>
<h6 id="compiler-compcmd">compiler.compcmd</h6>
<ul>
<li>获取编译命令行</li>
</ul>
<p>直接获取<a href="#compiler-compile">compiler.compile</a>中执行的命令行字符串，相当于：</p>
<pre><code class="lang-lua">local cmdstr = compiler.compcmd(&quot;xxx.c&quot;, &quot;xxx.o&quot;, {target = target})
</code></pre>
<p>注：后面<code>{target = target}</code>扩展参数部分是可选的，如果传递了target对象，那么生成的编译命令，会加上这个target配置对应的链接选项。</p>
<p>并且还可以自己传递各种配置，例如：</p>
<pre><code class="lang-lua">local cmdstr = compiler.compcmd(&quot;xxx.c&quot;, &quot;xxx.o&quot;, {config = {includedirs = &quot;/usr/include&quot;, defines = &quot;DEBUG&quot;}})
</code></pre>
<p>通过target，我们可以导出指定目标的所有源文件编译命令：</p>
<pre><code class="lang-lua">import(&quot;core.project.project&quot;)

for _, target in pairs(project.targets()) do
    for sourcekind, sourcebatch in pairs(target:sourcebatches()) do
        for index, objectfile in ipairs(sourcebatch.objectfiles) do
            local cmdstr = compiler.compcmd(sourcebatch.sourcefiles[index], objectfile, {target = target})
        end
    end
end
</code></pre>
<h6 id="compiler-compargv">compiler.compargv</h6>
<ul>
<li>获取编译命令行列表</li>
</ul>
<p>跟<a href="#compiler-compargv">compiler.compargv</a>稍微有点区别的是，此接口返回的是参数列表，table表示，更加方便操作：</p>
<pre><code class="lang-lua">local program, argv = compiler.compargv(&quot;xxx.c&quot;, &quot;xxx.o&quot;)
</code></pre>
<h6 id="compiler-compflags">compiler.compflags</h6>
<ul>
<li>获取编译选项</li>
</ul>
<p>获取<a href="#compiler-compcmd">compiler.compcmd</a>中的编译选项字符串部分，不带shellname和文件列表，例如：</p>
<pre><code class="lang-lua">local flags = compiler.compflags(sourcefile, {target = target})
for _, flag in ipairs(flags) do
    print(flag)
end
</code></pre>
<p>返回的是flags的列表数组。</p>
<h6 id="compiler-has_flags">compiler.has_flags</h6>
<ul>
<li>判断指定编译选项是否支持</li>
</ul>
<p>虽然通过<a href="detect-has_flags">lib.detect.has_flags</a>也能判断，但是那个接口更加底层，需要指定编译器名称。<br>而此接口只需要指定语言类型，它会自动切换选择当前支持的编译器。</p>
<pre><code class="lang-lua">-- 判断c语言编译器是否支持选项: -g
if compiler.has_flags(&quot;c&quot;, &quot;-g&quot;) then
    -- ok
end

-- 判断c++语言编译器是否支持选项: -g
if compiler.has_flags(&quot;cxx&quot;, &quot;-g&quot;) then
    -- ok
end
</code></pre>
<h6 id="compiler-features">compiler.features</h6>
<ul>
<li>获取所有编译器特性</li>
</ul>
<p>虽然通过<a href="detect-features">lib.detect.features</a>也能获取，但是那个接口更加底层，需要指定编译器名称。<br>而此接口只需要指定语言类型，它会自动切换选择当前支持的编译器，然后获取当前的编译器特性列表。</p>
<pre><code class="lang-lua">-- 获取当前c语言编译器的所有特性
local features = compiler.features(&quot;c&quot;)

-- 获取当前c++语言编译器的所有特性，启用c++11标准，否则获取不到新标准的特性
local features = compiler.features(&quot;cxx&quot;, {config = {cxxflags = &quot;-std=c++11&quot;}})

-- 获取当前c++语言编译器的所有特性，传递工程target的所有配置信息
local features = compiler.features(&quot;cxx&quot;, {target = target, config = {defines = &quot;..&quot;, includedirs = &quot;..&quot;}})
</code></pre>
<p>所有c编译器特性列表：</p>
<table>
<thead>
<tr>
<th>特性名</th>
</tr>
</thead>
<tbody>
<tr>
<td>c_static_assert</td>
</tr>
<tr>
<td>c_restrict</td>
</tr>
<tr>
<td>c_variadic_macros</td>
</tr>
<tr>
<td>c_function_prototypes</td>
</tr>
</tbody>
</table>
<p>所有c++编译器特性列表：</p>
<table>
<thead>
<tr>
<th>特性名</th>
</tr>
</thead>
<tbody>
<tr>
<td>cxx_variable_templates</td>
</tr>
<tr>
<td>cxx_relaxed_constexpr</td>
</tr>
<tr>
<td>cxx_aggregate_default_initializers</td>
</tr>
<tr>
<td>cxx_contextual_conversions</td>
</tr>
<tr>
<td>cxx_attribute_deprecated</td>
</tr>
<tr>
<td>cxx_decltype_auto</td>
</tr>
<tr>
<td>cxx_digit_separators</td>
</tr>
<tr>
<td>cxx_generic_lambdas</td>
</tr>
<tr>
<td>cxx_lambda_init_captures</td>
</tr>
<tr>
<td>cxx_binary_literals</td>
</tr>
<tr>
<td>cxx_return_type_deduction</td>
</tr>
<tr>
<td>cxx_decltype_incomplete_return_types</td>
</tr>
<tr>
<td>cxx_reference_qualified_functions</td>
</tr>
<tr>
<td>cxx_alignof</td>
</tr>
<tr>
<td>cxx_attributes</td>
</tr>
<tr>
<td>cxx_inheriting_constructors</td>
</tr>
<tr>
<td>cxx_thread_local</td>
</tr>
<tr>
<td>cxx_alias_templates</td>
</tr>
<tr>
<td>cxx_delegating_constructors</td>
</tr>
<tr>
<td>cxx_extended_friend_declarations</td>
</tr>
<tr>
<td>cxx_final</td>
</tr>
<tr>
<td>cxx_nonstatic_member_init</td>
</tr>
<tr>
<td>cxx_override</td>
</tr>
<tr>
<td>cxx_user_literals</td>
</tr>
<tr>
<td>cxx_constexpr</td>
</tr>
<tr>
<td>cxx_defaulted_move_initializers</td>
</tr>
<tr>
<td>cxx_enum_forward_declarations</td>
</tr>
<tr>
<td>cxx_noexcept</td>
</tr>
<tr>
<td>cxx_nullptr</td>
</tr>
<tr>
<td>cxx_range_for</td>
</tr>
<tr>
<td>cxx_unrestricted_unions</td>
</tr>
<tr>
<td>cxx_explicit_conversions</td>
</tr>
<tr>
<td>cxx_lambdas</td>
</tr>
<tr>
<td>cxx_local_type_template_args</td>
</tr>
<tr>
<td>cxx_raw_string_literals</td>
</tr>
<tr>
<td>cxx_auto_type</td>
</tr>
<tr>
<td>cxx_defaulted_functions</td>
</tr>
<tr>
<td>cxx_deleted_functions</td>
</tr>
<tr>
<td>cxx_generalized_initializers</td>
</tr>
<tr>
<td>cxx_inline_namespaces</td>
</tr>
<tr>
<td>cxx_sizeof_member</td>
</tr>
<tr>
<td>cxx_strong_enums</td>
</tr>
<tr>
<td>cxx_trailing_return_types</td>
</tr>
<tr>
<td>cxx_unicode_literals</td>
</tr>
<tr>
<td>cxx_uniform_initialization</td>
</tr>
<tr>
<td>cxx_variadic_templates</td>
</tr>
<tr>
<td>cxx_decltype</td>
</tr>
<tr>
<td>cxx_default_function_template_args</td>
</tr>
<tr>
<td>cxx_long_long_type</td>
</tr>
<tr>
<td>cxx_right_angle_brackets</td>
</tr>
<tr>
<td>cxx_rvalue_references</td>
</tr>
<tr>
<td>cxx_static_assert</td>
</tr>
<tr>
<td>cxx_extern_templates</td>
</tr>
<tr>
<td>cxx_func_identifier</td>
</tr>
<tr>
<td>cxx_variadic_macros</td>
</tr>
<tr>
<td>cxx_template_template_parameters</td>
</tr>
</tbody>
</table>
<h6 id="compiler-has_features">compiler.has_features</h6>
<ul>
<li>判断指定的编译器特性是否支持</li>
</ul>
<p>虽然通过<a href="detect-has-features">lib.detect.has_features</a>也能获取，但是那个接口更加底层，需要指定编译器名称。<br>而此接口只需要指定需要检测的特姓名称列表，就能自动切换选择当前支持的编译器，然后判断指定特性在当前的编译器中是否支持。</p>
<pre><code class="lang-lua">if compiler.has_features(&quot;c_static_assert&quot;) then
    -- ok
end

if compiler.has_features({&quot;c_static_assert&quot;, &quot;cxx_constexpr&quot;}, {languages = &quot;cxx11&quot;}) then
    -- ok
end

if compiler.has_features(&quot;cxx_constexpr&quot;, {target = target, defines = &quot;..&quot;, includedirs = &quot;..&quot;}) then
    -- ok
end
</code></pre>
<p>具体特性名有哪些，可以参考：<a href="#compiler-features">compiler.features</a>。</p>
<h5 id="core-project-config">core.project.config</h5>
<p>用于获取工程编译时候的配置信息，也就是<code>xmake f|config --xxx=val</code> 传入的参数选项值。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#config-get">config.get</a></td>
<td>获取指定配置值</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#config-load">config.load</a></td>
<td>加载配置</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#config-arch">config.arch</a></td>
<td>获取当前工程的架构配置</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#config-plat">config.plat</a></td>
<td>获取当前工程的平台配置</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#config-mode">config.mode</a></td>
<td>获取当前工程的编译模式配置</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#config-buildir">config.buildir</a></td>
<td>获取当前工程的输出目录配置</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#config-directory">config.directory</a></td>
<td>获取当前工程的配置信息目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#config-dump">config.dump</a></td>
<td>打印输出当前工程的所有配置信息</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="config-get">config.get</h6>
<ul>
<li>获取指定配置值</li>
</ul>
<p>用于获取<code>xmake f|config --xxx=val</code>的配置值，例如：</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_run(function (target)

        -- 导入配置模块
        import(&quot;core.project.config&quot;)

        -- 获取配置值
        print(config.get(&quot;xxx&quot;))
    end)
</code></pre>
<h6 id="config-load">config.load</h6>
<ul>
<li>加载配置</li>
</ul>
<p>一般用于插件开发中，插件任务中不像工程的自定义脚本，环境需要自己初始化加载，默认工程配置是没有被加载的，如果要用<a href="#config-get">config.get</a>接口获取工程配置，那么需要先：</p>
<pre><code class="lang-lua">
-- 导入配置模块
import(&quot;core.project.config&quot;)

function main(...)

    -- 先加载工程配置
    config.load()

    -- 获取配置值
    print(config.get(&quot;xxx&quot;))
end
</code></pre>
<h6 id="config-arch">config.arch</h6>
<ul>
<li>获取当前工程的架构配置</li>
</ul>
<p>也就是获取<code>xmake f|config --arch=armv7</code>的平台配置，相当于<code>config.get(&quot;arch&quot;)</code>。</p>
<h6 id="config-plat">config.plat</h6>
<ul>
<li>获取当前工程的平台配置</li>
</ul>
<p>也就是获取<code>xmake f|config --plat=iphoneos</code>的平台配置，相当于<code>config.get(&quot;plat&quot;)</code>。</p>
<h6 id="config-mode">config.mode</h6>
<ul>
<li>获取当前工程的编译模式配置</li>
</ul>
<p>也就是获取<code>xmake f|config --mode=debug</code>的平台配置，相当于<code>config.get(&quot;mode&quot;)</code>。</p>
<h6 id="config-buildir">config.buildir</h6>
<ul>
<li>获取当前工程的输出目录配置</li>
</ul>
<p>也就是获取<code>xmake f|config -o /tmp/output</code>的平台配置，相当于<code>config.get(&quot;buildir&quot;)</code>。</p>
<h6 id="config-directory">config.directory</h6>
<ul>
<li>获取当前工程的配置信息目录</li>
</ul>
<p>获取工程配置的存储目录，默认为：<code>projectdir/.config</code></p>
<h6 id="config-dump">config.dump</h6>
<ul>
<li>打印输出当前工程的所有配置信息</li>
</ul>
<p>输出结果例如：</p>
<pre><code class="lang-lua">{
    sh = &quot;xcrun -sdk macosx clang++&quot;
,   xcode_dir = &quot;/Applications/Xcode.app&quot;
,   ar = &quot;xcrun -sdk macosx ar&quot;
,   small = true
,   object = false
,   arch = &quot;x86_64&quot;
,   xcode_sdkver = &quot;10.12&quot;
,   ex = &quot;xcrun -sdk macosx ar&quot;
,   cc = &quot;xcrun -sdk macosx clang&quot;
,   rc = &quot;rustc&quot;
,   plat = &quot;macosx&quot;
,   micro = false
,   host = &quot;macosx&quot;
,   as = &quot;xcrun -sdk macosx clang&quot;
,   dc = &quot;dmd&quot;
,   gc = &quot;go&quot;
,   openssl = false
,   ccache = &quot;ccache&quot;
,   cxx = &quot;xcrun -sdk macosx clang&quot;
,   sc = &quot;xcrun -sdk macosx swiftc&quot;
,   mm = &quot;xcrun -sdk macosx clang&quot;
,   buildir = &quot;build&quot;
,   mxx = &quot;xcrun -sdk macosx clang++&quot;
,   ld = &quot;xcrun -sdk macosx clang++&quot;
,   mode = &quot;release&quot;
,   kind = &quot;static&quot;
}
</code></pre>
<h5 id="core-project-global">core.project.global</h5>
<p>&lt;p class=&quot;tip&quot;&gt;<br>此模块自2.1.5版本后迁移至<a href="#core-base-global">core.base.global</a>。<br>&lt;/p&gt;

</p>
<h5 id="core-project-task">core.project.task</h5>
<p>&lt;p class=&quot;tip&quot;&gt;<br>此模块自2.1.5版本后迁移至<a href="#core-base-task">core.base.task</a>。<br>&lt;/p&gt;

</p>
<h5 id="core-project-project">core.project.project</h5>
<p>用于获取当前工程的一些描述信息，也就是在<code>xmake.lua</code>工程描述文件中定义的配置信息，例如：<a href="#target">target</a>、<a href="#option">option</a>等。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#project-load">project.load</a></td>
<td>加载工程配置</td>
<td>&gt;= 2.0.1 (2.1.5废弃)</td>
</tr>
<tr>
<td><a href="#project-directory">project.directory</a></td>
<td>获取工程目录</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#project-target">project.target</a></td>
<td>获取指定工程目标对象</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#project-targets">project.targets</a></td>
<td>获取工程目标对象列表</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#project-option">project.option</a></td>
<td>获取指定的选项对象</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#project-options">project.options</a></td>
<td>获取工程所有的选项对象</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#project-name">project.name</a></td>
<td>获取当前工程名</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#project-version">project.version</a></td>
<td>获取当前工程版本号</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="project-load">project.load</h6>
<ul>
<li>加载工程描述配置</li>
</ul>
<p>仅在插件中使用，因为这个时候还没有加载工程配置信息，在工程目标的自定义脚本中，不需要执行此操作，就可以直接访问工程配置。</p>
<pre><code class="lang-lua">-- 导入工程模块
import(&quot;core.project.project&quot;)

-- 插件入口
function main(...)

    -- 加载工程描述配置
    project.load()

    -- 访问工程描述，例如获取指定工程目标
    local target = project.target(&quot;test&quot;)
end
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本后，不在需要，工程加载会自动在合适时机延迟加载。<br>&lt;/p&gt;

</p>
<h6 id="project-directory">project.directory</h6>
<ul>
<li>获取工程目录</li>
</ul>
<p>获取当前工程目录，也就是<code>xmake -P xxx</code>中指定的目录，否则为默认当前<code>xmake</code>命令执行目录。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>2.1.5版本后，建议使用<a href="#os-projectdir">os.projectdir</a>来获取。<br>&lt;/p&gt;

</p>
<h6 id="project-target">project.target</h6>
<ul>
<li>获取指定工程目标对象</li>
</ul>
<p>获取和访问指定工程目标配置，例如：</p>
<pre><code class="lang-lua">local target = project.target(&quot;test&quot;)
if target then

    -- 获取目标名
    print(target:name())

    -- 获取目标目录, 2.1.9版本之后才有
    print(target:targetdir())

    -- 获取目标文件名
    print(target:targetfile())

    -- 获取目标类型，也就是：binary, static, shared
    print(target:targetkind())

    -- 获取目标名
    print(target:name())

    -- 获取目标源文件
    local sourcefiles = target:sourcefiles()

    -- 获取目标安装头文件列表
    local srcheaders, dstheaders = target:headerfiles()

    -- 获取目标依赖
    print(target:get(&quot;deps&quot;))
end
</code></pre>
<h6 id="project-targets">project.targets</h6>
<ul>
<li>获取工程目标对象列表</li>
</ul>
<p>返回当前工程的所有编译目标，例如：</p>
<pre><code class="lang-lua">for targetname, target in pairs(project.targets())
    print(target:targetfile())
end
</code></pre>
<h6 id="project-option">project.option</h6>
<ul>
<li>获取指定选项对象</li>
</ul>
<p>获取和访问工程中指定的选项对象，例如：</p>
<pre><code class="lang-lua">local option = project.option(&quot;test&quot;)
if option:enabled() then
    option:enable(false)
end
</code></pre>
<h6 id="project-options">project.options</h6>
<ul>
<li>获取工程所有选项对象</li>
</ul>
<p>返回当前工程的所有编译目标，例如：</p>
<pre><code class="lang-lua">for optionname, option in pairs(project.options())
    print(option:enabled())
end
</code></pre>
<h6 id="project-name">project.name</h6>
<ul>
<li>获取当前工程名</li>
</ul>
<p>也就是获取<a href="#set_project">set_project</a>的工程名配置。</p>
<pre><code class="lang-lua">print(project.name())
</code></pre>
<h6 id="project-version">project.version</h6>
<ul>
<li>获取当前工程版本号</li>
</ul>
<p>也就是获取<a href="#set_version">set_version</a>的工程版本配置。</p>
<pre><code class="lang-lua">print(project.version())
</code></pre>
<h5 id="core-language-language">core.language.language</h5>
<p>用于获取编译语言相关信息，一般用于代码文件的操作。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#language-extensions">language.extensions</a></td>
<td>获取所有语言的代码后缀名列表</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#language-targetkinds">language.targetkinds</a></td>
<td>获取所有语言的目标类型列表</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#language-sourcekinds">language.sourcekinds</a></td>
<td>获取所有语言的源文件类型列表</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#language-sourceflags">language.sourceflags</a></td>
<td>加载所有语言的源文件编译选项名列表</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#language-load">language.load</a></td>
<td>加载指定语言</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#language-load_sk">language.load_sk</a></td>
<td>从源文件类型加载指定语言</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#language-load_ex">language.load_ex</a></td>
<td>从源文件后缀名加载指定语言</td>
<td>&gt;= 2.1.1</td>
</tr>
<tr>
<td><a href="#language-sourcekind_of">language.sourcekind_of</a></td>
<td>获取指定源文件的源文件类型</td>
<td>&gt;= 2.1.1</td>
</tr>
</tbody>
</table>
<h6 id="language-extensions">language.extensions</h6>
<ul>
<li>获取所有语言的代码后缀名列表</li>
</ul>
<p>获取结果如下：</p>
<pre><code class="lang-lua">{
     [&quot;.c&quot;]      = cc
,    [&quot;.cc&quot;]     = cxx
,    [&quot;.cpp&quot;]    = cxx
,    [&quot;.m&quot;]      = mm
,    [&quot;.mm&quot;]     = mxx
,    [&quot;.swift&quot;]  = sc
,    [&quot;.go&quot;]     = gc
}
</code></pre>
<h6 id="language-targetkinds">language.targetkinds</h6>
<ul>
<li>获取所有语言的目标类型列表</li>
</ul>
<p>获取结果如下：</p>
<pre><code class="lang-lua">{
     binary = {&quot;ld&quot;, &quot;gcld&quot;, &quot;dcld&quot;}
,    static = {&quot;ar&quot;, &quot;gcar&quot;, &quot;dcar&quot;}
,    shared = {&quot;sh&quot;, &quot;dcsh&quot;}
}
</code></pre>
<h6 id="language-sourcekinds">language.sourcekinds</h6>
<ul>
<li>获取所有语言的源文件类型列表</li>
</ul>
<p>获取结果如下：</p>
<pre><code class="lang-lua">{
     cc  = &quot;.c&quot;
,    cxx = {&quot;.cc&quot;, &quot;.cpp&quot;, &quot;.cxx&quot;}
,    mm  = &quot;.m&quot;
,    mxx = &quot;.mm&quot;
,    sc  = &quot;.swift&quot;
,    gc  = &quot;.go&quot;
,    rc  = &quot;.rs&quot;
,    dc  = &quot;.d&quot;
,    as  = {&quot;.s&quot;, &quot;.S&quot;, &quot;.asm&quot;}
}
</code></pre>
<h6 id="language-sourceflags">language.sourceflags</h6>
<ul>
<li>加载所有语言的源文件编译选项名列表</li>
</ul>
<p>获取结果如下：</p>
<pre><code class="lang-lua">{
     cc  = {&quot;cflags&quot;, &quot;cxflags&quot;}
,    cxx = {&quot;cxxflags&quot;, &quot;cxflags&quot;}
,    ...
}
</code></pre>
<h6 id="language-load">language.load</h6>
<ul>
<li>加载指定语言</li>
</ul>
<p>从语言名称加载具体语言对象，例如：</p>
<pre><code class="lang-lua">local lang = language.load(&quot;c++&quot;)
if lang then
    print(lang:name())
end
</code></pre>
<h6 id="language-load_sk">language.load_sk</h6>
<ul>
<li>从源文件类型加载指定语言</li>
</ul>
<p>从源文件类型：<code>cc, cxx, mm, mxx, sc, gc, as ..</code>加载具体语言对象，例如：</p>
<pre><code class="lang-lua">local lang = language.load_sk(&quot;cxx&quot;)
if lang then
    print(lang:name())
end
</code></pre>
<h6 id="language-load_ex">language.load_ex</h6>
<ul>
<li>从源文件后缀名加载指定语言</li>
</ul>
<p>从源文件后缀名：<code>.cc, .c, .cpp, .mm, .swift, .go  ..</code>加载具体语言对象，例如：</p>
<pre><code class="lang-lua">local lang = language.load_sk(&quot;.cpp&quot;)
if lang then
    print(lang:name())
end
</code></pre>
<h6 id="language-sourcekind_of">language.sourcekind_of</h6>
<ul>
<li>获取指定源文件的源文件类型</li>
</ul>
<p>也就是从给定的一个源文件路径，获取它是属于那种源文件类型，例如：</p>
<pre><code class="lang-lua">print(language.sourcekind_of(&quot;/xxxx/test.cpp&quot;))
</code></pre>
<p>显示结果为：<code>cxx</code>，也就是<code>c++</code>类型，具体对应列表见：<a href="#language-sourcekinds">language.sourcekinds</a></p>
<h5 id="core-platform-platform">core.platform.platform</h5>
<p>平台信息相关操作</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#platform-get">platform.get</a></td>
<td>获取指定平台相关配置信息</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="platform-get">platform.get</h6>
<ul>
<li>获取指定平台相关配置信息</li>
</ul>
<p>获取平台配置<code>xmake.lua</code>中设置的信息，一般只有在写插件的时候会用到，例如：</p>
<pre><code class="lang-lua">-- 获取当前平台的所有支持架构
print(platform.get(&quot;archs&quot;))

-- 获取指定iphoneos平台的目标文件格式信息
local formats = platform.get(&quot;formats&quot;, &quot;iphoneos&quot;)
utils.dump(formats)
</code></pre>
<p>具体有哪些可读的平台配置信息，可参考：<a href="#platform">platform</a></p>
<h5 id="core-platform-environment">core.platform.environment</h5>
<p>环境相关操作，用于进入和离开指定环境变量对应的终端环境，一般用于<code>path</code>环境的进入和离开，尤其是一些需要特定环境的构建工具，例如：msvc的工具链。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#environment-enter">environment.enter</a></td>
<td>进入指定环境</td>
<td>&gt;= 2.0.1</td>
</tr>
<tr>
<td><a href="#environment-leave">environment.leave</a></td>
<td>离开指定环境</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<p>目前支持的环境有：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>toolchains</td>
<td>工具链执行环境</td>
<td>&gt;= 2.0.1</td>
</tr>
</tbody>
</table>
<h6 id="environment-enter">environment.enter</h6>
<ul>
<li>进入指定环境</li>
</ul>
<p>进入指定环境，例如msvc有自己的环境变量环境用于运行构建工具，例如：<code>cl.exe</code>, <code>link.exe</code>这些，这个时候想要在xmake里面运行他们，需要：</p>
<pre><code class="lang-lua">-- 进入工具链环境
environment.enter(&quot;toolchains&quot;)

-- 这个时候运行cl.exe才能正常运行，这个时候的path等环境变量都会进入msvc的环境模式
os.run(&quot;cl.exe ..&quot;)

-- 离开工具链环境
environment.leave(&quot;toolchains&quot;)
</code></pre>
<p>因此为了通用性，默认xmake编译事都会设置这个环境，在linux下基本上内部环境不需要特殊切换，目前仅对windows下msvc进行了处理。</p>
<h6 id="environment-leave">environment.leave</h6>
<ul>
<li>离开指定环境</li>
</ul>
<p>具体使用见：<a href="#environment-enter">environment.enter</a></p>
<h5 id="lib-detect">lib.detect</h5>
<p>此模块提供了非常强大的探测功能，用于探测程序、编译器、语言特性、依赖包等。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>此模块的接口分散在多个模块目录中，尽量通过导入单个接口来使用，这样效率更高，例如：<code>import(&quot;lib.detect.find_package&quot;)</code>，而不是通过<code>import(&quot;lib.detect&quot;)</code>导入所有来调用。<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#detect-find_file">detect.find_file</a></td>
<td>查找文件</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_path">detect.find_path</a></td>
<td>查找文件路径</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_library">detect.find_library</a></td>
<td>查找库文件</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_program">detect.find_program</a></td>
<td>查找可执行程序</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_programver">detect.find_programver</a></td>
<td>查找可执行程序版本号</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_package">detect.find_package</a></td>
<td>查找包文件，包含库文件和搜索路径</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_tool">detect.find_tool</a></td>
<td>查找工具</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_toolname">detect.find_toolname</a></td>
<td>查找工具名</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-find_cudadevices">detect.find_cudadevices</a></td>
<td>查找本机的 CUDA 设备</td>
<td>&gt;= 2.2.7</td>
</tr>
<tr>
<td><a href="#detect-features">detect.features</a></td>
<td>获取指定工具的所有特性</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_features">detect.has_features</a></td>
<td>判断指定特性是否支持</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_flags">detect.has_flags</a></td>
<td>判断指定参数选项是否支持</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_cfuncs">detect.has_cfuncs</a></td>
<td>判断指定c函数是否存在</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_cxxfuncs">detect.has_cxxfuncs</a></td>
<td>判断指定c++函数是否存在</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_cincludes">detect.has_cincludes</a></td>
<td>判断指定c头文件是否存在</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_cxxincludes">detect.has_cxxincludess</a></td>
<td>判断指定c++头文件是否存在</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_ctypes">detect.has_ctypes</a></td>
<td>判断指定c类型是否存在</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-has_cxxtypes">detect.has_cxxtypes</a></td>
<td>判断指定c++类型是否存在</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#detect-check_cxsnippets">detect.check_cxsnippets</a></td>
<td>检测c/c++代码片段是否能够编译通过</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<h6 id="detect-find_file">detect.find_file</h6>
<ul>
<li>查找文件</li>
</ul>
<p>这个接口提供了比<a href="#os-files">os.files</a>更加强大的工程， 可以同时指定多个搜索目录，并且还能对每个目录指定附加的子目录，来模式匹配查找，相当于是<a href="#os-files">os.files</a>的增强版。</p>
<p>例如：</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_file&quot;)

local file = find_file(&quot;ccache&quot;, { &quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;})
</code></pre>
<p>如果找到，返回的结果是：<code>/usr/bin/ccache</code></p>
<p>它同时也支持模式匹配路径，进行递归查找，类似<code>os.files</code>：</p>
<pre><code class="lang-lua">local file = find_file(&quot;test.h&quot;, { &quot;/usr/include&quot;, &quot;/usr/local/include/**&quot;})
</code></pre>
<p>不仅如此，里面的路径也支持内建变量，来从环境变量和注册表中获取路径进行查找：</p>
<pre><code class="lang-lua">local file = find_file(&quot;xxx.h&quot;, { &quot;$(env PATH)&quot;, &quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name)&quot;})
</code></pre>
<p>如果路径规则比较复杂多变，还可以通过自定义脚本来动态生成路径传入：</p>
<pre><code class="lang-lua">local file = find_file(&quot;xxx.h&quot;, { &quot;$(env PATH)&quot;, function () return val(&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name&quot;):match(&quot;\&quot;(.-)\&quot;&quot;) end})
</code></pre>
<p>大部分场合下，上面的使用已经满足各种需求了，如果还需要一些扩展功能，可以通过传入第三个参数，自定义一些可选配置，例如：</p>
<pre><code class="lang-lua">local file = find_file(&quot;test.h&quot;, { &quot;/usr&quot;, &quot;/usr/local&quot;}, {suffixes = {&quot;/include&quot;, &quot;/lib&quot;}})
</code></pre>
<p>通过指定suffixes子目录列表，可以扩展路径列表（第二个参数），使得实际的搜索目录扩展为：</p>
<pre><code>/usr/include
/usr/lib
/usr/local/include
/usr/local/lib
</code></pre><p>并且不用改变路径列表，就能动态切换子目录来搜索文件。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>我们也可以通过<code>xmake lua</code>插件来快速调用和测试此接口：<code>xmake lua lib.detect.find_file test.h /usr/local</code><br>&lt;/p&gt;

</p>
<h6 id="detect-find_path">detect.find_path</h6>
<ul>
<li>查找路径</li>
</ul>
<p>这个接口的用法跟<a href="#detect-find_file">lib.detect.find_file</a>类似，唯一的区别是返回的结果不同。<br>此接口查找到传入的文件路径后，返回的是对应的搜索路径，而不是文件路径本身，一般用于查找文件对应的父目录位置。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_path&quot;)

local p = find_path(&quot;include/test.h&quot;, { &quot;/usr&quot;, &quot;/usr/local&quot;})
</code></pre>
<p>上述代码如果查找成功，则返回：<code>/usr/local</code>，如果<code>test.h</code>在<code>/usr/local/include/test.h</code>的话。</p>
<p>还有一个区别就是，这个接口传入不只是文件路径，还可以传入目录路径来查找：</p>
<pre><code class="lang-lua">local p = find_path(&quot;lib/xxx&quot;, { &quot;$(env PATH)&quot;, &quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name)&quot;})
</code></pre>
<p>同样，此接口也支持模式匹配和后缀子目录：</p>
<pre><code class="lang-lua">local p = find_path(&quot;include/*.h&quot;, { &quot;/usr&quot;, &quot;/usr/local/**&quot;}, {suffixes = &quot;/subdir&quot;})
</code></pre>
<h6 id="detect-find_library">detect.find_library</h6>
<ul>
<li>查找库文件</li>
</ul>
<p>此接口用于指定的搜索目录中查找库文件（静态库，动态库），例如：</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_library&quot;)

local library = find_library(&quot;crypto&quot;, {&quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;})
</code></pre>
<p>在macosx上运行，返回的结果如下：</p>
<pre><code class="lang-lua">{
    filename = libcrypto.dylib
,   linkdir = /usr/lib
,   link = crypto
,   kind = shared
}
</code></pre>
<p>如果不指定是否需要静态库还是动态库，那么此接口会自动选择一个存在的库（有可能是静态库、也有可能是动态库）进行返回。</p>
<p>如果需要强制指定需要查找的库类型，可以指定kind参数为（<code>static/shared</code>）：</p>
<pre><code class="lang-lua">local library = find_library(&quot;crypto&quot;, {&quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;}, {kind = &quot;static&quot;})
</code></pre>
<p>此接口也支持suffixes后缀子目录搜索和模式匹配操作：</p>
<pre><code class="lang-lua">local library = find_library(&quot;cryp*&quot;, {&quot;/usr&quot;, &quot;/usr/local&quot;}, {suffixes = &quot;/lib&quot;})
</code></pre>
<h6 id="detect-find_program">detect.find_program</h6>
<ul>
<li>查找可执行程序</li>
</ul>
<p>这个接口比<a href="#detect-find_tool">lib.detect.find_tool</a>较为原始底层，通过指定的参数目录来查找可执行程序。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_program&quot;)

local program = find_program(&quot;ccache&quot;)
</code></pre>
<p>上述代码犹如没有传递搜索目录，所以它会尝试直接执行指定程序，如果运行ok，那么直接返回：<code>ccache</code>，表示查找成功。</p>
<p>指定搜索目录，修改尝试运行的检测命令参数（默认是：<code>ccache --version</code>）：</p>
<pre><code class="lang-lua">local program = find_program(&quot;ccache&quot;, {pathes = {&quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;}, check = &quot;--help&quot;}) 
</code></pre>
<p>上述代码会尝试运行：<code>/usr/bin/ccache --help</code>，如果运行成功，则返回：<code>/usr/bin/ccache</code>。</p>
<p>如果<code>--help</code>也没法满足需求，有些程序没有<code>--version/--help</code>参数，那么可以自定义运行脚本，来运行检测：</p>
<pre><code class="lang-lua">local program = find_program(&quot;ccache&quot;, {pathes = {&quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;}, check = function (program) os.run(&quot;%s -h&quot;, program) end})
</code></pre>
<p>同样，搜索路径列表支持内建变量和自定义脚本：</p>
<pre><code class="lang-lua">local program = find_program(&quot;ccache&quot;, {pathes = {&quot;$(env PATH)&quot;, &quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug;Debugger)&quot;}})
local program = find_program(&quot;ccache&quot;, {pathes = {&quot;$(env PATH)&quot;, function () return &quot;/usr/local/bin&quot; end}})
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>为了加速频发查找的效率，此接口是默认自带cache的，所以就算频繁查找相同的程序，也不会花太多时间。<br>如果要禁用cache，可以在工程目录执行<code>xmake f -c</code>清除本地cache。<br>&lt;/p&gt;

</p>
<p>我们也可以通过<code>xmake lua lib.detect.find_program ccache</code> 来快速测试。</p>
<h6 id="detect-find_programver">detect.find_programver</h6>
<ul>
<li>查找可执行程序版本号</li>
</ul>
<pre><code class="lang-lua">import(&quot;lib.detect.find_programver&quot;)

local programver = find_programver(&quot;ccache&quot;)
</code></pre>
<p>返回结果为：3.2.2</p>
<p>默认它会通过<code>ccache --version</code>尝试获取版本，如果不存在此参数，可以自己指定其他参数：</p>
<pre><code class="lang-lua">local version = find_programver(&quot;ccache&quot;, {command = &quot;-v&quot;})
</code></pre>
<p>甚至自定义版本获取脚本：</p>
<pre><code class="lang-lua">local version = find_programver(&quot;ccache&quot;, {command = function () return os.iorun(&quot;ccache --version&quot;) end})
</code></pre>
<p>对于版本号的提取规则，如果内置的匹配模式不满足要求，也可以自定义：</p>
<pre><code class="lang-lua">local version = find_programver(&quot;ccache&quot;, {command = &quot;--version&quot;, parse = &quot;(%d+%.?%d*%.?%d*.-)%s&quot;})
local version = find_programver(&quot;ccache&quot;, {command = &quot;--version&quot;, parse = function (output) return output:match(&quot;(%d+%.?%d*%.?%d*.-)%s&quot;) end})
</code></pre>
<p>&lt;p class=&quot;tip&quot;&gt;<br>为了加速频发查找的效率，此接口是默认自带cache的，如果要禁用cache，可以在工程目录执行<code>xmake f -c</code>清除本地cache。<br>&lt;/p&gt;

</p>
<p>我们也可以通过<code>xmake lua lib.detect.find_programver ccache</code> 来快速测试。</p>
<h6 id="detect-find_package">detect.find_package</h6>
<ul>
<li>查找包文件</li>
</ul>
<p>此接口也是用于查找库文件，但是比<a href="#detect-find_library">lib.detect.find_library</a>更加上层，也更为强大和简单易用，因为它是以包为力度进行查找。</p>
<p>那怎样算是一个完整的包，它包含：</p>
<ol>
<li>多个静态库或者动态库文件</li>
<li>库的搜索目录</li>
<li>头文件的搜索目录</li>
<li>可选的编译链接选项，例如：<code>defines</code>等</li>
<li>可选的版本号</li>
</ol>
<p>例如我们查找一个openssl包：</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_package&quot;)

local package = find_package(&quot;openssl&quot;)
</code></pre>
<p>返回的结果如下：</p>
<pre><code class="lang-lua">{links = {&quot;ssl&quot;, &quot;crypto&quot;, &quot;z&quot;}, linkdirs = {&quot;/usr/local/lib&quot;}, includedirs = {&quot;/usr/local/include&quot;}}
</code></pre>
<p>如果查找成功，则返回一个包含所有包信息的table，如果失败返回nil</p>
<p>这里的返回结果可以直接作为<code>target:add</code>, <code>option:add</code>的参数传入，用于动态增加<code>target/option</code>的配置：</p>
<pre><code class="lang-lua">option(&quot;zlib&quot;)
    set_showmenu(true)
    before_check(function (option)
        import(&quot;lib.detect.find_package&quot;)
        option:add(find_package(&quot;zlib&quot;))
    end)
</code></pre>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_load(function (target)
        import(&quot;lib.detect.find_package&quot;)
        target:add(find_package(&quot;zlib&quot;))
    end)
</code></pre>
<p>如果系统上装有<code>homebrew</code>, <code>pkg-config</code>等第三方工具，那么此接口会尝试使用它们去改进查找结果。</p>
<p>我们也可以通过指定版本号，来选择查找指定版本的包（如果这个包获取不到版本信息或者没有匹配版本的包，则返回nil）：</p>
<pre><code class="lang-lua">local package = find_package(&quot;openssl&quot;, {version = &quot;1.0.1&quot;})
</code></pre>
<p>默认情况下查找的包是根据如下规则匹配平台，架构和模式的：</p>
<ol>
<li>如果参数传入指定了<code>{plat = &quot;iphoneos&quot;, arch = &quot;arm64&quot;, mode = &quot;release&quot;}</code>，则优先匹配，例如：<code>find_package(&quot;openssl&quot;, {plat = &quot;iphoneos&quot;})</code>。</li>
<li>如果是在当前工程环境，存在配置文件，则优先尝试从<code>config.get(&quot;plat&quot;)</code>, <code>config.get(&quot;arch&quot;)</code>和<code>config.get(&quot;mode&quot;)</code>获取平台架构进行匹配。</li>
<li>最后从<code>os.host()</code>和<code>os.arch()</code>中进行匹配，也就是当前主机的平台架构环境。</li>
</ol>
<p>如果系统的库目录以及<code>pkg-config</code>都不能满足需求，找不到包，那么可以自己手动设置搜索路径：</p>
<pre><code class="lang-lua">local package = find_package(&quot;openssl&quot;, {linkdirs = {&quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;}, includedirs = &quot;/usr/local/include&quot;})
</code></pre>
<p>也可以同时指定需要搜索的链接名，头文件名：</p>
<pre><code class="lang-lua">local package = find_package(&quot;openssl&quot;, {links = {&quot;ssl&quot;, &quot;crypto&quot;}, includes = &quot;ssl.h&quot;}})
</code></pre>
<p>甚至可以指定xmake的<code>packagedir/*.pkg</code>包目录，用于查找对应的<code>openssl.pkg</code>包，一般用于查找内置在工程目录中的本地包。</p>
<p>例如，tbox工程内置了<code>pkg/openssl.pkg</code>本地包载项目中，我们可以通过下面的脚本，传入<code>{packagedirs = &quot;&quot;}</code>参数优先查找本地包，如果找不到再去找系统包。</p>
<pre><code class="lang-lua">target(&quot;test&quot;)
    on_load(function (target)
        import(&quot;lib.detect.find_package&quot;)
        target:add(find_package(&quot;openssl&quot;, {packagedirs = path.join(os.projectdir(), &quot;pkg&quot;)}))
    end)
</code></pre>
<p>总结下，现在的查找顺序：</p>
<ol>
<li>如果指定<code>{packagedirs = &quot;&quot;}</code>参数，优先从这个参数指定的路径中查找本地包<code>*.pkg</code></li>
<li>如果在<code>xmake/modules</code>下面存在<code>detect.packages.find_xxx</code>脚本，那么尝试调用此脚本来改进查找结果</li>
<li>如果系统存在vcpkg，优先从vcpkg的包管理系统中去获取包</li>
<li>如果系统存在<code>pkg-config</code>，并且查找的是系统环境的库，则尝试使用<code>pkg-config</code>提供的路径和链接信息进行查找</li>
<li>如果系统存在<code>homebrew</code>，并且查找的是系统环境的库，则尝试使用<code>brew --prefix xxx</code>提供的信息进行查找</li>
<li>从参数中指定的pathes路径和一些已知的系统路径<code>/usr/lib</code>, <code>/usr/include</code>中进行查找</li>
</ol>
<p>这里需要着重说下第二点，通过在<code>detect.packages.find_xxx</code>脚本来改进查找结果，很多时候自动的包探测是没法完全探测到包路径的，<br>尤其是针对windows平台，没有默认的库目录，也没有包管理app，很多库装的时候，都是自己所处放置在系统目录，或者添加注册表项。</p>
<p>因此查找起来没有统一的规则，这个时候，就可以自定义一个查找脚本，去改进<code>find_package</code>的查找机制，对指定包进行更精准的查找。</p>
<p>在xmake自带的<code>xmake/modules/detect/packages</code>目录下，已经有许多的内置包脚本，来对常用的包进行更好的查找支持。<br>当然这不可能满足所有用户的需求，如果用户需要的包还是找不到，那么可以自己定义一个查找脚本，例如：</p>
<p>查找一个名为<code>openssl</code>的包，可以编写一个<code>find_openssl.lua</code>的脚本放置在工程目录：</p>
<pre><code>projectdir
 - xmake
   - modules
     - detect/package/find_openssl.lua
</code></pre><p>然后在工程的<code>xmake.lua</code>文件的开头指定下这个modules的目录：</p>
<pre><code class="lang-lua">add_moduledirs(&quot;$(projectdir)/xmake/modules&quot;)
</code></pre>
<p>这样xmake就能找到自定义的扩展模块了。</p>
<p>接下来我们看下<code>find_openssl.lua</code>的实现：</p>
<pre><code class="lang-lua">-- imports
import(&quot;lib.detect.find_path&quot;)
import(&quot;lib.detect.find_library&quot;)

-- find openssl 
--
-- @param opt   the package options. e.g. see the options of find_package()
--
-- @return      see the return value of find_package()
--
function main(opt)

    -- for windows platform
    --
    -- http://www.slproweb.com/products/Win32OpenSSL.html
    --
    if opt.plat == &quot;windows&quot; then

        -- init bits
        local bits = ifelse(opt.arch == &quot;x64&quot;, &quot;64&quot;, &quot;32&quot;)

        -- init search pathes
        local pathes = {&quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\OpenSSL %(&quot; .. bits .. &quot;-bit%)_is1;Inno Setup: App Path)&quot;,
                        &quot;$(env PROGRAMFILES)/OpenSSL&quot;,
                        &quot;$(env PROGRAMFILES)/OpenSSL-Win&quot; .. bits,
                        &quot;C:/OpenSSL&quot;,
                        &quot;C:/OpenSSL-Win&quot; .. bits}

        -- find library
        local result = {links = {}, linkdirs = {}, includedirs = {}}
        for _, name in ipairs({&quot;libssl&quot;, &quot;libcrypto&quot;}) do
            local linkinfo = find_library(name, pathes, {suffixes = &quot;lib&quot;})
            if linkinfo then
                table.insert(result.links, linkinfo.link)
                table.insert(result.linkdirs, linkinfo.linkdir)
            end
        end

        -- not found?
        if #result.links ~= 2 then
            return 
        end

        -- find include
        table.insert(result.includedirs, find_path(&quot;openssl/ssl.h&quot;, pathes, {suffixes = &quot;include&quot;}))

        -- ok
        return result
    end
end
</code></pre>
<p>里面对windows平台进行注册表读取，去查找指定的库文件，其底层其实也是调用的<a href="#detect-find_library">find_library</a>等接口。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>为了加速频发查找的效率，此接口是默认自带cache的，如果要禁用cache，可以在工程目录执行<code>xmake f -c</code>清除本地cache。<br>也可以通过指定force参数，来禁用cache，强制重新查找：<code>find_package(&quot;openssl&quot;, {force = true})</code><br>&lt;/p&gt;

</p>
<p>我们也可以通过<code>xmake lua lib.detect.find_package openssl</code> 来快速测试。</p>
<p>2.2.5版本之后，新增了内置接口<a href="#find_packages">find_packages</a>，可以同时查找多个包，并且不需要通过import导入即可直接使用。</p>
<p>并且此版本之后，支持显式的从指定第三方包管理器中查找包，例如：</p>
<pre><code class="lang-lua">find_package(&quot;brew::pcre2/libpcre2-8&quot;)
</code></pre>
<p>由于每个第三方包管理器的包名不完全一致，比如pcre2在homebrew中有三个库版本，我们可以通过上面的方式，指定查找对应libpcre2-8版本的库。</p>
<p>另外，对于vcpkg, conan也可以通过加上<code>vcpkg::</code>, <code>conan::</code>包命名空间来指定查找里面的库。</p>
<h6 id="detect-find_tool">detect.find_tool</h6>
<ul>
<li>查找工具</li>
</ul>
<p>此接口也是用于查找可执行程序，不过比<a href="#detect-find_program">lib.detect.find_program</a>更加的高级，功能也更加强大，它对可执行程序进行了封装，提供了工具这个概念：</p>
<ul>
<li>toolname: 工具名，可执行程序的简称，用于标示某个工具，例如：<code>gcc</code>, <code>clang</code>等</li>
<li>program: 可执行程序命令，例如：<code>xcrun -sdk macosx clang</code></li>
</ul>
<p>其对应关系如下：</p>
<table>
<thead>
<tr>
<th>toolname</th>
<th>program</th>
</tr>
</thead>
<tbody>
<tr>
<td>clang</td>
<td><code>xcrun -sdk macosx clang</code></td>
</tr>
<tr>
<td>gcc</td>
<td><code>/usr/toolchains/bin/arm-linux-gcc</code></td>
</tr>
<tr>
<td>link</td>
<td><code>link.exe -lib</code></td>
</tr>
</tbody>
</table>
<p><a href="#detect-find_program">lib.detect.find_program</a>只能通过传入的原始program命令或路径，去判断该程序是否存在。<br>而<code>find_tool</code>则可以通过更加一致的toolname去查找工具，并且返回对应的program完整命令路径，例如：</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_tool&quot;)

local tool = find_tool(&quot;clang&quot;)
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;clang&quot;}</code>，这个时候还看不出区别，我们可以手动指定可执行的命令：</p>
<pre><code class="lang-lua">local tool = find_tool(&quot;clang&quot;, {program = &quot;xcrun -sdk macosx clang&quot;})
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;xcrun -sdk macosx clang&quot;}</code></p>
<p>而在macosx下，gcc就是clang，如果我们执行<code>gcc --version</code>可以看到就是clang的一个马甲，我们可以通过<code>find_tool</code>接口进行智能识别：</p>
<pre><code class="lang-lua">local tool = find_tool(&quot;gcc&quot;)
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;gcc&quot;}</code></p>
<p>通过这个结果就可以看的区别来了，工具名实际会被标示为clang，但是可执行的命令用的是gcc。</p>
<p>我们也可以指定<code>{version = true}</code>参数去获取工具的版本，并且指定一个自定义的搜索路径，也支持内建变量和自定义脚本哦： </p>
<pre><code class="lang-lua">local tool = find_tool(&quot;clang&quot;, {version = true, {pathes = {&quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;, &quot;$(env PATH)&quot;, function () return &quot;/usr/xxx/bin&quot; end}})
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;/usr/bin/clang&quot;, version = &quot;4.0&quot;}</code></p>
<p>这个接口是对<code>find_program</code>的上层封装，因此也支持自定义脚本检测：</p>
<pre><code class="lang-lua">local tool = find_tool(&quot;clang&quot;, {check = &quot;--help&quot;}) 
local tool = find_tool(&quot;clang&quot;, {check = function (tool) os.run(&quot;%s -h&quot;, tool) end})
</code></pre>
<p>最后总结下，<code>find_tool</code>的查找流程：</p>
<ol>
<li>优先通过<code>{program = &quot;xxx&quot;}</code>的参数来尝试运行和检测。</li>
<li>如果在<code>xmake/modules/detect/tools</code>下存在<code>detect.tools.find_xxx</code>脚本，则调用此脚本进行更加精准的检测。</li>
<li>尝试从<code>/usr/bin</code>，<code>/usr/local/bin</code>等系统目录进行检测。</li>
</ol>
<p>我们也可以在工程<code>xmake.lua</code>中<code>add_moduledirs</code>指定的模块目录中，添加自定义查找脚本，来改进检测机制：</p>
<pre><code>projectdir
  - xmake/modules
    - detect/tools/find_xxx.lua
</code></pre><p>例如我们自定义一个<code>find_7z.lua</code>的查找脚本：</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_program&quot;)
import(&quot;lib.detect.find_programver&quot;)

function main(opt)

    -- init options
    opt = opt or {}

    -- find program
    local program = find_program(opt.program or &quot;7z&quot;, opt.pathes, opt.check or &quot;--help&quot;)

    -- find program version
    local version = nil
    if program and opt and opt.version then
        version = find_programver(program, &quot;--help&quot;, &quot;(%d+%.?%d*)%s&quot;)
    end

    -- ok?
    return program, version
end
</code></pre>
<p>将它放置到工程的模块目录下后，执行：<code>xmake l lib.detect.find_tool 7z</code>就可以查找到了。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>为了加速频发查找的效率，此接口是默认自带cache的，如果要禁用cache，可以在工程目录执行<code>xmake f -c</code>清除本地cache。<br>&lt;/p&gt;

</p>
<p>我们也可以通过<code>xmake lua lib.detect.find_tool clang</code> 来快速测试。</p>
<h6 id="detect-find_toolname">detect.find_toolname</h6>
<ul>
<li>查找工具名</li>
</ul>
<p>通过program命令匹配对应的工具名，例如：</p>
<table>
<thead>
<tr>
<th>program</th>
<th>toolname</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>xcrun -sdk macosx clang</code></td>
<td>clang</td>
</tr>
<tr>
<td><code>/usr/bin/arm-linux-gcc</code></td>
<td>gcc</td>
</tr>
<tr>
<td><code>link.exe -lib</code></td>
<td>link</td>
</tr>
<tr>
<td><code>gcc-5</code></td>
<td>gcc</td>
</tr>
<tr>
<td><code>arm-android-clang++</code></td>
<td>clangxx</td>
</tr>
<tr>
<td><code>pkg-config</code></td>
<td>pkg_config</td>
</tr>
</tbody>
</table>
<p>toolname相比program，更能唯一标示某个工具，也方便查找和加载对应的脚本<code>find_xxx.lua</code>。</p>
<h6 id="detect-find_cudadevices">detect.find_cudadevices</h6>
<ul>
<li>查找本机的 CUDA 设备</li>
</ul>
<p>通过 CUDA Runtime API 枚举本机的 CUDA 设备，并查询其属性。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.find_cudadevices&quot;)

local devices = find_cudadevices({ skip_compute_mode_prohibited = true })
local devices = find_cudadevices({ min_sm_arch = 35, order_by_flops = true })
</code></pre>
<p>返回的结果为：<code>{ { [&#39;$id&#39;] = 0, name = &quot;GeForce GTX 960M&quot;, major = 5, minor = 0, ... }, ... }</code></p>
<p>包含的属性依据当前 CUDA 版本会有所不同，可以参考 <a href="https://docs.nvidia.com/cuda/cuda-runtime-api/structcudaDeviceProp.html#structcudaDeviceProp">CUDA 官方文档</a>及其历史版本。</p>
<h6 id="detect-features">detect.features</h6>
<ul>
<li>获取指定工具的所有特性</li>
</ul>
<p>此接口跟<a href="#compiler-features">compiler.features</a>类似，区别就是此接口更加的原始，传入的参数是实际的工具名toolname。</p>
<p>并且此接口不仅能够获取编译器的特性，任何工具的特性都可以获取，因此更加通用。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.features&quot;)

local features = features(&quot;clang&quot;)
local features = features(&quot;clang&quot;, {flags = &quot;-O0&quot;, program = &quot;xcrun -sdk macosx clang&quot;})
local features = features(&quot;clang&quot;, {flags = {&quot;-g&quot;, &quot;-O0&quot;, &quot;-std=c++11&quot;}})
</code></pre>
<p>通过传入flags，可以改变特性的获取结果，例如一些c++11的特性，默认情况下获取不到，通过启用<code>-std=c++11</code>后，就可以获取到了。</p>
<p>所有编译器的特性列表，可以见：<a href="#compiler-features">compiler.features</a>。</p>
<h6 id="detect-has_features">detect.has_features</h6>
<ul>
<li>判断指定特性是否支持</li>
</ul>
<p>此接口跟<a href="#compiler-has_features">compiler.has_features</a>类似，但是更加原始，传入的参数是实际的工具名toolname。</p>
<p>并且此接口不仅能够判断编译器的特性，任何工具的特性都可以判断，因此更加通用。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.has_features&quot;)

local features = has_features(&quot;clang&quot;, &quot;cxx_constexpr&quot;)
local features = has_features(&quot;clang&quot;, {&quot;cxx_constexpr&quot;, &quot;c_static_assert&quot;}, {flags = {&quot;-g&quot;, &quot;-O0&quot;}, program = &quot;xcrun -sdk macosx clang&quot;})
local features = has_features(&quot;clang&quot;, {&quot;cxx_constexpr&quot;, &quot;c_static_assert&quot;}, {flags = &quot;-g&quot;})
</code></pre>
<p>如果指定的特性列表存在，则返回实际支持的特性子列表，如果都不支持，则返回nil，我们也可以通过指定flags去改变特性的获取规则。</p>
<p>所有编译器的特性列表，可以见：<a href="#compiler-features">compiler.features</a>。</p>
<h6 id="detect-has_flags">detect.has_flags</h6>
<ul>
<li>判断指定参数选项是否支持</li>
</ul>
<p>此接口跟<a href="#compiler-has_flags">compiler.has_flags</a>类似，但是更加原始，传入的参数是实际的工具名toolname。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.has_flags&quot;)

local ok = has_flags(&quot;clang&quot;, &quot;-g&quot;)
local ok = has_flags(&quot;clang&quot;, {&quot;-g&quot;, &quot;-O0&quot;}, {program = &quot;xcrun -sdk macosx clang&quot;})
local ok = has_flags(&quot;clang&quot;, &quot;-g -O0&quot;, {toolkind = &quot;cxx&quot;})
</code></pre>
<p>如果检测通过，则返回true。</p>
<p>此接口的检测做了一些优化，除了cache机制外，大部分场合下，会去拉取工具的选项列表（<code>--help</code>）直接判断，如果选项列表里获取不到的话，才会通过尝试运行的方式来检测。</p>
<h6 id="detect-has_cfuncs">detect.has_cfuncs</h6>
<ul>
<li>判断指定c函数是否存在</li>
</ul>
<p>此接口是<a href="#detect-check_cxsnippets">lib.detect.check_cxsnippets</a>的简化版本，仅用于检测函数。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.has_cfuncs&quot;)

local ok = has_cfuncs(&quot;setjmp&quot;)
local ok = has_cfuncs({&quot;sigsetjmp((void*)0, 0)&quot;, &quot;setjmp&quot;}, {includes = &quot;setjmp.h&quot;})
</code></pre>
<p>对于函数的描述规则如下：</p>
<table>
<thead>
<tr>
<th>函数描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sigsetjmp</code></td>
<td>纯函数名</td>
</tr>
<tr>
<td><code>sigsetjmp((void*)0, 0)</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>sigsetjmp{int a = 0; sigsetjmp((void*)a, a);}</code></td>
<td>函数名 + {}块</td>
</tr>
</tbody>
</table>
<p>在最后的可选参数中，除了可以指定<code>includes</code>外，还可以指定其他的一些参数用于控制编译检测的选项条件：</p>
<pre><code class="lang-lua">{ verbose = false, target = [target|option], includes = .., config = {linkdirs = .., links = .., defines = ..}}
</code></pre>
<p>其中verbose用于回显检测信息，target用于在检测前追加target中的配置信息, 而config用于自定义配置跟target相关的编译选项。</p>
<h6 id="detect-has_cxxfuncs">detect.has_cxxfuncs</h6>
<ul>
<li>判断指定c++函数是否存在</li>
</ul>
<p>此接口跟<a href="#detect-has_cfuncs">lib.detect.has_cfuncs</a>类似，请直接参考它的使用说明，唯一区别是这个接口用于检测c++函数。</p>
<h6 id="detect-has_cincludes">detect.has_cincludes</h6>
<ul>
<li>判断指定c头文件是否存在</li>
</ul>
<p>此接口是<a href="#detect-check_cxsnippets">lib.detect.check_cxsnippets</a>的简化版本，仅用于检测头文件。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.has_cincludes&quot;)

local ok = has_cincludes(&quot;stdio.h&quot;)
local ok = has_cincludes({&quot;stdio.h&quot;, &quot;stdlib.h&quot;}, {target = target})
local ok = has_cincludes({&quot;stdio.h&quot;, &quot;stdlib.h&quot;}, {config = {defines = &quot;_GNU_SOURCE=1&quot;, languages = &quot;cxx11&quot;}})
</code></pre>
<h6 id="detect-has_cxxincludes">detect.has_cxxincludes</h6>
<ul>
<li>判断指定c++头文件是否存在</li>
</ul>
<p>此接口跟<a href="#detect-has_cincludes">lib.detect.has_cincludess</a>类似，请直接参考它的使用说明，唯一区别是这个接口用于检测c++头文件。</p>
<h6 id="detect-has_ctypes">detect.has_ctypes</h6>
<ul>
<li>判断指定c类型是否存在</li>
</ul>
<p>此接口是<a href="#detect-check_cxsnippets">lib.detect.check_cxsnippets</a>的简化版本，仅用于检测函数。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.has_ctypes&quot;)

local ok = has_ctypes(&quot;wchar_t&quot;)
local ok = has_ctypes({&quot;char&quot;, &quot;wchar_t&quot;}, {includes = &quot;stdio.h&quot;})
local ok = has_ctypes(&quot;wchar_t&quot;, {includes = {&quot;stdio.h&quot;, &quot;stdlib.h&quot;}, config = {&quot;defines = &quot;_GNU_SOURCE=1&quot;, languages = &quot;cxx11&quot;}})
</code></pre>
<h6 id="detect-has_cxxtypes">detect.has_cxxtypes</h6>
<ul>
<li>判断指定c++类型是否存在</li>
</ul>
<p>此接口跟<a href="#detect-has_ctypes">lib.detect.has_ctypess</a>类似，请直接参考它的使用说明，唯一区别是这个接口用于检测c++类型。</p>
<h6 id="detect-check_cxsnippets">detect.check_cxsnippets</h6>
<ul>
<li>检测c/c++代码片段是否能够编译通过</li>
</ul>
<p>通用的c/c++代码片段检测接口，通过传入多个代码片段列表，它会自动生成一个编译文件，然后常识对它进行编译，如果编译通过返回true。</p>
<p>对于一些复杂的编译器特性，连<a href="#compiler-has_features">compiler.has_features</a>都无法检测到的时候，可以通过此接口通过尝试编译来检测它。</p>
<pre><code class="lang-lua">import(&quot;lib.detect.check_cxsnippets&quot;)

local ok = check_cxsnippets(&quot;void test() {}&quot;)
local ok = check_cxsnippets({&quot;void test(){}&quot;, &quot;#define TEST 1&quot;}, {types = &quot;wchar_t&quot;, includes = &quot;stdio.h&quot;})
</code></pre>
<p>此接口是<a href="#detect-has_cfuncs">detect.has_cfuncs</a>, <a href="#detect-has_cincludes">detect.has_cincludes</a>和<a href="detect-has_ctypes">detect.has_ctypes</a>等接口的通用版本，也更加底层。</p>
<p>因此我们可以用它来检测：types, functions, includes 还有 links，或者是组合起来一起检测。</p>
<p>第一个参数为代码片段列表，一般用于一些自定义特性的检测，如果为空，则可以仅仅检测可选参数中条件，例如：</p>
<pre><code class="lang-lua">local ok = check_cxsnippets({}, {types = {&quot;wchar_t&quot;, &quot;char*&quot;}, includes = &quot;stdio.h&quot;, funcs = {&quot;sigsetjmp&quot;, &quot;sigsetjmp((void*)0, 0)&quot;}})
</code></pre>
<p>上面那个调用，会去同时检测types, includes和funcs是否都满足，如果通过返回true。</p>
<p>还有其他一些可选参数：</p>
<pre><code class="lang-lua">{ verbose = false, target = [target|option], sourcekind = &quot;[cc|cxx]&quot;}
</code></pre>
<p>其中verbose用于回显检测信息，target用于在检测前追加target中的配置信息, sourcekind 用于指定编译器等工具类型，例如传入<code>cxx</code>强制作为c++代码来检测。</p>
<h5 id="net-http">net.http</h5>
<p>此模块提供http的各种操作支持，目前提供的接口如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#http-download">http.download</a></td>
<td>下载http文件</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<h6 id="http-download">http.download</h6>
<ul>
<li>下载http文件</li>
</ul>
<p>这个接口比较简单，就是单纯的下载文件。</p>
<pre><code class="lang-lua">import(&quot;net.http&quot;)

http.download(&quot;https://xmake.io&quot;, &quot;/tmp/index.html&quot;)
</code></pre>
<h5 id="privilege-sudo">privilege.sudo</h5>
<p>此接口用于通过<code>sudo</code>来运行命令，并且提供了平台一致性处理，对于一些需要root权限运行的脚本，可以使用此接口。</p>
<p>&lt;p class=&quot;warn&quot;&gt;<br>为了保证安全性，除非必须使用的场合，其他情况下尽量不要使用此接口。<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#sudo-has">sudo.has</a></td>
<td>判断sudo是否支持</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#sudo-run">sudo.run</a></td>
<td>安静运行程序</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#sudo-runv">sudo.runv</a></td>
<td>安静运行程序，带参数列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#sudo-exec">sudo.exec</a></td>
<td>回显运行程序</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#sudo-execv">sudo.execv</a></td>
<td>回显运行程序，带参数列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#sudo-iorun">sudo.iorun</a></td>
<td>运行并获取程序输出内容</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#sudo-iorunv">sudo.iorunv</a></td>
<td>运行并获取程序输出内容，带参数列表</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<h6 id="sudo-has">sudo.has</h6>
<ul>
<li>判断sudo是否支持</li>
</ul>
<p>目前仅在<code>macosx/linux</code>下支持sudo，windows上的管理员权限运行暂时还不支持，因此建议使用前可以通过此接口判断支持情况后，针对性处理。</p>
<pre><code class="lang-lua">import(&quot;privilege.sudo&quot;)

if sudo.has() then
    sudo.run(&quot;rm /system/file&quot;)
end
</code></pre>
<h6 id="sudo-run">sudo.run</h6>
<ul>
<li>安静运行原生shell命令</li>
</ul>
<p>具体用法可参考：<a href="#os-run">os.run</a>。</p>
<pre><code class="lang-lua">import(&quot;privilege.sudo&quot;)

sudo.run(&quot;rm /system/file&quot;)
</code></pre>
<h6 id="sudo-runv">sudo.runv</h6>
<ul>
<li>安静运行原生shell命令，带参数列表</li>
</ul>
<p>具体用法可参考：<a href="#os-runv">os.runv</a>。</p>
<h6 id="sudo-exec">sudo.exec</h6>
<ul>
<li>回显运行原生shell命令</li>
</ul>
<p>具体用法可参考：<a href="#os-exec">os.exec</a>。</p>
<h6 id="sudo-execv">sudo.execv</h6>
<ul>
<li>回显运行原生shell命令，带参数列表</li>
</ul>
<p>具体用法可参考：<a href="#os-execv">os.execv</a>。</p>
<h6 id="sudo-iorun">sudo.iorun</h6>
<ul>
<li>安静运行原生shell命令并获取输出内容</li>
</ul>
<p>具体用法可参考：<a href="#os-iorun">os.iorun</a>。</p>
<h6 id="sudo-iorunv">sudo.iorunv</h6>
<ul>
<li>安静运行原生shell命令并获取输出内容，带参数列表</li>
</ul>
<p>具体用法可参考：<a href="#os-iorunv">os.iorunv</a>。</p>
<h5 id="devel-git">devel.git</h5>
<p>此接口提供了git各种命令的访问接口，相对于直接调用git命令，此模块提供了更加上层易用的封装接口，并且提供对git的自动检测和跨平台处理。</p>
<p>&lt;p class=&quot;tip&quot;&gt;<br>目前windows上，需要手动安装git包后，才能检测到，后续版本会提供自动集成git功能，用户将不用关心如何安装git，就可以直接使用。<br>&lt;/p&gt;

</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#git-clone">git.clone</a></td>
<td>clone代码库</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#git-pull">git.pull</a></td>
<td>拉取代码库最新提交</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#git-clean">git.clean</a></td>
<td>清理代码库文件</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#git-checkout">git.checkout</a></td>
<td>签出指定分支版本</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#git-refs">git.refs</a></td>
<td>获取所有引用列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#git-tags">git.tags</a></td>
<td>获取所有标记列表</td>
<td>&gt;= 2.1.5</td>
</tr>
<tr>
<td><a href="#git-branches">git.branches</a></td>
<td>获取所有分支列表</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<h6 id="git-clone">git.clone</h6>
<ul>
<li>clone代码库</li>
</ul>
<p>此接口对应<code>git clone</code>命令</p>
<pre><code class="lang-lua">import(&quot;devel.git&quot;)

git.clone(&quot;git@github.com:tboox/xmake.git&quot;)
git.clone(&quot;git@github.com:tboox/xmake.git&quot;, {depth = 1, branch = &quot;master&quot;, outputdir = &quot;/tmp/xmake&quot;})
</code></pre>
<h6 id="git-pull">git.pull</h6>
<ul>
<li>拉取代码库最新提交</li>
</ul>
<p>此接口对应<code>git pull</code>命令</p>
<pre><code class="lang-lua">import(&quot;devel.git&quot;)

git.pull()
git.pull({remote = &quot;origin&quot;, tags = true, branch = &quot;master&quot;, repodir = &quot;/tmp/xmake&quot;})
</code></pre>
<h6 id="git-clean">git.clean</h6>
<ul>
<li>清理代码库文件</li>
</ul>
<p>此接口对应<code>git clean</code>命令</p>
<pre><code class="lang-lua">import(&quot;devel.git&quot;)

git.clean()
git.clean({repodir = &quot;/tmp/xmake&quot;, force = true})
</code></pre>
<h6 id="git-checkout">git.checkout</h6>
<ul>
<li>签出指定分支版本</li>
</ul>
<p>此接口对应<code>git checkout</code>命令</p>
<pre><code class="lang-lua">import(&quot;devel.git&quot;)

git.checkout(&quot;master&quot;, {repodir = &quot;/tmp/xmake&quot;})
git.checkout(&quot;v1.0.1&quot;, {repodir = &quot;/tmp/xmake&quot;})
</code></pre>
<h6 id="git-refs">git.refs</h6>
<ul>
<li>获取所有引用列表 </li>
</ul>
<p>此接口对应<code>git ls-remote --refs</code>命令</p>
<pre><code class="lang-lua">import(&quot;devel.git&quot;)

local refs = git.refs(url)
</code></pre>
<h6 id="git-tags">git.tags</h6>
<ul>
<li>获取所有标记列表 </li>
</ul>
<p>此接口对应<code>git ls-remote --tags</code>命令</p>
<pre><code class="lang-lua">import(&quot;devel.git&quot;)

local tags = git.tags(url)
</code></pre>
<h6 id="git-branches">git.branches</h6>
<ul>
<li>获取所有分支列表 </li>
</ul>
<p>此接口对应<code>git ls-remote --heads</code>命令</p>
<pre><code class="lang-lua">import(&quot;devel.git&quot;)

local branches = git.branches(url)
</code></pre>
<h5 id="utils-archive">utils.archive</h5>
<p>此模块用于压缩和解压缩文件。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>支持版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#archive-extract">archive.extract</a></td>
<td>解压文件</td>
<td>&gt;= 2.1.5</td>
</tr>
</tbody>
</table>
<h6 id="archive-extract">archive.extract</h6>
<ul>
<li>解压文件</li>
</ul>
<p>支持大部分常用压缩文件的解压，它会自动检测系统提供了哪些解压工具，然后适配到最合适的解压器对指定压缩文件进行解压操作。</p>
<pre><code class="lang-lua">import(&quot;utils.archive&quot;)

archive.extract(&quot;/tmp/a.zip&quot;, &quot;/tmp/outputdir&quot;)
archive.extract(&quot;/tmp/a.7z&quot;, &quot;/tmp/outputdir&quot;)
archive.extract(&quot;/tmp/a.gzip&quot;, &quot;/tmp/outputdir&quot;)
archive.extract(&quot;/tmp/a.tar.bz2&quot;, &quot;/tmp/outputdir&quot;)
</code></pre>
