<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="/assets/npm/github-markdown/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/manual/extension_modules">https://xmake.io/#/manual/extension_modules</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <p>All expansion modules need to be imported through the <a href="/mirror/manual/builtin_modules.html#import">import</a> interface.</p>
<h3 id="corebaseoption">core.base.option</h3>
<p>Commonly used to get the value of the xmake command parameter option, often used for plugin development.</p>
<h4 id="optionget">option.get</h4>
<ul>
<li>Get parameter option values</li>
</ul>
<p>Used to get parameter option values in plugin development, for example:</p>
<pre><code class="lang-lua">-- import option module
import("core.base.option")

-- plugin entry function
function main(...)
    print(option.get("info"))
end
</code></pre>
<p>The above code gets the hello plugin and executes: <code>xmake hello --info=xxxx</code> The value of the <code>--info=</code> option passed in the command, and shows: <code>xxxx</code></p>
<p>For task tasks or plugins that are not a main entry, you can use this:</p>
<pre><code class="lang-lua">task("hello")
    on_run(function ())
        import("core.base.option")
        print(option.get("info"))
    end)
</code></pre>
<h3 id="corebaseglobal">core.base.global</h3>
<p>Used to get the configuration information of xmake global, that is, the value of the parameter option passed in <code>xmake g|global --xxx=val</code>.</p>
<p>!> Prior to version 2.1.5, it was <code>core.project.global</code>.</p>
<h4 id="globalget">global.get</h4>
<ul>
<li>Get the specified configuration value</li>
</ul>
<p>Similar to <a href="#configget">config.get</a>, the only difference is that this is obtained from the global configuration.</p>
<h4 id="globalload">global.load</h4>
<ul>
<li>Load configuration</li>
</ul>
<p>Similar to <a href="#globalget">global.get</a>, the only difference is that this is loaded from the global configuration.</p>
<h4 id="globaldirectory">global.directory</h4>
<ul>
<li>Get the global configuration information directory</li>
</ul>
<p>The default is the <code>~/.config</code> directory.</p>
<h4 id="globaldump">global.dump</h4>
<ul>
<li>Print out all global configuration information</li>
</ul>
<p>The output is as follows:</p>
<pre><code class="lang-lua">{
    clean = true
,   ccache = "ccache"
,   xcode_dir = "/Applications/Xcode.app"
}
</code></pre>
<h3 id="corebasetask">core.base.task</h3>
<p>Used for task operations, generally used to call other task tasks in custom scripts and plug-in tasks.</p>
<p>!> Prior to version 2.1.5, it was <code>core.project.task</code>.</p>
<h4 id="taskrun">task.run</h4>
<ul>
<li>Run the specified task</li>
</ul>
<p>Used to run tasks or plugins defined by <a href="#task">task</a> in custom scripts, plugin tasks, for example:</p>
<pre><code class="lang-lua">task("hello")
    on_run(function ()
        print("hello xmake!")
    end)

target("demo")
    on_clean(function(target)

        -- Import task module
        import("core.base.task")

        -- Run this hello task
        task.run("hello")
    end)
</code></pre>
<p>We can also increase parameter passing when running a task, for example:</p>
<pre><code class="lang-lua">task("hello")
    on_run(function (arg1, arg2)
        print("hello xmake: %s %s!", arg1, arg2)
    end)

target("demo")
    on_clean(function(target)

        -- Import task
        import("core.base.task")

        -- {} This is used for the first option, which is set to null, where two arguments are passed in the last: arg1, arg2
        task.run("hello", {}, "arg1", "arg2")
    end)
</code></pre>
<p>The second argument to <code>task.run</code> is used to pass options from the command line menu instead of passing directly into the <code>function (arg, ...)</code> function entry, for example:</p>
<pre><code class="lang-lua">-- Import task
import("core.base.task")

-- Plugin entry
function main(...)

    -- Run the built-in xmake configuration task, equivalent to: xmake f|config --plat=iphoneos --arch=armv7
    task.run("config", {plat="iphoneos", arch="armv7"})
end
</code></pre>
<h3 id="corebasejson">core.base.json</h3>
<p>xmake provides a built-in json module, based on the implementation of lua_cjson, we can use it to quickly and directly interoperate between json and lua table.</p>
<p>We can use <code>import("core.base.json")</code> to directly import and use.</p>
<p>There are also some examples here: <a href="https://github.com/xmake-io/xmake/blob/master/tests/modules/json/test.lua">Jsom Examples</a></p>
<h4 id="jsondecode">json.decode</h4>
<p>Obtain the lua table directly from the string decoding json.</p>
<pre><code class="lang-lua">import("core.base.json")
local luatable = json.decode(&#39;[1,"2", {"a":1, "b":true}]&#39;)
print(luatable)
</code></pre>
<pre><code>{
    1.0,
    "2",
    {
      b = true,
      a = 1.0
    }
  }
</code></pre><p>!> If there is null in it, you can use <code>json.null</code> to judge</p>
<h4 id="jsonencode">json.encode</h4>
<p>We can also directly encode a lua table.</p>
<pre><code class="lang-lua">local jsonstr = json.encode({1, "2", {a = 1}}
</code></pre>
<p>It should be noted that if you need to encode null, you need to use <code>json.null</code>, for example</p>
<pre><code class="lang-lua">local jsonstr = json.encode({json.null, 1, "2", false, true})
</code></pre>
<h4 id="jsonloadfile">json.loadfile</h4>
<p>Load the json file directly and parse it into a lua table.</p>
<pre><code class="lang-lua">local luatable = json.loadfile("/tmp/xxx.json")
</code></pre>
<h4 id="jsonsavefile">json.savefile</h4>
<p>Save the lua table to the specified json file.</p>
<pre><code class="lang-lua">json.savefile("/tmp/xxx.json", {1, {a = 1}})
</code></pre>
<h3 id="coretoollinker">core.tool.linker</h3>
<p>Linker related operations, often used for plugin development.</p>
<h4 id="linkerlink">linker.link</h4>
<ul>
<li>Execute link</li>
</ul>
<p>For the target, link the specified object file list to generate the corresponding target file, for example:</p>
<pre><code class="lang-lua">linker.link("binary", "cc", {"a.o", "b.o", "c.o"}, target:targetfile(), {target = target})
</code></pre>
<p>Where <a href="#target">target</a> is the project target, here is passed in, mainly used to get the target-specific link options. For the project target object, see: <a href="#core-project-project">core.project.project</a></p>
<p>Of course, you can also not specify the target, for example:</p>
<pre><code class="lang-lua">linker.link("binary", "cc", {"a.o", "b.o", "c.o"}, "/tmp/targetfile")
</code></pre>
<p>The first parameter specifies the link type and currently supports: binary, static, shared<br>The second parameter tells the linker that it should be linked as the source file object, and what compiler source files are compiled with, for example:</p>
<table>
<thead>
<tr>
<th>Second Parameter Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>cc</td>
<td>c compiler</td>
</tr>
<tr>
<td>cxx</td>
<td>c++ compiler</td>
</tr>
<tr>
<td>mm</td>
<td>objc compiler</td>
</tr>
<tr>
<td>mxx</td>
<td>objc++ compiler</td>
</tr>
<tr>
<td>gc</td>
<td>go compiler</td>
</tr>
<tr>
<td>as</td>
<td>assembler</td>
</tr>
<tr>
<td>sc</td>
<td>swift compiler</td>
</tr>
<tr>
<td>rc</td>
<td>rust compiler</td>
</tr>
<tr>
<td>dc</td>
<td>dlang compiler</td>
</tr>
</tbody>
</table>
<p>Specifying different compiler types, the linker will adapt the most appropriate linker to handle the link, and if several languages ​​support mixed compilation, you can pass in multiple compiler types at the same time, specifying that the linker chooses to support these hybrid compilations. The linker of the language performs link processing:</p>
<pre><code class="lang-lua">linker.link("binary", {"cc", "mxx", "sc"}, {"a.o", "b.o", "c.o"}, "/tmp/targetfile")
</code></pre>
<p>The above code tells the linker that the three object files a, b, c may be c, objc++, compiled by swift code. The linker will select the most suitable linker from the current system and toolchain to handle the link process. .</p>
<h4 id="linkerlinkcmd">linker.linkcmd</h4>
<ul>
<li>Get link command line string</li>
</ul>
<p>Get the command line string executed in <a href="#linkerlink">linker.link</a> directly, which is equivalent to:</p>
<pre><code class="lang-lua">local cmdstr = linker.linkcmd("static", "cxx", {"a.o", "b.o", "c.o"}, target:targetfile(), {target = target})
</code></pre>
<p>Note: The extension part of <code></code>target = target}` is optional. If the target object is passed, the generated link command will add the link option corresponding to this target configuration.</p>
<p>And you can also pass various configurations yourself, for example:</p>
<pre><code class="lang-lua">local cmdstr = linker.linkcmd("static", "cxx", {"a.o", "b.o", "c.o"}, target:targetfile(), {configs = {linkdirs = "/usr/lib"}})
</code></pre>
<h4 id="linkerlinkargv">linker.linkargv</h4>
<ul>
<li>Get a list of link command line arguments</li>
</ul>
<p>A little different from <a href="#linkerlinkcmd">linker.linkcmd</a> is that this interface returns a list of parameters, table representation, more convenient to operate:</p>
<pre><code class="lang-lua">local program, argv = linker.linkargv("static", "cxx", {"a.o", "b.o", "c.o"}, target:targetfile(), {target = target})
</code></pre>
<p>The first value returned is the main program name, followed by the parameter list, and <code>os.args(table.join(program, argv))</code> is equivalent to <code>linker.linkcmd</code>.</p>
<p>We can also run it directly by passing the return value to <a href="#os-runv">os.runv</a>: <code>os.runv(linker.linkargv(..))</code></p>
<h4 id="linkerlinkflags">linker.linkflags</h4>
<ul>
<li>Get link options</li>
</ul>
<p>Get the link option string part of <a href="#linkerlinkcmd">linker.linkcmd</a> without shellname and object file list, and return by array, for example:</p>
<pre><code class="lang-lua">local flags = linker.linkflags("shared", "cc", {target = target})
for _, flag in ipairs(flags) do
    print(flag)
end
</code></pre>
<p>The returned array of flags is an array.</p>
<h4 id="linkerhas_flags">linker.has_flags</h4>
<ul>
<li>Determine if the specified link option is supported</li>
</ul>
<p>Although it can be judged by <a href="detect-has_flags">lib.detect.has_flags</a>, but the interface is more low-level, you need to specify the linker name.<br>This interface only needs to specify the target type of the target, the source file type, which will automatically switch to select the currently supported linker.</p>
<pre><code class="lang-lua">if linker.has_flags(target:targetkind(), target:sourcekinds(), "-L/usr/lib -lpthread") then
    -- ok
end
</code></pre>
<h3 id="coretoolcompiler">core.tool.compiler</h3>
<p>Compiler related operations, often used for plugin development.</p>
<h4 id="compilercompile">compiler.compile</h4>
<ul>
<li>Perform compilation</li>
</ul>
<p>For the target, link the specified object file list to generate the corresponding target file, for example:</p>
<pre><code class="lang-lua">compiler.compile("xxx.c", "xxx.o", "xxx.h.d", {target = target})
</code></pre>
<p>Where <a href="#target">target</a> is the project target, here is the specific compile option that is mainly used to get the target. If you get the project target object, see: <a href="#core-project-project">core.project.project</a></p>
<p>The <code>xxx.h.d</code> file is used to store the header file dependency file list for this source file. Finally, these two parameters are optional. You can not pass them when compiling:</p>
<pre><code class="lang-lua">compiler.compile("xxx.c", "xxx.o")
</code></pre>
<p>To simply compile a source file.</p>
<h4 id="compilercompcmd">compiler.compcmd</h4>
<ul>
<li>Get the compile command line</li>
</ul>
<p>Get the command line string executed directly in <a href="#compilercompile">compiler.compile</a>, which is equivalent to:</p>
<pre><code class="lang-lua">local cmdstr = compiler.compcmd("xxx.c", "xxx.o", {target = target})
</code></pre>
<p>Note: The extension part of <code></code>target = target}` is optional. If the target object is passed, the generated compile command will add the link option corresponding to this target configuration.</p>
<p>And you can also pass various configurations yourself, for example:</p>
<pre><code class="lang-lua">local cmdstr = compiler.compcmd("xxx.c", "xxx.o", {configs = {includedirs = "/usr/include", defines = "DEBUG"}})
</code></pre>
<p>With target, we can export all source file compilation commands for the specified target:</p>
<pre><code class="lang-lua">import("core.project.project")

for _, target in pairs(project.targets()) do
    for sourcekind, sourcebatch in pairs(target:sourcebatches()) do
        for index, objectfile in ipairs(sourcebatch.objectfiles) do
            local cmdstr = compiler.compcmd(sourcebatch.sourcefiles[index], objectfile, {target = target})
        end
    end
end
</code></pre>
<h4 id="compilercompargv">compiler.compargv</h4>
<ul>
<li>Get compiled command line list</li>
</ul>
<p>A little different from <a href="#compilercompargv">compiler.compargv</a> is that this interface returns a list of parameters, table representation, more convenient to operate:</p>
<pre><code class="lang-lua">local program, argv = compiler.compargv("xxx.c", "xxx.o")
</code></pre>
<h4 id="compilercompflags">compiler.compflags</h4>
<ul>
<li>Get compilation options</li>
</ul>
<p>Get the compile option string part of <a href="#compilercompcmd">compiler.compcmd</a> without shList of ellnames and files, for example:</p>
<pre><code class="lang-lua">local flags = compiler.compflags(sourcefile, {target = target})
for _, flag in ipairs(flags) do
    print(flag)
end
</code></pre>
<p>The returned array of flags is an array.</p>
<h4 id="compilerhas_flags">compiler.has_flags</h4>
<ul>
<li>Determine if the specified compilation option is supported</li>
</ul>
<p>Although it can be judged by <a href="detect-has_flags">lib.detect.has_flags</a>, but the interface is more low-level, you need to specify the compiler name.<br>This interface only needs to specify the language type, it will automatically switch to select the currently supported compiler.</p>
<pre><code class="lang-lua">-- Determine if the c language compiler supports the option: -g
if compiler.has_flags("c", "-g") then
    -- ok
end

-- Determine if the C++ language compiler supports the option: -g
if compiler.has_flags("cxx", "-g") then
    -- ok
end
</code></pre>
<h4 id="compilerfeatures">compiler.features</h4>
<ul>
<li>Get all compiler features</li>
</ul>
<p>Although it can be obtained by <a href="detect-features">lib.detect.features</a>, but the interface is more low-level, you need to specify the compiler name.<br>This interface only needs to specify the language type, it will automatically switch to select the currently supported compiler, and then get the current list of compiler features.</p>
<pre><code class="lang-lua">-- Get all the features of the current c compiler
local features = compiler.features("c")

-- Get all the features of the current C++ language compiler, enable the C++11 standard, otherwise you will not get the new standard features.
local features = compiler.features("cxx", {cofnig = {cxxflags = "-std=c++11"}})

-- Get all the features of the current C++ language compiler, pass all configuration information of the project target
local features = compiler.features("cxx", {target = target, configs = {defines = "..", includedirs = ".."}})
</code></pre>
<p>A list of all c compiler features:</p>
<table>
<thead>
<tr>
<th>Feature Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>c_static_assert</td>
</tr>
<tr>
<td>c_restrict</td>
</tr>
<tr>
<td>c_variadic_macros</td>
</tr>
<tr>
<td>c_function_prototypes</td>
</tr>
</tbody>
</table>
<p>A list of all C++ compiler features:</p>
<table>
<thead>
<tr>
<th>Feature Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>cxx_variable_templates</td>
</tr>
<tr>
<td>cxx_relaxed_constexpr</td>
</tr>
<tr>
<td>cxx_aggregate_default_initializers</td>
</tr>
<tr>
<td>cxx_contextual_conversions</td>
</tr>
<tr>
<td>cxx_attribute_deprecated</td>
</tr>
<tr>
<td>cxx_decltype_auto</td>
</tr>
<tr>
<td>cxx_digit_separators</td>
</tr>
<tr>
<td>cxx_generic_lambdas</td>
</tr>
<tr>
<td>cxx_lambda_init_captures</td>
</tr>
<tr>
<td>cxx_binary_literals</td>
</tr>
<tr>
<td>cxx_return_type_deduction</td>
</tr>
<tr>
<td>cxx_decltype_incomplete_return_types</td>
</tr>
<tr>
<td>cxx_reference_qualified_functions</td>
</tr>
<tr>
<td>cxx_alignof</td>
</tr>
<tr>
<td>cxx_attributes</td>
</tr>
<tr>
<td>cxx_inheriting_constructors</td>
</tr>
<tr>
<td>cxx_thread_local</td>
</tr>
<tr>
<td>cxx_alias_templates</td>
</tr>
<tr>
<td>cxx_delegating_constructors</td>
</tr>
<tr>
<td>cxx_extended_friend_declarations</td>
</tr>
<tr>
<td>cxx_final</td>
</tr>
<tr>
<td>cxx_nonstatic_member_init</td>
</tr>
<tr>
<td>cxx_override</td>
</tr>
<tr>
<td>cxx_user_literals</td>
</tr>
<tr>
<td>cxx_constexpr</td>
</tr>
<tr>
<td>cxx_defaulted_move_initializers</td>
</tr>
<tr>
<td>cxx_enum_forward_declarations</td>
</tr>
<tr>
<td>cxx_noexcept</td>
</tr>
<tr>
<td>cxx_nullptr</td>
</tr>
<tr>
<td>cxx_range_for</td>
</tr>
<tr>
<td>cxx_unrestricted_unions</td>
</tr>
<tr>
<td>cxx_explicit_conversions</td>
</tr>
<tr>
<td>cxx_lambdas</td>
</tr>
<tr>
<td>cxx_local_type_template_args</td>
</tr>
<tr>
<td>cxx_raw_string_literals</td>
</tr>
<tr>
<td>cxx_auto_type</td>
</tr>
<tr>
<td>cxx_defaulted_functions</td>
</tr>
<tr>
<td>cxx_deleted_functions</td>
</tr>
<tr>
<td>cxx_generalized_initializers</td>
</tr>
<tr>
<td>cxx_inline_namespaces</td>
</tr>
<tr>
<td>cxx_sizeof_member</td>
</tr>
<tr>
<td>cxx_strong_enums</td>
</tr>
<tr>
<td>cxx_trailing_return_types</td>
</tr>
<tr>
<td>cxx_unicode_literals</td>
</tr>
<tr>
<td>cxx_uniform_initialization</td>
</tr>
<tr>
<td>cxx_variadic_templates</td>
</tr>
<tr>
<td>cxx_decltype</td>
</tr>
<tr>
<td>cxx_default_function_template_args</td>
</tr>
<tr>
<td>cxx_long_long_type</td>
</tr>
<tr>
<td>cxx_right_angle_brackets</td>
</tr>
<tr>
<td>cxx_rvalue_references</td>
</tr>
<tr>
<td>cxx_static_assert</td>
</tr>
<tr>
<td>cxx_extern_templates</td>
</tr>
<tr>
<td>cxx_func_identifier</td>
</tr>
<tr>
<td>cxx_variadic_macros</td>
</tr>
<tr>
<td>cxx_template_template_parameters</td>
</tr>
</tbody>
</table>
<h4 id="compilerhas_features">compiler.has_features</h4>
<ul>
<li>Determine if the specified compiler feature is supported</li>
</ul>
<p>Although it can be obtained by <a href="detect-has-features">lib.detect.has_features</a>, but the interface is more low-level, you need to specify the compiler name.<br>And this interface only needs to specify the special name list that needs to be detected, it can automatically switch to select the currently supported compiler, and then determine whether the specified feature is supported in the current compiler.</p>
<pre><code class="lang-lua">if compiler.has_features("c_static_assert") then
    -- ok
end

if compiler.has_features({"c_static_assert", "cxx_constexpr"}, {languages ​​= "cxx11"}) then
    -- ok
end

if compiler.has_features("cxx_constexpr", {target = target, defines = "..", includedirs = ".."}) then
    -- ok
end
</code></pre>
<p>For specific feature names, refer to <a href="#compilerfeatures">compiler.features</a>.</p>
<h3 id="coreprojectconfig">core.project.config</h3>
<p>Used to get the configuration information when the project is compiled, that is, the value of the parameter option passed in <code>xmake f|config --xxx=val</code>.</p>
<h4 id="configget">config.get</h4>
<ul>
<li>Get the specified configuration value</li>
</ul>
<p>Used to get the configuration value of <code>xmake f|config --xxx=val</code>, for example:</p>
<pre><code class="lang-lua">target("test")
    on_run(function (target)

        -- Import configuration module
        import("core.project.config")

        -- Get configuration values
        print(config.get("xxx"))
    end)
</code></pre>
<h4 id="configload">config.load</h4>
<ul>
<li>Load configuration</li>
</ul>
<p>Generally used in plug-in development, the plug-in task is not like the custom script of the project, the environment needs to be initialized and loaded by itself, the default project configuration is not loaded, if you want to use <a href="#configget">config.get</a> interface to get the project Configuration, then you need to:</p>
<pre><code class="lang-lua">
-- Import configuration module
import("core.project.config")

function main(...)

    -- Load project configuration first
    config.load()

    -- Get configuration values
    print(config.get("xxx"))
end
</code></pre>
<h4 id="configarch">config.arch</h4>
<ul>
<li>Get the schema configuration of the current project</li>
</ul>
<p>That is to get the platform configuration of <code>xmake f|config --arch=armv7</code>, which is equivalent to <code>config.get("arch")</code>.</p>
<h4 id="configplat">config.plat</h4>
<ul>
<li>Get the platform configuration of the current project</li>
</ul>
<p>That is to get the platform configuration of <code>xmake f|config --plat=iphoneos</code>, which is equivalent to <code>config.get("plat")</code>.</p>
<h4 id="configmode">config.mode</h4>
<ul>
<li>Get the compilation mode configuration of the current project</li>
</ul>
<p>That is to get the platform configuration of <code>xmake f|config --mode=debug</code>, which is equivalent to <code>config.get("mode")</code>.</p>
<h4 id="configbuildir">config.buildir</h4>
<ul>
<li>Get the output directory configuration of the current project</li>
</ul>
<p>That is to get the platform configuration of <code>xmake f|config -o /tmp/output</code>, which is equivalent to <code>config.get("buildir")</code>.</p>
<h4 id="configdirectory">config.directory</h4>
<ul>
<li>Get the configuration information directory of the current project</li>
</ul>
<p>Get the storage directory of the project configuration, the default is: <code>projectdir/.config</code></p>
<h4 id="configdump">config.dump</h4>
<ul>
<li>Print out all configuration information of the current project</li>
</ul>
<p>The output is for example:</p>
<pre><code class="lang-lua">{
    sh = "xcrun -sdk macosx clang++"
,   xcode_dir = "/Applications/Xcode.app"
,   ar = "xcrun -sdk macosx ar"
,   small = true
,   object = false
,   arch = "x86_64"
,   xcode_sdkver = "10.12"
,   ex = "xcrun -sdk macosx ar"
,   cc = "xcrun -sdk macosx clang"
,   rc = "rustc"
,   plat = "macosx"
,   micro = false
,   host = "macosx"
,   as = "xcrun -sdk macosx clang"
,   dc = "dmd"
,   gc = "go"
,   openssl = false
,   ccache = "ccache"
,   cxx = "xcrun -sdk macosx clang"
,   sc = "xcrun -sdk macosx swiftc"
,   mm = "xcrun -sdk macosx clang"
,   buildir = "build"
,   mxx = "xcrun -sdk macosx clang++"
,   ld = "xcrun -sdk macosx clang++"
,   mode = "release"
,   kind = "static"
}
</code></pre>
<h3 id="coreprojectproject">core.project.project</h3>
<p>Used to get some description information of the current project, that is, the configuration information defined in the <code>xmake.lua</code> project description file, for example: <a href="#target">target</a>, <a href="#option">option</a>, etc.</p>
<h4 id="projectload">project.load</h4>
<ul>
<li>Load project description configuration</li>
</ul>
<p>It is only used in the plugin, because the project configuration information has not been loaded at this time. In the custom script of the project target, you do not need to perform this operation, you can directly access the project configuration.</p>
<pre><code class="lang-lua">-- Import engineering modules
import("core.project.project")

-- Plugin entry
function main(...)

    -- Load project description configuration
    project.load()

    -- access project descriptions, such as getting specified project goals
    local target = project.target("test")
end
</code></pre>
<p>!> After version 2.1.5, if not needed, the project load will automatically load at the appropriate time.</p>
<h4 id="projectdirectory">project.directory</h4>
<ul>
<li>Get the project directory</li>
</ul>
<p>Get the current project directory, which is the directory specified in <code>xmake -P xxx</code>, otherwise it is the default current <code>xmake</code> command execution directory.</p>
<p>!> After version 2.1.5, it is recommended to use <a href="#os-projectdir">os.projectdir</a> to get it.</p>
<h4 id="projecttarget">project.target</h4>
<ul>
<li>Get the specified project target object</li>
</ul>
<p>Get and access the specified project target configuration, for example:</p>
<pre><code class="lang-lua">local target = project.target("test")
if target then

    -- Get the target file name
    print(target:targetfile())

    -- Get the target type, which is: binary, static, shared
    print(target:targetkind())

    -- Get the target name
    print(target:name())

    -- Get the target source file
    local sourcefiles = target:sourcefiles()

    -- Get a list of target installation header files
    local srcheaders, dstheaders = target:headerfiles()

    -- Get target dependencies
    print(target:get("deps"))
end
</code></pre>
<h4 id="projecttargets">project.targets</h4>
<ul>
<li>Get a list of project target objects</li>
</ul>
<p>Returns all compilation targets for the current project, for example:</p>
<pre><code class="lang-lua">for targetname, target in pairs(project.targets()) do
    print(target:targetfile())
end
</code></pre>
<h4 id="projectoption">project.option</h4>
<ul>
<li>Get the specified option object</li>
</ul>
<p>Get and access the option objects specified in the project, for example:</p>
<pre><code class="lang-lua">local option = project.option("test")
if option:enabled() then
    option:enable(false)
end
</code></pre>
<h4 id="projectoptions">project.options</h4>
<ul>
<li>Get all project option objects</li>
</ul>
<p>Returns all compilation targets for the current project, for example:</p>
<pre><code class="lang-lua">for optionname, option in pairs(project.options())
    print(option:enabled())
end
</code></pre>
<h4 id="projectname">project.name</h4>
<ul>
<li>Get the current project name</li>
</ul>
<p>That is, get the project name configuration of <a href="#set_project">set_project</a>.</p>
<pre><code class="lang-lua">print(project.name())
</code></pre>
<h4 id="projectversion">project.version</h4>
<ul>
<li>Get the current project version number</li>
</ul>
<p>That is, get <a href="#set_version">set_version</a> project version configuration.</p>
<pre><code class="lang-lua">print(project.version())
</code></pre>
<h3 id="corelanguagelanguage">core.language.language</h3>
<p>Used to obtain information about the compiled language, generally used for the operation of code files.</p>
<h4 id="languageextensions">language.extensions</h4>
<ul>
<li>Get a list of code suffixes for all languages</li>
</ul>
<p>The results are as follows:</p>
<pre><code class="lang-lua">{
     [".c"] = cc
,    [".cc"] = cxx
,    [".cpp"] = cxx
,    [".m"] = mm
,    [".mm"] = mxx
,    [".swift"] = sc
,    [".go"] = gc
}
</code></pre>
<h4 id="languagetargetkinds">language.targetkinds</h4>
<ul>
<li>Get a list of target types in all languages</li>
</ul>
<p>The results are as follows:</p>
<pre><code class="lang-lua">{
     binary = {"ld", "gcld", "dcld"}
,    static = {"ar", "gcar", "dcar"}
,    shared = {"sh", "dcsh"}
}
</code></pre>
<h4 id="languagesourcekinds">language.sourcekinds</h4>
<ul>
<li>Get a list of source file types in all languages</li>
</ul>
<p>The results are as follows:</p>
<pre><code class="lang-lua">{
     cc = ".c"
,    cxx = {".cc", ".cpp", ".cxx"}
,    mm = ".m"
,    mxx = ".mm"
,    sc = ".swift"
,    gc = ".go"
,    rc = ".rs"
,    dc = ".d"
,    as = {".s", ".S", ".asm"}
}
</code></pre>
<h4 id="languagesourceflags">language.sourceflags</h4>
<ul>
<li>Load a list of source file compilation option names for all languages</li>
</ul>
<p>The results are as follows:</p>
<pre><code class="lang-lua">{
     cc = {"cflags", "cxflags"}
,    cxx = {"cxxflags", "cxflags"}
,    ...
}
</code></pre>
<h4 id="languageload">language.load</h4>
<ul>
<li>Load the specified language</li>
</ul>
<p>Load a specific language object from the language name, for example:</p>
<pre><code class="lang-lua">local lang = language.load("c++")
if lang then
    print(lang:name())
end
</code></pre>
<h4 id="languageload_sk">language.load_sk</h4>
<ul>
<li>Load the specified language from the source file type</li>
</ul>
<p>Load specific language objects from the source file type: <code>cc, cxx, mm, mxx, sc, gc, as ..</code>, for example:</p>
<pre><code class="lang-lua">local lang = language.load_sk("cxx")
if lang then
    print(lang:name())
end
</code></pre>
<h4 id="languageload_ex">language.load_ex</h4>
<ul>
<li>Load the specified language from the source file suffix name</li>
</ul>
<p>Load specific language objects from the source file extension: <code>.cc, .c, .cpp, .mm, .swift, .go ..</code>, for example:</p>
<pre><code class="lang-lua">local lang = language.load_ex(".cpp")
if lang then
    print(lang:name())
end
</code></pre>
<h4 id="languagesourcekind_of">language.sourcekind_of</h4>
<ul>
<li>Get the source file type of the specified source file</li>
</ul>
<p>That is, from a given source file path, get the type of source file it belongs to, for example:</p>
<pre><code class="lang-lua">print(language.sourcekind_of("/xxxx/test.cpp"))
</code></pre>
<p>The result is: <code>cxx</code>, which is the <code>c++</code> type. For the corresponding list, see: <a href="#languagesourcekinds">language.sourcekinds</a></p>
<h3 id="libdetect">lib.detect</h3>
<p>This module provides very powerful probing capabilities for probing programs, compilers, language features, dependencies, and more.</p>
<p>!> The interface of this module is spread across multiple module directories, try to import it by importing a single interface, which is more efficient.</p>
<h4 id="detectfind_file">detect.find_file</h4>
<ul>
<li>Find files</li>
</ul>
<p>This interface provides a more powerful project than <a href="#os-files">os.files</a>, which can specify multiple search directories at the same time, and can also specify additional subdirectories for each directory to match the pattern lookup, which is equivalent to <a href="#os-files"> An enhanced version of os.files</a>.</p>
<p>E.g:</p>
<pre><code class="lang-lua">import("lib.detect.find_file")

local file = find_file("ccache", { "/usr/bin", "/usr/local/bin"})
</code></pre>
<p>If found, the result returned is: <code>/usr/bin/ccache</code></p>
<p>It also supports pattern matching paths for recursive lookups, similar to <code>os.files</code>:</p>
<pre><code class="lang-lua">local file = find_file("test.h", { "/usr/include", "/usr/local/include/**"})
</code></pre>
<p>Not only that, but the path inside also supports built-in variables to get the path from the environment variables and the registry to find:</p>
<pre><code class="lang-lua">local file = find_file("xxx.h", { "$(env PATH)", "$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name)"})
</code></pre>
<p>If the path rules are more complex, you can also dynamically generate path entries through a custom script:</p>
<pre><code class="lang-lua">local file = find_file("xxx.h", { "$(env PATH)", function () return val("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name"):match ("\"(.-)\"") end})
</code></pre>
<p>In most cases, the above use has met various needs. If you need some extended functions, you can customize some optional configurations by passing in the third parameter, for example:</p>
<pre><code class="lang-lua">local file = find_file("test.h", { "/usr", "/usr/local"}, {suffixes = {"/include", "/lib"}})
</code></pre>
<p>By specifying a list of suffixes subdirectories, you can extend the list of paths (the second parameter) so that the actual search directory is expanded to:</p>
<pre><code>/usr/include
/usr/lib
/usr/local/include
/usr/local/lib
</code></pre><p>And without changing the path list, you can dynamically switch subdirectories to search for files.</p>
<p>!> We can also quickly call and test this interface with the <code>xmake lua</code> plugin: <code>xmake lua lib.detect.find_file test.h /usr/local</code></p>
<h4 id="detectfind_path">detect.find_path</h4>
<ul>
<li>Find the path</li>
</ul>
<p>The usage of this interface is similar to <a href="#detectfind_file">lib.detect.find_file</a>, the only difference is that the returned results are different.<br>After the interface finds the incoming file path, it returns the corresponding search path, not the file path itself. It is generally used to find the parent directory location corresponding to the file.</p>
<pre><code class="lang-lua">import("lib.detect.find_path")

local p = find_path("include/test.h", { "/usr", "/usr/local"})
</code></pre>
<p>If the above code is successful, it returns: <code>/usr/local</code>, if <code>test.h</code> is in <code>/usr/local/include/test.h</code>.</p>
<p>Another difference is that this interface is passed in not only the file path, but also the directory path to find:</p>
<pre><code class="lang-lua">local p = find_path("lib/xxx", { "$(env PATH)", "$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name)"})
</code></pre>
<p>Again, this interface also supports pattern matching and suffix subdirectories:</p>
<pre><code class="lang-lua">local p = find_path("include/*.h", { "/usr", "/usr/local/**"}, {suffixes = "/subdir"})
</code></pre>
<h4 id="detectfind_library">detect.find_library</h4>
<ul>
<li>Find library files</li>
</ul>
<p>This interface is used to find library files (static libraries, dynamic libraries) in the specified search directory, for example:</p>
<pre><code class="lang-lua">import("lib.detect.find_library")

local library = find_library("crypto", {"/usr/lib", "/usr/local/lib"})
</code></pre>
<p>Running on macosx, the results returned are as follows:</p>
<pre><code class="lang-lua">{
    filename = libcrypto.dylib
,   linkdir = /usr/lib
,   link = crypto
,   kind = shared
}
</code></pre>
<p>If you do not specify whether you need a static library or a dynamic library, then this interface will automatically select an existing library (either a static library or a dynamic library) to return.</p>
<p>If you need to force the library type you need to find, you can specify the kind parameter as (<code>static/shared</code>):</p>
<pre><code class="lang-lua">local library = find_library("crypto", {"/usr/lib", "/usr/local/lib"}, {kind = "static"})
</code></pre>
<p>This interface also supports suffixes suffix subdirectory search and pattern matching operations:</p>
<pre><code class="lang-lua">local library = find_library("cryp*", {"/usr", "/usr/local"}, {suffixes = "/lib"})
</code></pre>
<h4 id="detectfind_program">detect.find_program</h4>
<ul>
<li>Find executable programs</li>
</ul>
<p>This interface is more primitive than <a href="#detectfind_tool">lib.detect.find_tool</a>, looking for executables through the specified parameter directory.</p>
<pre><code class="lang-lua">import("lib.detect.find_program")

local program = find_program("ccache")
</code></pre>
<p>The above code is like not passing the search directory, so it will try to execute the specified program directly. If it runs ok, it will return directly: <code>ccache</code>, indicating that the search is successful.</p>
<p>Specify the search directory and modify the test command parameters that are attempted to run (default: <code>ccache --version</code>):</p>
<pre><code class="lang-lua">localProgram = find_program("ccache", {pathes = {"/usr/bin", "/usr/local/bin"}, check = "--help"})
</code></pre>
<p>The above code will try to run: <code>/usr/bin/ccache --help</code>, if it runs successfully, it returns: <code>/usr/bin/ccache</code>.</p>
<p>If <code>--help</code> can&#39;t satisfy the requirement, some programs don&#39;t have the <code>--version/--help</code> parameter, then you can customize the run script to run the test:</p>
<pre><code class="lang-lua">local program = find_program("ccache", {pathes = {"/usr/bin", "/usr/local/bin"}, check = function (program) os.run("%s -h", program) end })
</code></pre>
<p>Similarly, the search path list supports built-in variables and custom scripts:</p>
<pre><code class="lang-lua">local program = find_program("ccache", {pathes = {"$(env PATH)", "$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug;Debugger)"}})
local program = find_program("ccache", {pathes = {"$(env PATH)", function () return "/usr/local/bin" end}})
</code></pre>
<p>!> In order to speed up the efficiency of frequent lookups, this interface comes with a default cache, so even if you frequently find the same program, it will not take too much time.<br>If you want to disable the cache, you can clear the local cache by executing <code>xmake f -c</code> in the project directory.</p>
<p>We can also test quickly with <code>xmake lua lib.detect.find_program ccache</code>.</p>
<h4 id="detectfind_programver">detect.find_programver</h4>
<ul>
<li>Find the executable version number</li>
</ul>
<pre><code class="lang-lua">import("lib.detect.find_programver")

local programver = find_programver("ccache")
</code></pre>
<p>The return result is: 3.2.2</p>
<p>By default it will try to get the version via <code>ccache --version</code>. If this parameter doesn&#39;t exist, you can specify other parameters yourself:</p>
<pre><code class="lang-lua">local version = find_programver("ccache", {command = "-v"})
</code></pre>
<p>Even the custom version gets the script:</p>
<pre><code class="lang-lua">local version = find_programver("ccache", {command = function () return os.iorun("ccache --version") end})
</code></pre>
<p>For the extraction rule of the version number, if the built-in matching mode does not meet the requirements, you can also customize:</p>
<pre><code class="lang-lua">local version = find_programver("ccache", {command = "--version", parse = "(%d+%.?%d*%.?%d*.-)%s"})
local version = find_programver("ccache", {command = "--version", parse = function (output) return output:match("(%d+%.?%d*%.?%d*.-)%s ") end})
</code></pre>
<p>!> In order to speed up the efficiency of frequent lookups, this interface is self-contained by default. If you want to disable the cache, you can execute <code>xmake f -c</code> in the project directory to clear the local cache.</p>
<p>We can also test quickly with <code>xmake lua lib.detect.find_programver ccache</code>.</p>
<h4 id="detectfind_package">detect.find_package</h4>
<ul>
<li>Find package files</li>
</ul>
<p>After 2.6.x this interface is not recommended for direct use (internal use only), for library integration, please use <code>add_requires()</code> and <code>add_packages()</code> as much as possible.</p>
<h4 id="detectfind_tool">detect.find_tool</h4>
<ul>
<li>Find tool</li>
</ul>
<p>This interface is also used to find executable programs, but more<br>advanced than <a href="#detectfind_program">lib.detect.find_program</a>, the<br>function is also more powerful, it encapsulates the executable<br>program, providing the concept of tools:</p>
<ul>
<li>toolname: tool name, short for executable program, used to mark a</li>
<li>tool, for example: <code>gcc</code>, <code>clang</code>, etc.  program: executable program</li>
<li>command, for example: <code>xcrun -sdk macosx clang</code></li>
</ul>
<p>The corresponding relationship is as follows:</p>
<table>
<thead>
<tr>
<th>toolname</th>
<th>program</th>
</tr>
</thead>
<tbody>
<tr>
<td>clang</td>
<td><code>xcrun -sdk macosx clang</code></td>
</tr>
<tr>
<td>gcc</td>
<td><code>/usr/toolchains/bin/arm-linux-gcc</code></td>
</tr>
<tr>
<td>link</td>
<td><code>link.exe -lib</code></td>
</tr>
</tbody>
</table>
<p><a href="#detectfind_program">lib.detect.find_program</a> can only determine<br>whether the program exists by passing in the original program command<br>or path.  And <code>find_tool</code> can find the tool through a more consistent<br>toolname, and return the corresponding program complete command path,<br>for example:</p>
<pre><code class="lang-lua">import("lib.detect.find_tool")

local tool = find_tool("clang")
</code></pre>
<p>The result returned is: <code>{name = "clang", program = "clang"}</code>, at this<br>time there is no difference, we can manually specify the executable<br>command:</p>
<pre><code class="lang-lua">local tool = find_tool("clang", {program = "xcrun -sdk macosx clang"})
</code></pre>
<p>The result returned is: <code>{name = "clang", program = "xcrun -sdk macosx
clang"}</code></p>
<p>In macosx, gcc is clang. If we execute <code>gcc --version</code>, we can see<br>that it is a vest of clang. We can intelligently identify it through<br>the <code>find_tool</code> interface:</p>
<pre><code class="lang-lua">local tool = find_tool("gcc")
</code></pre>
<p>The result returned is: <code>{name = "clang", program = "gcc"}</code></p>
<p>The difference can be seen by this result. The tool name will actually<br>be marked as clang, but the executable command uses gcc.</p>
<p>We can also specify the <code>{version = true}</code> parameter to get the<br>version of the tool, and specify a custom search path. It also<br>supports built-in variables and custom scripts:</p>
<pre><code class="lang-lua">local tool = find_tool("clang", {version = true, {pathes = {"/usr/bin", "/usr/local/bin", "$(env PATH)", function () return "/usr/xxx/bin" end}})
</code></pre>
<p>The result returned is: <code>{name = "clang", program = "/usr/bin/clang",
version = "4.0"}</code></p>
<p>This interface is a high-level wrapper around <code>find_program</code>, so it<br>also supports custom script detection:</p>
<pre><code class="lang-lua">local tool = find_tool("clang", {check = "--help"})
local tool = find_tool("clang", {check = function (tool) os.run("%s -h", tool) end})
</code></pre>
<p>Finally, the search process of <code>find_tool</code>:</p>
<ol>
<li>First try to run and detect with the argument of <code>{program =
"xxx"}</code>.  2. If there is a <code>detect.tools.find_xxx</code> script in<br><code>xmake/modules/detect/tools</code>, call this script for more accurate<br>detection.  3. Try to detect from the system directory such as<br><code>/usr/bin</code>, <code>/usr/local/bin</code>.</li>
</ol>
<p>We can also add a custom lookup script to the module directory<br>specified by <code>add_moduledirs</code> in the project <code>xmake.lua</code> to improve<br>the detection mechanism:</p>
<pre><code>projectdir
- xmake/modules
- detect/tools/find_xxx.lua
</code></pre><p>For example, we customize a lookup script for <code>find_7z.lua</code>:</p>
<pre><code class="lang-lua">import("lib.detect.find_program")
import("lib.detect.find_programver")

function main(opt)

    -- init options
    opt = opt or {}

    -- find program
    local program = find_program(opt.program or "7z", opt.pathes, opt.check or "--help")

    -- find program version
    local version = nil
    if program and opt and opt.version then
        version = find_programver(program, "--help", "(%d+%.?%d*)%s")
    end

    -- ok?
    return program, version
end
</code></pre>
<p>After placing it in the project&#39;s module directory, execute: <code>xmake l
lib.detect.find_tool 7z</code> to find it.</p>
<p>!> In order to speed up the efficiency of frequent<br>lookups, this interface is self-contained by default. If you want to<br>disable the cache, you can execute <code>xmake f -c</code> in the project<br>directory to clear the local cache.</p>
<p>We can also test quickly with <code>xmake lua lib.detect.find_tool clang</code>.</p>
<h4 id="detectfind_toolname">detect.find_toolname</h4>
<ul>
<li>Find tool name</li>
</ul>
<p>Match the corresponding tool name with the program command, for<br>example:</p>
<table>
<thead>
<tr>
<th>program</th>
<th>toolname</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>xcrun -sdk macosx clang</code></td>
<td>clang</td>
</tr>
<tr>
<td><code>/usr/bin/arm-linux-gcc</code></td>
<td>gcc</td>
</tr>
<tr>
<td><code>link.exe -lib</code></td>
<td>link</td>
</tr>
<tr>
<td><code>gcc-5</code></td>
<td>gcc</td>
</tr>
<tr>
<td><code>arm-android-clang++</code></td>
<td>clangxx</td>
</tr>
<tr>
<td><code>pkg-config</code></td>
<td>pkg_config</td>
</tr>
</tbody>
</table>
<p>Compared with program, toolname can uniquely mark a tool, and it is also convenient to find and load the corresponding script <code>find_xxx.lua</code>.</p>
<h4 id="detectfind_cudadevices">detect.find_cudadevices</h4>
<ul>
<li>Find CUDA devices of the host</li>
</ul>
<p>Enumerate CUDA devices through the CUDA Runtime API and query theirs properties.</p>
<pre><code class="lang-lua">import("lib.detect.find_cudadevices")

local devices = find_cudadevices({ skip_compute_mode_prohibited = true })
local devices = find_cudadevices({ min_sm_arch = 35, order_by_flops = true })
</code></pre>
<p>The result returned is: <code>{ { [&#39;$id&#39;] = 0, name = "GeForce GTX 960M", major = 5, minor = 0, ... }, ... }</code></p>
<p>The included properties will vary depending on the current CUDA version.<br>Please refer to <a href="https://docs.nvidia.com/cuda/cuda-runtime-api/structcudaDeviceProp.html#structcudaDeviceProp">CUDA Toolkit Documentation</a> and its historical version for more information.</p>
<h4 id="detectfeatures">detect.features</h4>
<ul>
<li>Get all the features of the specified tool</li>
</ul>
<p>This interface is similar to <a href="#compilerfeatures">compiler.features</a>. The difference is that this interface is more primitive. The passed argument is the actual tool name toolname.</p>
<p>And this interface not only can get the characteristics of the compiler, the characteristics of any tool can be obtained, so it is more versatile.</p>
<pre><code class="lang-lua">import("lib.detect.features")

local features = features("clang")
local features = features("clang", {flags = "-O0", program = "xcrun -sdk macosx clang"})
local features = features("clang", {flags = {"-g", "-O0", "-std=c++11"}})
</code></pre>
<p>By passing in flags, you can change the result of the feature, for example, some features of C++11, which are not available by default. After enabling <code>-std=c++11</code>, you can get it.</p>
<p>A list of all compiler features can be found at <a href="#compilerfeatures">compiler.features</a>.</p>
<h4 id="detecthas_features">detect.has_features</h4>
<ul>
<li>Determine if the specified feature is supported</li>
</ul>
<p>This interface is similar to <a href="#compilerhas_features">compiler.has_features</a>, but more primitive, the passed argument is the actual tool name toolname.</p>
<p>And this interface can not only judge the characteristics of the compiler, but the characteristics of any tool can be judged, so it is more versatile.</p>
<pre><code class="lang-lua">import("lib.detect.has_features")

local features = has_features("clang", "cxx_constexpr")
local features = has_features("clang", {"cxx_constexpr", "c_static_assert"}, {flags = {"-g", "-O0"}, program = "xcrun -sdk macosx clang"})
local features = has_features("clang", {"cxx_constexpr", "c_static_assert"}, {flags = "-g"})
</code></pre>
<p>If the specified feature list exists, the actual supported feature sublist is returned. If none is supported, nil is returned. We can also change the feature acquisition rule by specifying flags.</p>
<p>A list of all compiler features can be found at <a href="#compilerfeatures">compiler.features</a>.</p>
<h4 id="detecthas_flags">detect.has_flags</h4>
<ul>
<li>Determine if the specified parameter option is supported</li>
</ul>
<p>This interface is similar to <a href="#compilerhas_flags">compiler.has_flags</a>, but more primitive, the passed argument is the actual tool name toolname.</p>
<pre><code class="lang-lua">import("lib.detect.has_flags")

local ok = has_flags("clang", "-g")
local ok = has_flags("clang", {"-g", "-O0"}, {program = "xcrun -sdk macosx clang"})
local ok = has_flags("clang", "-g -O0", {toolkind = "cxx"})
</code></pre>
<p>Returns true if the test passed.</p>
<p>The detection of this interface has been optimized. Except for the cache mechanism, in most cases, the tool&#39;s option list (<code>--help</code>) will be directly judged. If the option list is not available, it will be tried. The way to run to detect.</p>
<h4 id="detecthas_cfuncs">detect.has_cfuncs</h4>
<ul>
<li>Determine if the specified c function exists</li>
</ul>
<p>This interface is a simplified version of <a href="#detectcheck_cxsnippets">lib.detect.check_cxsnippets</a> and is only used to detect functions.</p>
<pre><code class="lang-lua">import("lib.detect.has_cfuncs")

local ok = has_cfuncs("setjmp")
local ok = has_cfuncs({"sigsetjmp((void*)0, 0)", "setjmp"}, {includes = "setjmp.h"})
</code></pre>
<p>The rules for describing functions are as follows:</p>
<table>
<thead>
<tr>
<th>Function Description</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sigsetjmp</code></td>
<td>pure function name</td>
</tr>
<tr>
<td><code>sigsetjmp((void*)0, 0)</code></td>
<td>Function Call</td>
</tr>
<tr>
<td><code>sigsetjmp{int a = 0; sigsetjmp((void*)a, a);}</code></td>
<td>function name + {} block</td>
</tr>
</tbody>
</table>
<p>In the last optional parameter, in addition to specifying <code>includes</code>, you can also specify other parameters to control the option conditions for compile detection:</p>
<pre><code class="lang-lua">{ verbose = false, target = [target|option], includes = .., configs = {linkdirs = .., links = .., defines = ..}}
</code></pre>
<p>The verbose is used to echo the detection information, the target is used to append the configuration information in the target before the detection, and the config is used to customize the compilation options related to the target.</p>
<h4 id="detecthas_cxxfuncs">detect.has_cxxfuncs</h4>
<ul>
<li>Determine if the specified c++ function exists</li>
</ul>
<p>This interface is similar to <a href="#detecthas_cfuncs">lib.detect.has_cfuncs</a>, please refer to its instructions for use. The only difference is that this interface is used to detect c++ functions.</p>
<h4 id="detecthas_cincludes">detect.has_cincludes</h4>
<ul>
<li>Determine if the specified c header file exists</li>
</ul>
<p>This interface is a simplified version of <a href="#detectcheck_cxsnippets">lib.detect.check_cxsnippets</a> and is only used to detect header files.</p>
<pre><code class="lang-lua">import("lib.detect.has_cincludes")

local ok = has_cincludes("stdio.h")
local ok = has_cincludes({"stdio.h", "stdlib.h"}, {target = target})
local ok = has_cincludes({"stdio.h", "stdlib.h"}, {configs = {defines = "_GNU_SOURCE=1", languages ​​= "cxx11"}})
</code></pre>
<h4 id="detecthas_cxxincludes">detect.has_cxxincludes</h4>
<ul>
<li>Determine if the specified c++ header file exists</li>
</ul>
<p>This interface is similar to <a href="#detecthas_cincludes">lib.detect.has_cincludess</a>, please refer to its instructions for use. The only difference is that this interface is used to detect c++ header files.</p>
<h4 id="detecthas_ctypes">detect.has_ctypes</h4>
<ul>
<li>Determine if the specified c type exists</li>
</ul>
<p>This interface is a simplified version of <a href="#detectcheck_cxsnippets">lib.detect.check_cxsnippets</a> and is only used to detect functions.</p>
<pre><code class="lang-lua">import("lib.detect.has_ctypes")

local ok = has_ctypes("wchar_t")
local ok = has_ctypes({"char", "wchar_t"}, {includes = "stdio.h"})
local ok = has_ctypes("wchar_t", {includes = {"stdio.h", "stdlib.h"}, configs = {"defines = "_GNU_SOURCE=1", languages ​​= "cxx11"}})
</code></pre>
<h4 id="detecthas_cxxtypes">detect.has_cxxtypes</h4>
<ul>
<li>Determine if the specified c++ type exists</li>
</ul>
<p>This interface is similar to <a href="#detecthas_ctypes">lib.detect.has_ctypess</a>. Please refer to its instructions for use. The only difference is that this interface is used to detect c++ types.</p>
<h4 id="detectcheck_cxsnippets">detect.check_cxsnippets</h4>
<ul>
<li>Check if the c/c++ code snippet can be compiled</li>
</ul>
<p>The generic c/c++ code snippet detection interface, by passing in a list of multiple code snippets, it will automatically generate a compiled file, and then common sense to compile it, if the compilation pass returns true.</p>
<p>For some complex compiler features, even if <a href="#compilerhas_features">compiler.has_features</a> can&#39;t detect it, you can detect it by trying to compile through this interface.</p>
<pre><code class="lang-lua">import("lib.detect.check_cxsnippets")

local ok = check_cxsnippets("void test() {}")
local ok = check_cxsnippets({"void test(){}", "#define TEST 1"}, {types = "wchar_t", includes = "stdio.h"})
</code></pre>
<p>This interface is a generic version of interfaces such as <a href="#detecthas_cfuncs">detect.has_cfuncs</a>, <a href="#detecthas_cincludes">detect.has_cincludes</a>, and <a href="detect-has_ctypes">detect.has_ctypes</a>, and is also lower level.</p>
<p>So we can use it to detect: types, functions, includes and links, or combine them together to detect.</p>
<p>The first parameter is a list of code fragments, which are generally used for the detection of some custom features. If it is empty, it can only detect the conditions in the optional parameters, for example:</p>
<pre><code class="lang-lua">local ok = check_cxsnippets({}, {types = {"wchar_t", "char*"}, includes = "stdio.h", funcs = {"sigsetjmp", "sigsetjmp((void*)0, 0)"} })
</code></pre>
<p>The above call will check if the types, includes and funcs are both satisfied, and return true if passed.</p>
<p>There are other optional parameters:</p>
<pre><code class="lang-lua">{ verbose = false, target = [target|option], sourcekind = "[cc|cxx]"}
</code></pre>
<p>The verbose is used to echo the detection information. The target is used to append the configuration information in the target before the detection. The sourcekind is used to specify the tool type such as the compiler. For example, the incoming <code>cxx</code> is forced to be detected as c++ code.</p>
<h3 id="nethttp">net.http</h3>
<p>This module provides various operational support for http. The currently available interfaces are as follows:</p>
<h4 id="httpdownload">http.download</h4>
<ul>
<li>Download http file</li>
</ul>
<p>This interface is relatively simple, is simply download files.</p>
<pre><code class="lang-lua">import("net.http")

http.download("https://xmake.io", "/tmp/index.html")
</code></pre>
<h3 id="privilegesudo">privilege.sudo</h3>
<p>This interface is used to run commands via <code>sudo</code> and provides platform consistency handling, which can be used for scripts that require root privileges to run.</p>
<p>!> In order to ensure security, unless you must use it, try not to use this interface in other cases.</p>
<h4 id="sudohas">sudo.has</h4>
<ul>
<li>Determine if sudo supports</li>
</ul>
<p>At present, sudo is supported only under <code>macosx/linux</code>. The administrator privilege running on Windows is not supported yet. Therefore, it is recommended to use the interface to judge the support situation before use.</p>
<pre><code class="lang-lua">import("privilege.sudo")

if sudo.has() then
    sudo.run("rm /system/file")
end
</code></pre>
<h4 id="sudorun">sudo.run</h4>
<ul>
<li>Quietly running native shell commands</li>
</ul>
<p>For specific usage, please refer to: <a href="#os-run">os.run</a>.</p>
<pre><code class="lang-lua">import("privilege.sudo")

sudo.run("rm /system/file")
</code></pre>
<h4 id="sudorunv">sudo.runv</h4>
<ul>
<li>Quietly running native shell commands with parameter list</li>
</ul>
<p>For specific usage, please refer to: <a href="#os-runv">os.runv</a>.</p>
<h4 id="sudoexec">sudo.exec</h4>
<ul>
<li>Echo running native shell commands</li>
</ul>
<p>For specific usage, please refer to: <a href="#os-exec">os.exec</a>.</p>
<h4 id="sudoexecv">sudo.execv</h4>
<ul>
<li>Echo running native shell commands with parameter list</li>
</ul>
<p>For specific usage, please refer to: <a href="#os-execv">os.execv</a>.</p>
<h4 id="sudoiorun">sudo.iorun</h4>
<ul>
<li>Quietly running native shell commands and getting output</li>
</ul>
<p>For specific usage, please refer to: <a href="#os-iorun">os.iorun</a>.</p>
<h4 id="sudoiorunv">sudo.iorunv</h4>
<ul>
<li>Run the native shell command quietly and get the output with a list of parameters</li>
</ul>
<p>For specific usage, please refer to: <a href="#os-iorunv">os.iorunv</a>.</p>
<h3 id="develgit">devel.git</h3>
<p>This interface provides access to various commands of git. Compared to the direct call to git command, this module provides a more easy-to-use package interface and provides automatic detection and cross-platform processing for git.</p>
<p>!> Currently on Windows, you need to manually install the git package before you can detect it. The subsequent version will provide automatic integration of git function. Users will not need to care about how to install git, they can be used directly.</p>
<h4 id="gitclone">git.clone</h4>
<ul>
<li>clone codebase</li>
</ul>
<p>This interface corresponds to the <code>git clone</code> command.</p>
<pre><code class="lang-lua">import("devel.git")

git.clone("git@github.com:tboox/xmake.git")
git.clone("git@github.com:tboox/xmake.git", {depth = 1, branch = "master", outputdir = "/tmp/xmake"})
</code></pre>
<h4 id="gitpull">git.pull</h4>
<ul>
<li>Pull the code base for the latest submission</li>
</ul>
<p>This interface corresponds to the <code>git pull</code> command.</p>
<pre><code class="lang-lua">import("devel.git")

git.pull()
git.pull({remote = "origin", tags = true, branch = "master", repodir = "/tmp/xmake"})
</code></pre>
<h4 id="gitclean">git.clean</h4>
<ul>
<li>Clean up the code base file</li>
</ul>
<p>This interface corresponds to the <code>git clean</code> command.</p>
<pre><code class="lang-lua">import("devel.git")

git.clean()
git.clean({repodir = "/tmp/xmake", force = true})
</code></pre>
<h4 id="gitcheckout">git.checkout</h4>
<ul>
<li>Check out the specified branch version</li>
</ul>
<p>This interface corresponds to the <code>git checkout</code> command</p>
<pre><code class="lang-lua">import("devel.git")

git.checkout("master", {repodir = "/tmp/xmake"})
git.checkout("v1.0.1", {repodir = "/tmp/xmake"})
</code></pre>
<h4 id="gitrefs">git.refs</h4>
<ul>
<li>Get a list of all references</li>
</ul>
<p>This interface corresponds to the <code>git ls-remote --refs</code> command</p>
<pre><code class="lang-lua">import("devel.git")

local refs = git.refs(url)
</code></pre>
<h4 id="gittags">git.tags</h4>
<ul>
<li>Get a list of all tags</li>
</ul>
<p>This interface corresponds to the <code>git ls-remote --tags</code> command</p>
<pre><code class="lang-lua">import("devel.git")

local tags = git.tags(url)
</code></pre>
<h4 id="gitbranches">git.branches</h4>
<ul>
<li>Get a list of all branches</li>
</ul>
<p>This interface corresponds to the <code>git ls-remote --heads</code> command</p>
<pre><code class="lang-lua">import("devel.git")

local branches = git.branches(url)
</code></pre>
<h3 id="utilsarchive">utils.archive</h3>
<p>This module is used to compress and decompress files.</p>
<h4 id="archiveextract">archive.extract</h4>
<ul>
<li>unzip files</li>
</ul>
<p>Supports the decompression of most commonly used compressed files. It automatically detects which decompression tools are provided by the system, and then adapts them to the most suitable decompressor to decompress the specified compressed files.</p>
<pre><code class="lang-lua">import("utils.archive")

archive.extract("/tmp/a.zip", "/tmp/outputdir")
archive.extract("/tmp/a.7z", "/tmp/outputdir")
archive.extract("/tmp/a.gzip", "/tmp/outputdir")
archive.extract("/tmp/a.tar.bz2", "/tmp/outputdir")
</code></pre>
<h3 id="utilsplatform">utils.platform</h3>
<p>This module is used for some platform-related auxiliary operation interfaces</p>
<h4 id="utilsplatformgnu2mslib">utils.platform.gnu2mslib</h4>
<ul>
<li>Convert mingw&#39;s libxxxdll.a to msvc&#39;s xxx.lib library</li>
</ul>
<p>This feature is particularly helpful for Fortran &amp; C++ mixed projects, because VS does not provide the fortran compiler. You can only use MinGW&#39;s gfortran to compile the fortran part, and then link with the VS project.<br>Often such projects also have some other libraries provided in the vs format, so pure MinGW compilation is not possible, you can only use this function to mix compilation.</p>
<p>And cmake also has a similar <a href="https://cmake.org/cmake/help/latest/prop_tgt/GNUtoMS.html">GNUtoMS</a>.</p>
<p>For related issues, see: <a href="https://github.com/xmake-io/xmake/issues/1181">#1181</a></p>
<pre><code class="lang-lua">import("utils.platform.gnu2mslib")

gnu2mslib("xxx.lib", "xxx.dll.a")
gnu2mslib("xxx.lib", "xxx.def")
gnu2mslib("xxx.lib", "xxx.dll.a", {dllname = "xxx.dll", arch = "x64"})
</code></pre>
<p>Support to generate xxx.lib from def, and also support to automatically export .def from xxx.dll.a, and then generate xxx.lib</p>
<p>If you don’t want to automatically generate def from dll.a, but want to borrow the def generated by gnu linker, then configure it yourself through add_shflags("-Wl,--output-def,xxx.def") to generate def, and then pass in def to this interface. .</p>
<p><code>{dllname = xxx, arch = "xxx"}</code> These are optional, according to your needs.</p>
<p>You can also directly xmake l utils.platform.gnu2mslib xxx.lib xxx.dll.a quick test verification</p>
</article>
</body>
</html>