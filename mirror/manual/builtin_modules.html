<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>xmake</title>
  <link rel="icon" href="/assets/img/favicon.ico">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link href="//cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" rel="stylesheet">
  <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
  </style>
</head>
<body>
<article class="markdown-body">
<h4>This is a mirror page, please see the original page: </h4><a href="https://xmake.io/#/manual/builtin_modules">https://xmake.io/#/manual/builtin_modules</a>
</br>
    <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7I52QU&placement=xmakeio" id="_carbonads_js"></script>
<style>
#carbonads {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
}

#carbonads {
  display: flex;
  max-width: 330px;
  background-color: hsl(0, 0%, 98%);
  box-shadow: 0 1px 4px 1px hsla(0, 0%, 0%, .1);
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

#carbonads .carbon-wrap {
  display: flex;
}

.carbon-img {
  display: block;
  margin: 0;
  line-height: 1;
}

.carbon-img img {
  display: block;
}

.carbon-text {
  font-size: 13px;
  padding: 10px;
  line-height: 1.5;
  text-align: left;
}

.carbon-poweredby {
  display: block;
  padding: 8px 10px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-align: center;
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
    <p>Used in script code such as custom scripts, plug-in scripts, task scripts, platform extensions, template extensions, etc., that is, in code blocks like the following, you can use these module interfaces:</p>
<pre><code class="lang-lua">on_run(function (target)
    print("hello xmake!")
end)
</code></pre>
<p><p class="warn"><br>In order to ensure that the description field of the outer layer is as simple and secure as possible, it is generally not recommended to use the interface and module operation api in this domain. Therefore, most module interfaces can only be used in the script domain to implement complex functions. </br><br>Of course, a small number of read-only built-in interfaces can still be used in the description field, as shown in the following table:<br></p>

</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
<th>Available Domains</th>
<th>Supported Versions</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#val">val</a></td>
<td>Get the value of the built-in variable</td>
<td>Script Field</td>
<td>>= 2.1.5</td>
</tr>
<tr>
<td><a href="#import">import</a></td>
<td>Importing Extension Blocks</td>
<td>Script Fields</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#inherit">inherit</a></td>
<td>Import and inherit base class modules</td>
<td>Script Domain</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#try-catch-finally">try-catch-finally</a></td>
<td>Exception Capture</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pairs">pairs</a></td>
<td>Used to Traverse the Dictionary</td>
<td>Description Field, Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ipairs">ipairs</a></td>
<td>Used to traverse arrays</td>
<td>Description fields, script fields</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#print">print</a></td>
<td>Wrap Print Terminal Log</td>
<td>Description Field, Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#printf">printf</a></td>
<td>No Line Printing Terminal Log</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#cprint">cprint</a></td>
<td>Wrap Color Print Terminal Log</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#cprintf">cprintf</a></td>
<td>No Line Color Print Terminal Log</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#format">format</a></td>
<td>Format String</td>
<td>Description Field, Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#vformat">vformat</a></td>
<td>Format string, support for built-in variable escaping</td>
<td>Script Domain</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#raise">raise</a></td>
<td>Throwing an abort program</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#os">os</a></td>
<td>System Operation Module</td>
<td>Partial Read-Only Operation Description Field, Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#io">io</a></td>
<td>File Manipulation Module</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#path">path</a></td>
<td>Path Manipulation Module</td>
<td>Description Field, Script Field</td>
<td>= 2.0.1</td>
</tr>
<tr>
<td><a href="#table">table</a></td>
<td>Array and Dictionary Operations Module</td>
<td>Description Field, Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#string">string</a></td>
<td>String Manipulation Module</td>
<td>Description Field, Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#process">process</a></td>
<td>Process Operation Module</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#coroutine">coroutine</a></td>
<td>Coroutine Operation Module</td>
<td>Script Field</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#find_packages">find_packages</a></td>
<td>Find Dependency Packages</td>
<td>Script Fields</td>
<td>>= 2.2.5</td>
</tr>
</tbody>
</table>
<p>An example of using an interface call in a description field is as follows, generally only for conditional control:</p>
<pre><code class="lang-lua">-- Scan all subdirectories under the current xmake.lua directory, defining a task task with the name of each directory
for _, taskname in ipairs(os.dirs("*"), path.basename) do
    task(taskname)
        on_run(function ()
        end)
end
</code></pre>
<p>The script field and description field mentioned above mainly refer to:</p>
<pre><code class="lang-lua">-- Description field
target("test")

    -- Description field
    set_kind("static")
    add_files("src/*.c")

    on_run(function (target)
        -- Script domain
    end)

-- Description field
</code></pre>
<h3 id="val">val</h3>
<h4 id="getthevalueofthebuiltinvariable">Get the value of the built-in variable</h4>
<p><a href="/mirror/manual/builtin_variables.html">Built-in variables</a> can be obtained directly through this interface, without the need to add a <code>$()</code> package, which is much simpler to use, for example:</p>
<pre><code class="lang-lua">print(val("host"))
print(val("env PATH"))
local s = val("shell echo hello")
</code></pre>
<p>Using <a href="#vformat">vformat</a> is cumbersome:</p>
<pre><code class="lang-lua">local s = vformat("$(shell echo hello)")
</code></pre>
<p>However, <code>vformat</code> supports string parameter formatting, which is more powerful, so the application scenario is different.</p>
<h3 id="import">import</h3>
<h4 id="importingextensionblocks">Importing extension blocks</h4>
<p>Import is mainly used to import xmake&#39;s extension class library and some custom class library modules, generally used to:</p>
<ul>
<li>Custom script (<a href="/mirror/manual/project_target.html#targeton_build">on_build</a>, <a href="/mirror/manual/project_target.html#targeton_run">on_run</a> ..)</li>
<li>Plugin development</li>
<li>Template development</li>
<li>Platform extension</li>
<li>Custom task task</li>
</ul>
<p>The import mechanism is as follows:</p>
<ol>
<li>Import from the current script directory first</li>
<li>Import from the extended class library</li>
</ol>
<p>Imported grammar rules:</p>
<p>Class library path rules based on <code>.</code>, for example:</p>
<p>Import core core extension module</p>
<pre><code class="lang-lua">import("core.base.option")
import("core.base.task")

function main()

    -- Get parameter options
    print(option.get("version"))

    -- Run tasks and plugins
    task.run("hello")
end
</code></pre>
<p>Import the custom module in the current directory:</p>
<p>Directory Structure:</p>
<pre><code>Plugin
  - xmake.lua
  - main.lua
  - modules
    - hello1.lua
    - hello2.lua
</code></pre><p>Import modules in main.lua</p>
<pre><code class="lang-lua">import("modules.hello1")
import("modules.hello2")
</code></pre>
<p>After importing, you can directly use all the public interfaces inside. The private interface is marked with the <code>_</code> prefix, indicating that it will not be exported and will not be called externally. .</p>
<p>In addition to the current directory, we can also import libraries in other specified directories, for example:</p>
<pre><code class="lang-lua">import("hello3", {rootdir = "/home/xxx/modules"})
</code></pre>
<p>To prevent naming conflicts, you can also specify an alias after import:</p>
<pre><code class="lang-lua">import("core.platform.platform", {alias = "p"})

function main()

    -- So we can use p to call the plats interface of the platform module to get a list of all the platforms supported by xmake.
    utils.dump(p.plats())
end
</code></pre>
<p>Import can not only import the class library, but also import and import as inheritance, realize the inheritance relationship between modules.</p>
<pre><code class="lang-lua">import("xxx.xxx", {inherit = true})
</code></pre>
<p>This is not a reference to the module, but all the public interfaces of the module imported, so that it will be merged with the interface of the current module to achieve inheritance between modules.</p>
<p>Version 2.1.5 adds two new properties: `import("xxx.xxx", {try = true, anonymous = true}).</p>
<p>If the try is true, the imported module does not exist, only return nil, and will not interrupt xmake after throwing an exception.<br>If anonymous is true, the imported module will not introduce the current scope, only the imported object reference will be returned in the import interface.</p>
<h3 id="inherit">inherit</h3>
<h4 id="importandinheritbaseclassmodules">Import and inherit base class modules</h4>
<p>This is equivalent to the <code>inherit</code> mode of the <a href="#import">import</a> interface, which is:</p>
<pre><code class="lang-lua">import("xxx.xxx", {inherit = true})
</code></pre>
<p>With the <code>inherit</code> interface, it will be more concise:</p>
<pre><code class="lang-lu">Inherit("xxx.xxx")
</code></pre>
<p>For an example, see the script in the xmake tools directory: <a href="#https://github.com/xmake-io/xmake/blob/master/xmake/tools/clang.lua">clang.lua</a></p>
<p>This is part of the clang tool module that inherits gcc.</p>
<h3 id="trycatchfinally">try-catch-finally</h3>
<h4 id="exceptioncapture">Exception capture</h4>
<p>Lua native does not provide try-catch syntax to catch exception handling, but provides interfaces such as <code>pcall/xpcall</code> to execute lua functions in protected mode.</p>
<p>Therefore, the capture mechanism of the try-catch block can be implemented by encapsulating these two interfaces.</p>
<p>We can look at the packaged try-catch usage first:</p>
<pre><code class="lang-lua">try
{
    -- try code block
    function ()
        error("error message")
    end,

    -- catch code block
    catch
    {
        -- After an exception occurs, it is executed
        function (errors)
            print(errors)
        end
    }
}
</code></pre>
<p>In the above code, an exception is thrown inside the try block, and an error message is thrown, caught in the catch, and the error message is output.</p>
<p>And finally processing, this role is for the <code>try{}</code> code block, regardless of whether the execution is successful, will be executed into the finally block</p>
<p>In other words, in fact, the above implementation, the complete support syntax is: <code>try-catch-finally</code> mode, where catch and finally are optional, according to their actual needs.</p>
<p>E.g:</p>
<pre><code class="lang-lua">try
{
    -- try code block
    function ()
        error("error message")
    end,

    -- catch code block
    catch
    {
        -- After an exception occurs, it is executed
        function (errors)
            print(errors)
        end
    },

    -- finally block
    finally
    {
        -- Finally will be executed here
        function (ok, errors)
            -- If there is an exception in try{}, ok is true, errors is the error message, otherwise it is false, and error is the return value in try
        end
    }
}

</code></pre>
<p>Or only the finally block:</p>
<pre><code class="lang-lua">try
{
    -- try code block
    function ()
        return "info"
    end,

    -- finally block
    finally
    {
        -- Since there is no exception in this try code, ok is true and errors is the return value: "info"
        function (ok, errors)
        end
    }
}
</code></pre>
<p>Processing can get the normal return value in try in finally, in fact, in the case of only try, you can also get the return value:</p>
<pre><code class="lang-lua">-- If no exception occurs, result is the return value: "xxxx", otherwise nil
local result = try
{
    function ()
        return "xxxx"
    end
}
</code></pre>
<p>In xmake&#39;s custom scripting and plugin development, it is also based entirely on this exception catching mechanism.</p>
<p>This makes the development of the extended script very succinct and readable, eliminating the cumbersome <code>if err ~= nil then</code> return value judgment. When an error occurs, xmake will directly throw an exception to interrupt, and then highlight the detailed error. information.</p>
<p>E.g:</p>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*.c")

    -- After the ios program is compiled, the target program is ldid signed
    after_build(function (target))
        os.run("ldid -S %s", target:targetfile())
    end
</code></pre>
<p>Only one line <code>os.run</code> is needed, and there is no need to return a value to determine whether it runs successfully. After the operation fails, xmake will automatically throw an exception, interrupt the program and prompt the error.</p>
<p>If you want to run xmake without running interrupts directly after running, you can do it yourself.Add a try and you will be fine:</p>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*.c")

    after_build(function (target))
        try
        {
            function ()
                os.run("ldid -S %s", target:targetfile())
            end
        }
    end
</code></pre>
<p>If you want to capture the error message, you can add a catch:</p>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*.c")

    after_build(function (target))
        try
        {
            function ()
                os.run("ldid -S %s", target:targetfile())
            end,
            catch
            {
                function (errors)
                    print(errors)
                end
            }
        }
    end
</code></pre>
<p>However, in general, write custom scripts in xmake, do not need to manually add try-catch, directly call a variety of api, after the error, let xmake default handler to take over, directly interrupted. .</p>
<h3 id="pairs">pairs</h3>
<h4 id="usedtotraversethedictionary">Used to traverse the dictionary</h4>
<p>This is lua&#39;s native built-in api. In xmake, it has been extended in its original behavior to simplify some of the daily lua traversal code.</p>
<p>First look at the default native notation:</p>
<pre><code class="lang-lua">local t = {a = "a", b = "b", c = "c", d = "d", e = "e", f = "f"}

for key, val in pairs(t) do
    print("%s: %s", key, val)
end
</code></pre>
<p>This is sufficient for normal traversal operations, but if we get the uppercase for each of the elements it traverses, we can write:</p>
<pre><code class="lang-lua">for key, val in pairs(t, function (v) return v:upper() end) do
     print("%s: %s", key, val)
end
</code></pre>
<p>Even pass in some parameters to the second <code>function</code>, for example:</p>
<pre><code class="lang-lua">for key, val in pairs(t, function (v, a, b) return v:upper() .. a .. b end, "a", "b") do
     print("%s: %s", key, val)
end
</code></pre>
<h3 id="ipairs">ipairs</h3>
<h4 id="fortraversingarrays">for traversing arrays</h4>
<p>This is lua&#39;s native built-in api. In xmake, it has been extended in its original behavior to simplify some of the daily lua traversal code.</p>
<p>First look at the default native notation:</p>
<pre><code class="lang-lua">for idx, val in ipairs({"a", "b", "c", "d", "e", "f"}) do
     print("%d %s", idx, val)
end
</code></pre>
<p>The extension is written like the <a href="#pairs">pairs</a> interface, for example:</p>
<pre><code class="lang-lua">for idx, val in ipairs({"a", "b", "c", "d", "e", "f"}, function (v) return v:upper() end) do
     print("%d %s", idx, val)
end

for idx, val in ipairs({"a", "b", "c", "d", "e", "f"}, function (v, a, b) return v:upper() .. a .. b end, "a", "b") do
     print("%d %s", idx, val)
end
</code></pre>
<p>This simplifies the logic of the <code>for</code> block code. For example, if I want to traverse the specified directory and get the file name, but not including the path, I can simplify the writing by this extension:</p>
<pre><code class="lang-lua">for _, filename in ipairs(os.dirs("*"), path.filename) do
    -- ...
end
</code></pre>
<h3 id="print">print</h3>
<h4 id="wrappingprintterminallog">Wrapping print terminal log</h4>
<p>This interface is also the native interface of lua. xmake is also extended based on the original behavior, and supports: formatted output, multivariable output.</p>
<p>First look at the way native support:</p>
<pre><code class="lang-lua">print("hello xmake!")
print("hello", "xmake!", 123)
</code></pre>
<p>And also supports extended formatting:</p>
<pre><code class="lang-lua">print("hello %s!", "xmake")
print("hello xmake! %d", 123)
</code></pre>
<p>Xmake will support both types of writing at the same time, and the internal will automatically detect and select the output behavior.</p>
<h3 id="printf">printf</h3>
<h4 id="nolineprintingterminallog">No line printing terminal log</h4>
<p>Like the <a href="#print">print</a> interface, the only difference is that it doesn&#39;t wrap.</p>
<h3 id="cprint">cprint</h3>
<h4 id="wrapcolorprintterminallog">Wrap color print terminal log</h4>
<p>The behavior is similar to <a href="#print">print</a>, the difference is that this interface also supports color terminal output, and supports <code>emoji</code> character output.</p>
<p>E.g:</p>
<pre><code class="lang-lua">    cprint(&#39;${bright}hello xmake&#39;)
    cprint(&#39;${red}hello xmake&#39;)
    cprint(&#39;${bright green}hello ${clear}xmake&#39;)
    cprint(&#39;${blue onyellow underline}hello xmake${clear}&#39;)
    cprint(&#39;${red}hello ${magenta}xmake&#39;)
    cprint(&#39;${cyan}hello ${dim yellow}xmake&#39;)
</code></pre>
<p>The results are as follows:</p>
<p><img src="https://tboox.org/static/img/xmake/cprint_colors.png" alt="cprint_colors"></p>
<p>The color-related descriptions are placed in <code>${ }</code>, and you can set several different properties at the same time, for example:</p>
<pre><code>    ${bright red underline onyellow}
</code></pre><p>Indicates: highlighted red, background yellow, and with a down line</p>
<p>All of these descriptions will affect the entire entire line of characters. If you only want to display partial color text, you can insert <code>${clear}</code> at the end position to clear the previous color description.</p>
<p>E.g:</p>
<pre><code>    ${red}hello ${clear}xmake
</code></pre><p>In this case, only hello is displayed in red, and the others are still normal black display.</p>
<p>Other colors belong to, I will not introduce them here, directly paste the list of attributes in the xmake code:</p>
<pre><code class="lang-lua">    colors.keys =
    {
        -- Attributes
        reset = 0 -- reset attribute
    , clear = 0 -- clear attribute
    , default = 0 -- default property
    , bright = 1 -- highlight
    , dim = 2 -- dark
    , underline = 4 -- underline
    , blink = 5 -- flashing
    , reverse = 7 -- reverse color
    , hidden = 8 -- hidden text

        -- Foreground
    , black = 30
    , red = 31
    , green = 32
    , yellow = 33
    , blue = 34
    , magenta = 35
    , cyan = 36
    , white = 37

        -- Background color
    , onblack = 40
    , onred = 41
    , ongreen = 42
    , onyellow = 43
    , onblue = 44
    , onmagenta = 45
    , oncyan = 46
    , onwhite = 47
</code></pre>
<p>In addition to color highlighting, if your terminal is under macosx, lion above the system, xmake can also support the display of emoji expressions, for systems that do not support<br>Ignore the display, for example:</p>
<pre><code class="lang-lua">    cprint("hello xmake${beer}")
    cprint("hello${ok_hand} xmake")
</code></pre>
<p>The above two lines of code, I printed a classic beer symbol in the homebrew, the following line printed an ok gesture symbol, is not very dazzling. .</p>
<p><img src="https://tboox.org/static/img/xmake/cprint_emoji.png" alt="cprint_emoji"></p>
<p>All emoji emoticons, as well as the corresponding keys in xmake, can be found in <a href="http://www.emoji-cheat-sheet.com/">emoji</a>. .</p>
<p>Version 2.1.7 supports 24-bit true color output, if the terminal supports it:</p>
<pre><code class="lang-lua">import("core.base.colors")
if colors.truecolor() then
    cprint("${255;0;0}hello")
    cprint("${on;255;0;0}hello${clear} xmake")
    cprint("${bright 255;0;0 underline}hello")
    cprint("${bright on;255;0;0 0;255;0}hello${clear} xmake")
end
</code></pre>
<p>Xmake&#39;s detection support for truecolor is implemented by the <code>$COLORTERM</code> environment variable. If your terminal supports truecolor, you can manually set this environment variable to tell xmake to enable truecolor support.</p>
<p>It can be enabled and tested with the following command:</p>
<pre><code class="lang-bash">$ export COLORTERM=truecolor
$ xmake --version
</code></pre>
<p>The 2.1.7 version can disable color output with <code>COLORTERM=nocolor</code>.</p>
<h3 id="cprintf">cprintf</h3>
<h4 id="nolinefeedcolorprintterminallog">No line feed color print terminal log</h4>
<p>This interface is similar to <a href="#cprint">cprint</a>, the difference is that it does not wrap the output.</p>
<h3 id="format">format</h3>
<h4 id="formattingastring">Formatting a string</h4>
<p>If you just want to format the string and don&#39;t output it, you can use this interface. This interface is equivalent to the <a href="#stringformat">string.format</a> interface, just a simplified version of the interface name.</p>
<pre><code class="lang-lua">local s = format("hello %s", xmake)
</code></pre>
<h3 id="vformat">vformat</h3>
<h4 id="formattingstringssupportforbuiltinvariableescaping">Formatting strings, support for built-in variable escaping</h4>
<p>This interface is followed by <a href="The #format">format</a> interface is similar, but adds support for the acquisition and escaping of built-in variables.</p>
<pre><code class="lang-lua">local s = vformat("hello %s $(mode) $(arch) $(env PATH)", xmake)
</code></pre>
<h3 id="raise">raise</h3>
<h4 id="throwinganabortprogram">Throwing an abort program</h4>
<p>If you want to interrupt xmake running in custom scripts and plug-in tasks, you can use this interface to throw an exception. If the upper layer does not show the call to <a href="#try-catch-finally">try-catch</a>, xmake will be executed. An error message is displayed.</p>
<pre><code class="lang-lua">if (errors) raise(errors)
</code></pre>
<p>If an exception is thrown in the try block, the error information is captured in catch and finally. See: <a href="#try-catch-finally">try-catch</a></p>
<h3 id="find_packages">find_packages</h3>
<h4 id="findingdependencies">Finding dependencies</h4>
<p>This interface is a wrapper around the <a href="/mirror/manual/extension_modules.html#detectfind_package">lib.detect.find_package</a> interface and provides lookup support for multiple dependencies, for example:</p>
<pre><code class="lang-lua">target("test")
    set_kind("binary")
    add_files("src/*.c")
    on_load(function (target)
        target:add(find_packages("openssl", "zlib"))
    end)
</code></pre>
<h3 id="os">os</h3>
<p>The system operation module belongs to the built-in module. It can be called directly by the script field without using <a href="#import">import</a> import.</p>
<p>This module is also a native module of lua, and xmake has been extended to provide more practical interfaces.</p>
<p><p class="tip"><br>Only some readonly interfaces (for example: <code>os.getenv</code>, <code>os.arch</code>) in the os module can be used in the description field. Other interfaces can only be used in the script domain, for example: <code>os.cp</code>, <code>os .rm</code>etc.<br></p>

</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
<th>Supported Versions</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#oscp">os.cp</a></td>
<td>Copy files or directories</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osmv">os.mv</a></td>
<td>Move Renamed File or Directory</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osrm">os.rm</a></td>
<td>Delete files or directory tree</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ostrycp">os.trycp</a></td>
<td>Try copying files or directories</td>
<td>>= 2.1.6</td>
</tr>
<tr>
<td><a href="#ostrymv">os.trymv</a></td>
<td>Try moving the renamed file or directory</td>
<td>>= 2.1.6</td>
</tr>
<tr>
<td><a href="#ostryrm">os.tryrm</a></td>
<td>Try deleting a file or directory tree</td>
<td>>= 2.1.6</td>
</tr>
<tr>
<td><a href="#oscd">os.cd</a></td>
<td>Go to the specified directory</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osrmdir">os.rmdir</a></td>
<td>Delete Directory Tree</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osmkdir">os.mkdir</a></td>
<td>Create the specified directory</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osisdir">os.isdir</a></td>
<td>Determine if the directory exists</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osisfile">os.isfile</a></td>
<td>Determine if the file exists</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osexists">os.exists</a></td>
<td>Determine if a file or directory exists</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osdirs">os.dirs</a></td>
<td>Traversing to get all directories under the specified directory</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osfiles">os.files</a></td>
<td>Traversing to get all the files in the specified directory</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osfiledirs">os.filedirs</a></td>
<td>Traversing to get all files or directories under the specified directory</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osrun">os.run</a></td>
<td>Quiet running program</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osrunv">os.runv</a></td>
<td>Quiet running program with parameter list</td>
<td>>= 2.1.5</td>
</tr>
<tr>
<td><a href="#osexec">os.exec</a></td>
<td>Evoke Run Program</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osexecv">os.execv</a></td>
<td>Echo running program with parameter list</td>
<td>>= 2.1.5</td>
</tr>
<tr>
<td><a href="#osiorun">os.iorun</a></td>
<td>Run and get the program output</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osiorunv">os.iorunv</a></td>
<td>Run and get the program output with parameter list</td>
<td>>= 2.1.5</td>
</tr>
<tr>
<td><a href="#osgetenv">os.getenv</a></td>
<td>Get Environment Variables</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ossetenv">os.setenv</a></td>
<td>Setting environment variables</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ostmpdir">os.tmpdir</a></td>
<td>Get Temp directory path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ostmpfile">os.tmpfile</a></td>
<td>Get Temporary File Path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#oscurdir">os.curdir</a></td>
<td>Get current directory path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osfilesize">os.filesize</a></td>
<td>Get File Size</td>
<td>>= 2.1.9</td>
</tr>
<tr>
<td><a href="#osscriptdir">os.scriptdir</a></td>
<td>Get script directory path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#osprogramdir">os.programdir</a></td>
<td>Get xmake install main program script directory</td>
<td>>= 2.1.5</td>
</tr>
<tr>
<td><a href="#osprojectdir">os.projectdir</a></td>
<td>Get Project Home</td>
<td></td>
<td>= 2.1.5</td>
</tr>
<tr>
<td><a href="#osarch">os.arch</a></td>
<td>Get Current System Architecture</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#oshost">os.host</a></td>
<td>Get Current Host System</td>
<td>>= 2.0.1</td>
</tr>
</tbody>
</table>
<h4 id="oscp">os.cp</h4>
<ul>
<li>Copy files or directories</li>
</ul>
<p>The behavior is similar to the <code>cp</code> command in the shell, supporting path wildcard matching (using lua pattern matching), support for multi-file copying, and built-in variable support.</p>
<p>E.g:</p>
<pre><code class="lang-lua">os.cp("$(scriptdir)/*.h", "$(buildir)/inc")
os.cp("$(projectdir)/src/test/**.h", "$(buildir)/inc")
</code></pre>
<p>The above code will: all the header files in the current <code>xmake.lua</code> directory, the header files in the project source test directory are all copied to the <code>$(buildir)</code> output directory.</p>
<p>Among them <code>$(scriptdir)</code>, <code>$(projectdir)</code> These variables are built-in variables of xmake. For details, see the related documentation of <a href="#built-in variables">built-in variables</a>.</p>
<p>The matching patterns in <code>*.h</code> and <code>**.h</code> are similar to those in <a href="#targetadd_files">add_files</a>, the former is a single-level directory matching, and the latter is a recursive multi-level directory matching.</p>
<p>This interface also supports `recursive replication&#39; of directories, for example:</p>
<pre><code class="lang-lua">-- Recursively copy the current directory to a temporary directory
os.cp("$(curdir)/test/", "$(tmpdir)/test")
</code></pre>
<p>The copy at the top will expand and copy all files to the specified directory, and lose the source directory hierarchy. If you want to copy according to the directory structure that maintains it, you can set the rootdir parameter:</p>
<pre><code class="lang-lua">os.cp ("src/**.h", "/tmp/", {rootdir=""src"})
</code></pre>
<p>The above script can press the root directory of <code>src</code> to copy all sub-files under src in the same directory structure.</p>
<p><p class="tip"><br>Try to use the <code>os.cp</code> interface instead of <code>os.run("cp ..")</code>, which will ensure platform consistency and cross-platform build description.<br></p>

</p>
<h4 id="osmv">os.mv</h4>
<ul>
<li>Move to rename a file or directory</li>
</ul>
<p>Similar to the use of <a href="#oscp">os.cp</a>, it also supports multi-file move operations and pattern matching, for example:</p>
<pre><code class="lang-lua">-- Move multiple files to a temporary directory
os.mv("$(buildir)/test1", "$(tmpdir)")

-- File movement does not support bulk operations, which is file renaming
os.mv("$(buildir)/libtest.a", "$(buildir)/libdemo.a")
</code></pre>
<h4 id="osrm">os.rm</h4>
<ul>
<li>Delete files or directory trees</li>
</ul>
<p>Support for recursive deletion of directories, bulk delete operations, and pattern matching and built-in variables, such as:</p>
<pre><code class="lang-lua">os.rm("$(buildir)/inc/**.h", "$(buildir)/lib/")
</code></pre>
<h4 id="ostrycp">os.trycp</h4>
<ul>
<li>Try copying files or directories</li>
</ul>
<p>Similar to <a href="#oscp">os.cp</a>, the only difference is that this interface operation will not throw an exception interrupt xmake, but the return value indicates whether the execution is successful.</p>
<pre><code class="lang-lua">if os.trycp("file", "dest/file") then
end
</code></pre>
<h4 id="ostrymv">os.trymv</h4>
<ul>
<li>Try moving a file or directory</li>
</ul>
<p>Similar to <a href="#osmv">os.mv</a>, the only difference is that this interface operation will not throw an exception interrupt xmake, but the return value indicates whether the execution is successful.</p>
<pre><code class="lang-lua">if os.trymv("file", "dest/file") then
end
</code></pre>
<h4 id="ostryrm">os.tryrm</h4>
<ul>
<li>Try deleting files or directories</li>
</ul>
<p>Similar to <a href="#osrm">os.rm</a>, the only difference is that this interface operation will not throw an exception interrupt xmake, but the return value indicates whether the execution is successful.</p>
<pre><code class="lang-lua">if os.tryrm("file") then
end
</code></pre>
<h4 id="oscd">os.cd</h4>
<ul>
<li>Enter the specified directory</li>
</ul>
<p>This operation is used for directory switching and also supports built-in variables, but does not support pattern matching and multi-directory processing, for example:</p>
<pre><code class="lang-lua">-- Enter the temporary directory
os.cd("$(tmpdir)")
</code></pre>
<p>If you want to leave the previous directory, there are several ways:</p>
<pre><code class="lang-lua">-- Enter the parent directory
os.cd("..")

-- Enter the previous directory, equivalent to: cd -
os.cd("-")

-- Save the previous directory before entering the directory, then use it to cut back directly after the level
local oldir = os.cd("./src")
...
os.cd(oldir)
</code></pre>
<h4 id="osrmdir">os.rmdir</h4>
<ul>
<li>delete only the directory</li>
</ul>
<p>If it is not a directory, it cannot be deleted.</p>
<h4 id="osmkdir">os.mkdir</h4>
<ul>
<li>Create a directory</li>
</ul>
<p>Support for batch creation and built-in variables, such as:</p>
<pre><code class="lang-lua">os.mkdir("$(tmpdir)/test", "$(buildir)/inc")
</code></pre>
<h4 id="osisdir">os.isdir</h4>
<ul>
<li>Determine if it is a directory</li>
</ul>
<p>Return false if the directory does not exist</p>
<pre><code class="lang-lua">if os.isdir("src") then
    -- ...
end
</code></pre>
<h4 id="osisfile">os.isfile</h4>
<ul>
<li>Determine if it is a file</li>
</ul>
<p>Return false if the file does not exist</p>
<pre><code class="lang-lua">if os.isfile("$(buildir)/libxxx.a") then
    -- ...
end
</code></pre>
<h4 id="osexists">os.exists</h4>
<ul>
<li>Determine if a file or directory exists</li>
</ul>
<p>Return false if the file or directory does not exist</p>
<pre><code class="lang-lua">-- Judging the existence of the directory
if os.exists("$(buildir)") then
    -- ...
end

-- Judging the existence of the file
if os.exists("$(buildir)/libxxx.a") then
    -- ...
end
</code></pre>
<h4 id="osdirs">os.dirs</h4>
<ul>
<li>Traverse to get all the directories under the specified directory</li>
</ul>
<p>Supports pattern matching in <a href="#targetadd_files">add_files</a>, supports recursive and non-recursive mode traversal, and returns a table array. If not, returns an empty array, for example:</p>
<pre><code class="lang-lua">-- Recursive traversal to get all subdirectories
for _, dir in ipairs(os.dirs("$(buildir)/inc/**")) do
    print(dir)
end
</code></pre>
<h4 id="osfiles">os.files</h4>
<ul>
<li>Traverse to get all the files in the specified directory</li>
</ul>
<p>Supports pattern matching in <a href="#targetadd_files">add_files</a>, supports recursive and non-recursive mode traversal, and returns a table array. If not, returns an empty array, for example:</p>
<pre><code class="lang-lua">-- Non-recursive traversal to get all child files
for _, filepath in ipairs(os.files("$(buildir)/inc/*.h")) do
    print(filepath)
end
</code></pre>
<h4 id="osfiledirs">os.filedirs</h4>
<ul>
<li>Traverse to get all files and directories under the specified directory</li>
</ul>
<p>Supports pattern matching in <a href="#targetadd_files">add_files</a>, supports recursive and non-recursive mode traversal, and returns a table array. If not, returns an empty array, for example:</p>
<pre><code class="lang-lua">-- Recursive traversal to get all child files and directories
for _, filedir in ipairs(os.filedirs("$(buildir)/**")) do
    print(filedir)
end
</code></pre>
<h4 id="osrun">os.run</h4>
<ul>
<li>Quietly running native shell commands</li>
</ul>
<p>Used to execute third-party shell commands, but will not echo the output, only after the error, highlight the error message.</p>
<p>This interface supports parameter formatting and built-in variables such as:</p>
<pre><code class="lang-lua">-- Formatted parameters passed in
os.run("echo hello %s!", "xmake")

-- List build directory files
os.run("ls -l $(buildir)")
</code></pre>
<p><p class="warn"><br>Using this interface to execute shell commands can easily reduce the cross-platform build. For <code>os.run("cp ..")</code>, try to use <code>os.cp</code> instead. <br><br>If you must use this interface to run the shell program, please use the <a href="#config-plat">config.plat</a> interface to determine the platform support.<br></p>

</p>
<p>For more advanced process operations and control, see the <a href="#process">process</a> module interface.</p>
<h4 id="osrunv">os.runv</h4>
<ul>
<li>Quietly running native shell commands with parameter list</li>
</ul>
<p>Similar to <a href="#osrun">os.run</a>, just the way to pass parameters is passed through the parameter list, not the string command, for example:</p>
<pre><code class="lang-lua">os.runv("echo", {"hello", "xmake!"})
</code></pre>
<h4 id="osexec">os.exec</h4>
<ul>
<li>Echo running native shell commands</li>
</ul>
<p>Similar to the <a href="#osrun">os.run</a> interface, the only difference is that when this interface executes the shell program, it has the output output, which is used in general debugging.</p>
<h4 id="osexecv">os.execv</h4>
<ul>
<li>Echo running native shell commands with parameter list</li>
</ul>
<p>Similar to <a href="#osexec">os.exec</a>, just the way to pass parameters is passed through the parameter list, not the string command, for example:</p>
<pre><code class="lang-lua">os.execv("echo", {"hello", "xmake!"})
os.execv("echo", {"hello", "xmake!"}, {stdout = "/tmp/out", stderr = io.open("/tmp/err", &#39;w&#39;)})
os.execv("echo", {"hello", "xmake!"}, {envs = {PATH="..."}})
</code></pre>
<h4 id="osiorun">os.iorun</h4>
<ul>
<li>Quietly running native shell commands and getting output</li>
</ul>
<p>Similar to the <a href="#osrun">os.run</a> interface, the only difference is that after executing the shell program, this interface will get the execution result of the shell program, which is equivalent to redirecting the output.</p>
<p>You can get the contents of <code>stdout</code>, <code>stderr</code> at the same time, for example:</p>
<pre><code class="lang-lua">local outdata, errdata = os.iorun("echo hello xmake!")
</code></pre>
<h4 id="osiorunv">os.iorunv</h4>
<ul>
<li>Run the native shell command quietly and get the output with a list of parameters</li>
</ul>
<p>Similar to <a href="#osiorun">os.iorun</a>, just the way to pass arguments is passed through the argument list, not the string command, for example:</p>
<pre><code class="lang-lua">local outdata, errdata = os.iorunv("echo", {"hello", "xmake!"})
local outdata, errdata = os.iorunv("echo", {"hello", "xmake!"}, {envs = {PATH="..."}})
</code></pre>
<h4 id="osgetenv">os.getenv</h4>
<ul>
<li>Get system environment variables</li>
</ul>
<pre><code class="lang-lua">print(os.getenv("PATH"))
</code></pre>
<h4 id="ossetenv">os.setenv</h4>
<ul>
<li>Set system environment variables</li>
</ul>
<pre><code class="lang-lua">os.setenv("HOME", "/tmp/")
</code></pre>
<h4 id="ostmpdir">os.tmpdir</h4>
<ul>
<li>Get temporary directory</li>
</ul>
<p>Consistent with the result of <a href="#var-tmpdir">$(tmpdir)</a>, it is just a direct return to return a variable that can be maintained with subsequent strings.</p>
<pre><code class="lang-lua">print(path.join(os.tmpdir(), "file.txt"))
</code></pre>
<p>Equivalent to:</p>
<pre><code class="lang-lua">print("$(tmpdir)/file.txt")
</code></pre>
<h4 id="ostmpfile">os.tmpfile</h4>
<ul>
<li>Get temporary file path</li>
</ul>
<p>Used to get a temporary file path, just a path, the file needs to be created by itself.</p>
<h4 id="oscurdir">os.curdir</h4>
<ul>
<li>Get the current directory path</li>
</ul>
<p>Consistent with the result of <a href="#var-curdir">$(curdir)</a>, it is just a direct return to return a variable that can be maintained with subsequent strings.</p>
<p>Usage reference: <a href="#ostmpdir">os.tmpdir</a>.</p>
<h4 id="osfilesize">os.filesize</h4>
<ul>
<li>Get file size</li>
</ul>
<pre><code class="lang-lua">print(os.filesize("/tmp/a"))
</code></pre>
<h4 id="osscriptdir">os.scriptdir</h4>
<ul>
<li>Get the path of the current description script</li>
</ul>
<p>Consistent with the result of <a href="#var-scriptdir">$(scriptdir)</a>, it is just a direct return to return a variable that can be maintained with subsequent strings.</p>
<p>Usage reference: <a href="#ostmpdir">os.tmpdir</a>.</p>
<h4 id="osprogramdir">os.programdir</h4>
<ul>
<li>Get the xmake installation main program script directory</li>
</ul>
<p>Consistent with the result of <a href="#var-programdir">$(programdir)</a>, it is just a direct get returned to a variable, which can be maintained with subsequent strings.</p>
<h4 id="osprojectdir">os.projectdir</h4>
<ul>
<li>Get the project home directory</li>
</ul>
<p>Consistent with the result of <a href="#var-projectdir">$(projectdir)</a>, it is just a direct return to return a variable that can be maintained with subsequent strings.</p>
<h4 id="osarch">os.arch</h4>
<ul>
<li>Get current system architecture</li>
</ul>
<p>That is the default architecture of the current host system, for example, I execute xmake on <code>linux x86_64</code> to build, then the return value is: <code>x86_64</code></p>
<h4 id="oshost">os.host</h4>
<ul>
<li>Get the operating system of the current host</li>
</ul>
<p>Consistent with the result of <a href="#var-host">$(host)</a>, for example, if I execute xmake on <code>linux x86_64</code> to build, the return value is: <code>linux</code></p>
<h3 id="io">io</h3>
<p>The io operation module extends lua&#39;s built-in io module to provide more easy-to-use interfaces.</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
<th>Supported Versions</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#ioopen">io.open</a></td>
<td>Open file for reading and writing</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ioload">io.load</a></td>
<td>De-serialize all table contents from the specified path file</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#iosave">io.save</a></td>
<td>Serialize all table contents to the specified path file</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#io.readfile">io.readfile</a></td>
<td>Read everything from the specified path file</td>
<td>>= 2.1.3</td>
</tr>
<tr>
<td><a href="#io.writefile">io.writefile</a></td>
<td>Write everything to the specified path file</td>
<td>>= 2.1.3</td>
</tr>
<tr>
<td><a href="#iogsub">io.gsub</a></td>
<td>Full text replaces the contents of the specified path file</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#iotail">io.tail</a></td>
<td>Read and display the tail of the file</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#iocat">io.cat</a></td>
<td>Read and display all contents of a file</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ioprint">io.print</a></td>
<td>Formatting output with a line feed to a file</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#ioprintf">io.printf</a></td>
<td>No line formatted output to file</td>
<td>>= 2.0.1</td>
</tr>
</tbody>
</table>
<h4 id="ioopen">io.open</h4>
<ul>
<li>Open file for reading and writing</li>
</ul>
<p>This is a native interface for lua. For detailed usage, see Lua&#39;s official documentation: <a href="https://www.lua.org/pil/21.2.html">The Complete I/O Model</a></p>
<p>If you want to read all the contents of the file, you can write:</p>
<pre><code class="lang-lua">local file = io.open("$(tmpdir)/file.txt", "r")
if file then
    local data = file:read("*all")
    file:close()
end
</code></pre>
<p>Or you can read it more quickly using <a href="#io.readfile">io.readfile</a>.</p>
<p>If you want to write a file, you can do this:</p>
<pre><code class="lang-lua">-- Open file: w is write mode, a is append write mode
local file = io.open("xxx.txt", "w")
if file then

    -- Write data to file with native lua interface, does not support formatting, no line breaks, does not support built-in variables
    file:write("hello xmake\n")

    -- Write data to file with xmake extended interface, support formatting, no line breaks, no built-in variables
    file:writef("hello %s\n", "xmake")

    -- Use xmake extended formatted parameters to write to one line, with line breaks, and support for built-in variables
    file:print("hello %s and $(buildir)", "xmake")

    -- Write a line using the xmake extended formatted arguments, no line breaks, and support for built-in variables
    file:printf("hello %s and $(buildir) \n", "xmake")

    -- Close the file
    file:close()
end
</code></pre>
<h4 id="ioload">io.load</h4>
<ul>
<li>Load all table contents from the specified path file deserialization</li>
</ul>
<p>You can load serialized table contents from a file, generally used with <a href="#iosave">io.save</a>, for example:</p>
<pre><code class="lang-lua">-- Load the contents of the serialized file to the table
local data = io.load("xxx.txt")
if data then

    -- Dump prints the contents of the entire table in the terminal, formatting the output
    utils.dump(data)
end
</code></pre>
<h4 id="iosave">io.save</h4>
<ul>
<li>Serialize all table contents to the specified path file</li>
</ul>
<p>You can serialize the contents of the table to the specified file, generally used in conjunction with <a href="#ioload">io.load</a>, for example:</p>
<pre><code class="lang-lua">io.save("xxx.txt", {a = "a", b = "b", c = "c"})
</code></pre>
<p>The result of the storage is:</p>
<pre><code>{
    ["b"] = "b"
,   ["a"] = "a"
,   ["c"] = "c"
}
</code></pre><h4 id="ioreadfile">io.readfile</h4>
<ul>
<li>Read everything from the specified path file</li>
</ul>
<p>It is more convenient to directly read the contents of the entire file without opening the file, for example:</p>
<pre><code class="lang-lua">local data = io.readfile("xxx.txt")
</code></pre>
<h4 id="iowritefile">io.writefile</h4>
<ul>
<li>Write all content to the specified path file</li>
</ul>
<p>It is more convenient to directly write the contents of the entire file without opening the file, for example:</p>
<pre><code class="lang-lua">io.writefile("xxx.txt", "all data")
</code></pre>
<h4 id="iogsub">io.gsub</h4>
<ul>
<li>Full text replaces the contents of the specified path file</li>
</ul>
<p>Similar to the <a href="#stringgsub">string.gsub</a> interface, the full-text pattern matches the replacement content, but here is the direct operation file, for example:</p>
<pre><code class="lang-lua">-- Remove all whitespace characters from the file
io.gsub("xxx.txt", "%s+", "")
</code></pre>
<h4 id="iotail">io.tail</h4>
<ul>
<li>Read and display the tail content of the file</li>
</ul>
<p>Reads the data of the specified number of lines at the end of the file and displays a command like <code>cat xxx.txt | tail -n 10</code>, for example:</p>
<pre><code class="lang-lua">-- Display the last 10 lines of the file
io.tail("xxx.txt", 10)
</code></pre>
<h4 id="iocat">io.cat</h4>
<ul>
<li>read and display all contents of the file</li>
</ul>
<p>Read all the contents of the file and display it, similar to the <code>cat xxx.txt</code> command, for example:</p>
<pre><code class="lang-lua">io.cat("xxx.txt")
</code></pre>
<h4 id="ioprint">io.print</h4>
<ul>
<li>Formatted output content to file with newline</li>
</ul>
<p>Directly format the passed parameter to output a line of string to the file with a line break, for example:</p>
<pre><code class="lang-lua">io.print("xxx.txt", "hello %s!", "xmake")
</code></pre>
<h4 id="ioprintf">io.printf</h4>
<ul>
<li>Formatted output to file without line breaks</li>
</ul>
<p>Directly format the passed parameter to output a line of string to the file without a line break, for example:</p>
<pre><code class="lang-lua">io.printf("xxx.txt", "hello %s!\n", "xmake")
</code></pre>
<h3 id="path">path</h3>
<p>The path operation module implements cross-platform path operations, which is a custom module of xmake.</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
<th>Supported Versions</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#pathjoin">path.join</a></td>
<td>Stitching Path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathtranslate">path.translate</a></td>
<td>Convert path to the path style of the current platform</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathbasename">path.basename</a></td>
<td>Get the file name with no suffix at the end</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathfilename">path.filename</a></td>
<td>Get the file name with the last suffix of the path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathextension">path.extension</a></td>
<td>Get the suffix of the path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathdirectory">path.directory</a></td>
<td>Get the last directory name of the path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathrelative">path.relative</a></td>
<td>Convert to relative path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathabsolute">path.absolute</a></td>
<td>Convert to Absolute Path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathis_absolute">path.is_absolute</a></td>
<td>Determine if it is an absolute path</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#pathsplitenv">path.splitenv</a></td>
<td>Split a envienment variable value of an array of pathes</td>
<td>>= 2.2.7</td>
</tr>
</tbody>
</table>
<h4 id="pathjoin">path.join</h4>
<ul>
<li>Stitching path</li>
</ul>
<p>Adding multiple path items by splicing. Due to the path difference of <code>windows/unix</code> style, using api to append paths is more cross-platform, for example:</p>
<pre><code class="lang-lua">print(path.join("$(tmpdir)", "dir1", "dir2", "file.txt"))
</code></pre>
<p>The above splicing on Unix is equivalent to: <code>$(tmpdir)/dir1/dir2/file.txt</code>, and on Windows is equivalent to: <code>$(tmpdir)\\dir1\\dir2\\file.txt</code></p>
<p>If you find this cumbersome and not clear enough, you can use: <a href="#pathtranslate">path.translate</a> to format the conversion path string to the format supported by the current platform.</p>
<h4 id="pathtranslate">path.translate</h4>
<ul>
<li>Convert path to the path style of the current platform</li>
</ul>
<p>Formatting converts the specified path string to the path style supported by the current platform, and supports the path string parameter of the <code>windows/unix</code> format to be passed in, even mixed, such as:</p>
<pre><code class="lang-lua">print(path.translate("$(tmpdir)/dir/file.txt"))
print(path.translate("$(tmpdir)\\dir\\file.txt"))
print(path.translate("$(tmpdir)\\dir/dir2//file.txt"))
</code></pre>
<p>The path strings of the above three different formats, after being standardized by <code>translate</code>, will become the format supported by the current platform, and the redundant path separator will be removed.</p>
<h4 id="pathbasename">path.basename</h4>
<ul>
<li>Get the file name with no suffix at the end of the path</li>
</ul>
<pre><code class="lang-lua">print(path.basename("$(tmpdir)/dir/file.txt"))
</code></pre>
<p>The result is: <code>file</code></p>
<h4 id="pathfilename">path.filename</h4>
<ul>
<li>Get the file name with the last suffix of the path</li>
</ul>
<pre><code class="lang-lua">print(path.filename("$(tmpdir)/dir/file.txt"))
</code></pre>
<p>The result is: <code>file.txt</code></p>
<h4 id="pathextension">path.extension</h4>
<ul>
<li>Get the suffix of the path</li>
</ul>
<pre><code class="lang-lua">print(path.extensione("$(tmpdir)/dir/file.txt"))
</code></pre>
<p>The result is: <code>.txt</code></p>
<h4 id="pathdirectory">path.directory</h4>
<ul>
<li>Get the last directory name of the path</li>
</ul>
<pre><code class="lang-lua">Print(path.directory("$(tmpdir)/dir/file.txt"))
</code></pre>
<p>The result is: <code>dir</code></p>
<h4 id="pathrelative">path.relative</h4>
<ul>
<li>Convert to relative path</li>
</ul>
<pre><code class="lang-lua">print(path.relative("$(tmpdir)/dir/file.txt", "$(tmpdir)"))
</code></pre>
<p>The result is: <code>dir/file.txt</code></p>
<p>The second parameter is to specify the relative root directory. If not specified, the default is relative to the current directory:</p>
<pre><code class="lang-lua">os.cd("$(tmpdir)")
print(path.relative("$(tmpdir)/dir/file.txt"))
</code></pre>
<p>The result is the same.</p>
<h4 id="pathabsolute">path.absolute</h4>
<ul>
<li>Convert to absolute path</li>
</ul>
<pre><code class="lang-lua">print(path.absolute("dir/file.txt", "$(tmpdir)"))
</code></pre>
<p>The result is: <code>$(tmpdir)/dir/file.txt</code></p>
<p>The second parameter is to specify the relative root directory. If not specified, the default is relative to the current directory:</p>
<pre><code class="lang-lua">os.cd("$(tmpdir)")
print(path.absolute("dir/file.txt"))
</code></pre>
<p>The result is the same.</p>
<h4 id="pathis_absolute">path.is_absolute</h4>
<ul>
<li>Determine if it is an absolute path</li>
</ul>
<pre><code class="lang-lua">if path.is_absolute("/tmp/file.txt") then
    -- if it is an absolute path
end
</code></pre>
<h4 id="pathsplitenv">path.splitenv</h4>
<ul>
<li>Split a envienment variable value of an array of pathes</li>
</ul>
<pre><code class="lang-lua">local pathes = path.splitenv(vformat("$(env PATH)"))

-- for windows 
local pathes = path.splitenv("C:\\Windows;C:\\Windows\\System32")
-- got { "C:\\Windows", "C:\\Windows\\System32" }

-- for *nix 
local pathes = path.splitenv("/usr/bin:/usr/local/bin")
-- got { "/usr/bin", "/usr/local/bin" }
</code></pre>
<p>The result is an array of strings, each item is a path in the input string.</p>
<h3 id="table">table</h3>
<p>Table belongs to the module provided by Lua native. For the native interface, you can refer to: <a href="https://www.lua.org/manual/5.1/manual.html#5.5">lua official document</a></p>
<p>It has been extended in xmake to add some extension interfaces:</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
<th>Supported Versions</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#tablejoin">table.join</a></td>
<td>Merge multiple tables and return</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#tablejoin2">table.join2</a></td>
<td>Merge multiple tables into the first table</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#tableunique">table.unique</a></td>
<td>Deduplicate the contents of the table</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#tableslice">table.slice</a></td>
<td>Get the slice of the table</td>
<td>>= 2.0.1</td>
</tr>
</tbody>
</table>
<h4 id="tablejoin">table.join</h4>
<ul>
<li>Merge multiple tables and return</li>
</ul>
<p>You can merge the elements in multiple tables and return to a new table, for example:</p>
<pre><code class="lang-lua">local newtable = table.join({1, 2, 3}, {4, 5, 6}, {7, 8, 9})
</code></pre>
<p>The result is: <code>{1, 2, 3, 4, 5, 6, 7, 8, 9}</code></p>
<p>And it also supports the merging of dictionaries:</p>
<pre><code class="lang-lua">local newtable = table.join({a = "a", b = "b"}, {c = "c"}, {d = "d"})
</code></pre>
<p>The result is: <code>{a = "a", b = "b", c = "c", d = "d"}</code></p>
<h4 id="tablejoin2">table.join2</h4>
<ul>
<li>Combine multiple tables into the first table</li>
</ul>
<p>Similar to <a href="#table.join">table.join</a>, the only difference is that the result of the merge is placed in the first argument, for example:</p>
<pre><code class="lang-lua">local t = {0, 9}
table.join2(t, {1, 2, 3})
</code></pre>
<p>The result is: <code>t = {0, 9, 1, 2, 3}</code></p>
<h4 id="tableunique">table.unique</h4>
<ul>
<li>Deduplicate the contents of the table</li>
</ul>
<p>To de-table elements, generally used in array tables, for example:</p>
<pre><code class="lang-lua">local newtable = table.unique({1, 1, 2, 3, 4, 4, 5})
</code></pre>
<p>The result is: <code>{1, 2, 3, 4, 5}</code></p>
<h4 id="tableslice">table.slice</h4>
<ul>
<li>Get the slice of the table</li>
</ul>
<p>Used to extract some elements of an array table, for example:</p>
<pre><code class="lang-lua">-- Extract all elements after the 4th element, resulting in: {4, 5, 6, 7, 8, 9}
table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4)

-- Extract the 4th-8th element and the result: {4, 5, 6, 7, 8}
table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4, 8)

-- Extract the 4th-8th element with an interval of 2, resulting in: {4, 6, 8}
table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4, 8, 2)
</code></pre>
<h3 id="string">string</h3>
<p>The string module is a native module of lua. For details, see: <a href="https://www.lua.org/manual/5.1/manual.html#5.4">lua official manual</a></p>
<p>It has been extended in xmake to add some extension interfaces:</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
<th>Supported Versions</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#stringstartswith">string.startswith</a></td>
<td>Determine if the beginning of the string matches</td>
<td>>= 1.0.1</td>
</tr>
<tr>
<td><a href="#stringendswith">string.endswith</a></td>
<td>Determine if the end of the string matches</td>
<td>>= 1.0.1</td>
</tr>
<tr>
<td><a href="#stringsplit">string.split</a></td>
<td>Split String</td>
<td>>= 1.0.1</td>
</tr>
<tr>
<td><a href="#stringtrim">string.trim</a></td>
<td>Remove the left and right whitespace characters</td>
<td>>= 1.0.1</td>
</tr>
<tr>
<td><a href="#stringltrim">string.ltrim</a></td>
<td>Remove the whitespace character to the left of the string</td>
<td>>= 1.0.1</td>
</tr>
<tr>
<td><a href="#stringrtrim">string.rtrim</a></td>
<td>Remove the whitespace character to the right of the string</td>
<td>>= 1.0.1</td>
</tr>
</tbody>
</table>
<h4 id="stringstartswith">string.startswith</h4>
<ul>
<li>Determine if the beginning of the string matches</li>
</ul>
<pre><code class="lang-lua">local s = "hello xmake"
if s:startswith("hello") then
    print("match")
end
</code></pre>
<h4 id="stringendswith">string.endswith</h4>
<ul>
<li>Determine if the end of the string matches</li>
</ul>
<pre><code class="lang-lua">local s = "hello xmake"
if s:endswith("xmake") then
    print("match")
end
</code></pre>
<h4 id="stringsplit">string.split</h4>
<p>pattern match and ignore empty string</p>
<pre><code class="lang-lua">("1\n\n2\n3"):split(&#39;\n&#39;) => 1, 2, 3
("abc123123xyz123abc"):split(&#39;123&#39;) => abc, xyz, abc
("abc123123xyz123abc"):split(&#39;[123]+&#39;) => abc, xyz, abc
</code></pre>
<p>plain match and ignore empty string</p>
<pre><code class="lang-lua">("1\n\n2\n3"):split(&#39;\n&#39;, {plain = true}) => 1, 2, 3
("abc123123xyz123abc"):split(&#39;123&#39;, {plain = true}) => abc, xyz, abc
</code></pre>
<p>pattern match and contains empty string</p>
<pre><code class="lang-lua">("1\n\n2\n3"):split(&#39;\n&#39;, {strict = true}) => 1, , 2, 3
("abc123123xyz123abc"):split(&#39;123&#39;, {strict = true}) => abc, , xyz, abc
("abc123123xyz123abc"):split(&#39;[123]+&#39;, {strict = true}) => abc, xyz, abc
</code></pre>
<p>plain match and contains empty string</p>
<pre><code class="lang-lua">("1\n\n2\n3"):split(&#39;\n&#39;, {plain = true, strict = true}) => 1, , 2, 3
("abc123123xyz123abc"):split(&#39;123&#39;, {plain = true, strict = true}) => abc, , xyz, abc
</code></pre>
<p>limit split count</p>
<pre><code class="lang-lua">("1\n\n2\n3"):split(&#39;\n&#39;, {limit = 2}) => 1, 2\n3
("1.2.3.4.5"):split(&#39;%.&#39;, {limit = 3}) => 1, 2, 3.4.5
</code></pre>
<h4 id="stringtrim">string.trim</h4>
<ul>
<li>Remove the left and right whitespace characters of the string</li>
</ul>
<pre><code class="lang-lua">string.trim("    hello xmake!    ")
</code></pre>
<p>The result is: "hello xmake!"</p>
<h4 id="stringltrim">string.ltrim</h4>
<ul>
<li>Remove the whitespace character to the left of the string</li>
</ul>
<pre><code class="lang-lua">string.ltrim("    hello xmake!    ")
</code></pre>
<p>The result is: "hello xmake!    "</p>
<h4 id="stringrtrim">string.rtrim</h4>
<ul>
<li>Remove the whitespace character to the right of the string</li>
</ul>
<pre><code class="lang-lua">string.rtrim("    hello xmake!    ")
</code></pre>
<p>The result is: "    hello xmake!"</p>
<h3 id="process">process</h3>
<p>This is the xmake extension&#39;s process control module for more flexible control of the process, compared to: <a href="#osrun">os.run</a> series is more flexible and lower level.</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>Description</th>
<th>Supported Versions</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#processopen">process.open</a></td>
<td>Open Process</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#processopenv">process.openv</a></td>
<td>Open Process with arguments list</td>
<td>>= 2.0.1</td>
</tr>
<tr>
<td><a href="#processwaitlist">process.waitlist</a></td>
<td>Waiting for multiple processes at the same time</td>
<td>>= 2.0.1</td>
</tr>
</tbody>
</table>
<h4 id="processopen">process.open</h4>
<ul>
<li>Open the process</li>
</ul>
<p>Run a specified program through path creation and return the corresponding process object:</p>
<pre><code class="lang-lua">-- Open the process, the last two parameters specify the stdout to be captured, the stderr file path
local proc = process.open("echo hello xmake!", {outpath = "", errpath = ""})
if proc then

    -- Waiting for the process to complete
    --
    -- Parameter 1 is waiting for timeout, -1 is permanent waiting, 0 is trying to get process status
    -- Return value waitok is wait state: 1 is waiting for the process to end normally, 0 is the process is still running, -1 bit is waiting to fail
    -- The return value status is the status code returned by the process after waiting for the process to end.
    local waitok, status = proc:wait(-1)

    -- release process object
    proc:close()
end
</code></pre>
<p>In the open parameter above, the outpath and errpath parameters specify the stdout and stderr file paths to be captured.</p>
<p>In addition, if you want to temporarily set and rewrite some environment variables during this execution, you can pass the envs parameter. The environment variable settings inside will replace the existing settings, but they will not affect the outer execution environment, only the current command.</p>
<p>We can also get all current environment variables through the <code>os.getenvs()</code> interface, and then pass the envs parameter after rewriting part.</p>
<h4 id="processopenv">process.openv</h4>
<ul>
<li>Open the process and pass the parameter list</li>
</ul>
<p>This interface is basically similar to <a href="#processopen">process.open</a>. The only difference is that you pass a command with a parameter list to execute instead of passing a command string. This will save unnecessary escaping. The input parameters are more reliable, and the compatibility and efficiency are better.</p>
<p><code>`lua
local proc = process.openv("echo", {"hello", "xmake!"})</code> `</p>
<h4 id="processwaitlist">process.waitlist</h4>
<ul>
<li>Waiting for multiple processes at the same time</li>
</ul>
<pre><code class="lang-lua">-- The second parameter is waiting for a timeout, returning a list of process states
for _, procinfo in ipairs(process.waitlist(procs, -1)) do

    -- For each process: process object, process pid, process end status code
    local proc   = procinfo[1]
    local procid = procinfo[2]
    local status = procinfo[3]

end
</code></pre>
<h3 id="coroutine">coroutine</h3>
<p>The coroutine module is a native module of lua. For use, see: <a href="https://www.lua.org/manual/5.1/manual.html#5.2">lua official manual</a></p>
</article>
</body>
</html>